btl_debPrint2( "\n>>> [btl_StdMoveTbl]" );


//すごい長い関数
//_ChrNo:キャラ番号を指定する

function Battle_Std::GetStdMoveTable( _ChrNo=0, ) {

// ----------------------------------------------------------------------------
//キャラクター別のmvを作るとき用の関数
// ----------------------------------------------------------------------------
_dp1p("\n[btl_ChrParamFunc]");
local CHRMAX = 32; //キャラ番号最大値
local chrparam = {};

chrparam.Param <- {}; //キャラ別の細かいフレームとかのテーブル
chrparam.Get <- function( tbl={} ) //chrparam.Paramから作成中のキャラ番号の値を取ってくる
{
	local checktype = tbl.type;
	local checkchrnum = tbl.chrnum;
	
	if( checktype in Param )
	{
		local ret = Param[checktype][checkchrnum];
		btl_debPrint_CharacterMake("【定義】chrparam:"+checktype+" chr:"+checkchrnum+" -> "+ret);
		return ret;
	}
	else
	{
		btl_debError_CharacterMake("【警告】chrparamで未定義:"+checktype+" chr:"+checkchrnum);
		return 0;
	}
}
	
{	//ダッシュのタメの硬直フレーム
	//この時間が経過するとDashWaitからDash_FのMvへ移行する
	//パターンは変化しないので注意
	local type = "ダッシュでかかり硬直Ｆ";
	chrparam.Param[type] <- array(CHRMAX, 4);
	chrparam.Param[type][Def_ChrNo_Hyd] = 4;
	chrparam.Param[type][Def_ChrNo_Lin] = 3;
	chrparam.Param[type][Def_ChrNo_Wal] = 8;
	chrparam.Param[type][Def_ChrNo_Car] = 7;
	chrparam.Param[type][Def_ChrNo_Ori] = 5;
	chrparam.Param[type][Def_ChrNo_Gor] = 6;
	chrparam.Param[type][Def_ChrNo_Mer] = 4;
	chrparam.Param[type][Def_ChrNo_Vat] = 4;
	chrparam.Param[type][Def_ChrNo_Set] = 6;
	chrparam.Param[type][Def_ChrNo_Yuz] = 6;
	chrparam.Param[type][Def_ChrNo_Hil] = 6;
	chrparam.Param[type][Def_ChrNo_Elt] = 3;
	chrparam.Param[type][Def_ChrNo_Nan] = 3;
	chrparam.Param[type][Def_ChrNo_Bya] = 4;
	chrparam.Param[type][Def_ChrNo_Aka] = 5;
	chrparam.Param[type][Def_ChrNo_Cha] = 4;
	chrparam.Param[type][Def_ChrNo_Wag] = 5;
	chrparam.Param[type][Def_ChrNo_Enk] = 4;
	chrparam.Param[type][Def_ChrNo_Lnd] = 4;
	chrparam.Param[type][Def_ChrNo_Mik] = 5;
	chrparam.Param[type][Def_ChrNo_Pho] = 5;
	chrparam.Param[type][Def_ChrNo_Kag] = 4;
	chrparam.Param[type][Def_ChrNo_Tsu] = 4;
	chrparam.Param[type][Def_ChrNo_Kuo] = 4;
	chrparam.Param[type][Def_ChrNo_Udu] = 5;
}

{	// ダッシュ停止不能Ｆ
	//ダッシュのタメを抜けてから、とまれるようになるまでの時間）
	//行動可能になってからどれだけの間停止に移行できないか
	//FrameID100があって停止できるMvでないと意味がない
	//これが長いと小刻みな動きができなくなる
	//少なすぎると慣性つけたダッシュ弱攻撃をやるのがやや難しくなる
	//停止モーションまでいけばリセット（ガードできる）ので"ダッシュガード不能Ｆ"より長くてもＯＫ
	local type = "ダッシュ停止不能Ｆ";
	chrparam.Param[type] <- array(CHRMAX, 4);
	chrparam.Param[type][Def_ChrNo_Hyd] = 4;
	chrparam.Param[type][Def_ChrNo_Lin] = 6;
	chrparam.Param[type][Def_ChrNo_Wal] = -1; //任意停止はない
	chrparam.Param[type][Def_ChrNo_Car] = 4;
	chrparam.Param[type][Def_ChrNo_Ori] = 4;
	chrparam.Param[type][Def_ChrNo_Gor] = 4;
	chrparam.Param[type][Def_ChrNo_Mer] = 8;
	chrparam.Param[type][Def_ChrNo_Vat] = -1; //任意停止はない
	chrparam.Param[type][Def_ChrNo_Set] = 3; //ダッシュガード苦手
	chrparam.Param[type][Def_ChrNo_Yuz] = 4;
	chrparam.Param[type][Def_ChrNo_Hil] = 12;
	chrparam.Param[type][Def_ChrNo_Elt] = 4;
	chrparam.Param[type][Def_ChrNo_Nan] = 4;
	chrparam.Param[type][Def_ChrNo_Bya] = 4;
	chrparam.Param[type][Def_ChrNo_Aka] = -1; //任意停止はない
	chrparam.Param[type][Def_ChrNo_Cha] = 4;
	chrparam.Param[type][Def_ChrNo_Wag] = 4;
	chrparam.Param[type][Def_ChrNo_Enk] = 4;
	chrparam.Param[type][Def_ChrNo_Lnd] = 5;
	chrparam.Param[type][Def_ChrNo_Mik] = 4;
	chrparam.Param[type][Def_ChrNo_Pho] = 5;
	chrparam.Param[type][Def_ChrNo_Kag] = 4;
	chrparam.Param[type][Def_ChrNo_Tsu] = 4;
	chrparam.Param[type][Def_ChrNo_Kuo] = 7;
	chrparam.Param[type][Def_ChrNo_Udu] = 9;
}

{	//ダッシュ停止やMv抜けのときのベクトル係数
	local type = "ダッシュ停止慣性";
	// 慣性係数, 収束F, 慣性最大値, 慣性最大値に対して1フレーム毎に加算される値
	chrparam.Param[type] <- array(CHRMAX, [100,10,2700,200]);
	chrparam.Param[type][Def_ChrNo_Hyd] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Lin] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Wal] = [100,14,   0,  0];
	chrparam.Param[type][Def_ChrNo_Car] = [100,10,2700,250];
	chrparam.Param[type][Def_ChrNo_Ori] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Gor] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Mer] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Vat] = [100,10,   0,  0];
	chrparam.Param[type][Def_ChrNo_Set] = [100,10,2700,250];
	chrparam.Param[type][Def_ChrNo_Yuz] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Hil] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Elt] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Nan] = [100,12,2700,200];
	chrparam.Param[type][Def_ChrNo_Bya] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Aka] = [100,10,   0,  0];
	chrparam.Param[type][Def_ChrNo_Cha] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Wag] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Enk] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Lnd] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Mik] = [100,10,2700,250];
	chrparam.Param[type][Def_ChrNo_Pho] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Kag] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Tsu] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Kuo] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Udu] = [100,10,2700,200];
}

{	//ダッシュジャンプの慣性
	//ベクトル * この値 / 100
	local type = "ダッシュジャンプ慣性";
	chrparam.Param[type] <- array(CHRMAX, 17);
	chrparam.Param[type][Def_ChrNo_Hyd] = 17;
	chrparam.Param[type][Def_ChrNo_Lin] = 20;
	chrparam.Param[type][Def_ChrNo_Wal] = 17;
	chrparam.Param[type][Def_ChrNo_Car] = 17;
	chrparam.Param[type][Def_ChrNo_Ori] = 17;
	chrparam.Param[type][Def_ChrNo_Gor] = 17;
	chrparam.Param[type][Def_ChrNo_Mer] = 17;
	chrparam.Param[type][Def_ChrNo_Vat] = 17;
	chrparam.Param[type][Def_ChrNo_Set] = 17;
	chrparam.Param[type][Def_ChrNo_Yuz] = 17;
	chrparam.Param[type][Def_ChrNo_Hil] = 17;
	chrparam.Param[type][Def_ChrNo_Elt] = 25;
	chrparam.Param[type][Def_ChrNo_Nan] = 25;
	chrparam.Param[type][Def_ChrNo_Bya] = 17;
	chrparam.Param[type][Def_ChrNo_Aka] = 20;
	chrparam.Param[type][Def_ChrNo_Cha] = 17;
	chrparam.Param[type][Def_ChrNo_Wag] = 17;
	chrparam.Param[type][Def_ChrNo_Enk] = 20;
	chrparam.Param[type][Def_ChrNo_Lnd] = 17;
	chrparam.Param[type][Def_ChrNo_Mik] = 20;
	chrparam.Param[type][Def_ChrNo_Pho] = 17;
	chrparam.Param[type][Def_ChrNo_Kag] = 17;
	chrparam.Param[type][Def_ChrNo_Tsu] = 17;
	chrparam.Param[type][Def_ChrNo_Kuo] = 17;
	chrparam.Param[type][Def_ChrNo_Udu] = 17;
}



{	//バックダッシュの無敵時間
	local type = "バクステ打撃無敵Ｆ";
	chrparam.Param[type] <- array(CHRMAX, 8);
	chrparam.Param[type][Def_ChrNo_Hyd] = 8;
	chrparam.Param[type][Def_ChrNo_Lin] = 8;
	chrparam.Param[type][Def_ChrNo_Wal] = 10;
	chrparam.Param[type][Def_ChrNo_Car] = 8;
	chrparam.Param[type][Def_ChrNo_Ori] = 8;
	chrparam.Param[type][Def_ChrNo_Gor] = 8;
	chrparam.Param[type][Def_ChrNo_Mer] = 10;
	chrparam.Param[type][Def_ChrNo_Vat] = 8;
	chrparam.Param[type][Def_ChrNo_Set] = 7;
	chrparam.Param[type][Def_ChrNo_Yuz] = 8;
	chrparam.Param[type][Def_ChrNo_Hil] = 9;
	chrparam.Param[type][Def_ChrNo_Elt] = 8;
	chrparam.Param[type][Def_ChrNo_Nan] = 8;
	chrparam.Param[type][Def_ChrNo_Bya] = 8;
	chrparam.Param[type][Def_ChrNo_Aka] = 8;
	chrparam.Param[type][Def_ChrNo_Cha] = 8;
	chrparam.Param[type][Def_ChrNo_Wag] = 8;
	chrparam.Param[type][Def_ChrNo_Enk] = 8;
	chrparam.Param[type][Def_ChrNo_Lnd] = 8;
	chrparam.Param[type][Def_ChrNo_Mik] = 8;
	chrparam.Param[type][Def_ChrNo_Pho] = 8;
	chrparam.Param[type][Def_ChrNo_Kag] = 8;
	chrparam.Param[type][Def_ChrNo_Tsu] = 8;
	chrparam.Param[type][Def_ChrNo_Kuo] = 8;
	chrparam.Param[type][Def_ChrNo_Udu] = 8;
}

{	// バクステの投げ無敵フレーム
	local type = "バクステ投げ無敵Ｆ";
	chrparam.Param[type] <- array(CHRMAX, 10);
	chrparam.Param[type][Def_ChrNo_Hyd] = 10;
	chrparam.Param[type][Def_ChrNo_Lin] = 10;
	chrparam.Param[type][Def_ChrNo_Wal] = 10;
	chrparam.Param[type][Def_ChrNo_Car] = 10;
	chrparam.Param[type][Def_ChrNo_Ori] = 10;
	chrparam.Param[type][Def_ChrNo_Gor] = 10;
	chrparam.Param[type][Def_ChrNo_Mer] = 10;
	chrparam.Param[type][Def_ChrNo_Vat] = 10;
	chrparam.Param[type][Def_ChrNo_Set] = 10;
	chrparam.Param[type][Def_ChrNo_Yuz] = 10;
	chrparam.Param[type][Def_ChrNo_Hil] = 10;
	chrparam.Param[type][Def_ChrNo_Elt] = 10;
	chrparam.Param[type][Def_ChrNo_Nan] = 10;
	chrparam.Param[type][Def_ChrNo_Bya] = 10;
	chrparam.Param[type][Def_ChrNo_Aka] = 10;
	chrparam.Param[type][Def_ChrNo_Cha] = 10;
	chrparam.Param[type][Def_ChrNo_Wag] = 10;
	chrparam.Param[type][Def_ChrNo_Enk] = 10;
	chrparam.Param[type][Def_ChrNo_Lnd] = 10;
	chrparam.Param[type][Def_ChrNo_Mik] = 10;
	chrparam.Param[type][Def_ChrNo_Pho] = 10;
	chrparam.Param[type][Def_ChrNo_Kag] = 10;
	chrparam.Param[type][Def_ChrNo_Tsu] = 10;
	chrparam.Param[type][Def_ChrNo_Kuo] = 10;
	chrparam.Param[type][Def_ChrNo_Udu] = 10;
}

//歩きやダッシュの足音ＳＥ定義
{
	//Param0が10のタイミングでＡ→Ｂ→Ａ→Ｂと再生される
	//定義が-1だと再生されない
	// st[170] =	{  file=path+"SE170_Walk_ShoesA", type=-1  }; // 歩き
	// st[171] =	{  file=path+"SE171_Walk_ShoesB", type=-1  }; // 歩き
	// st[172] =	{  file=path+"SE172_Walk_BootsA", type=-1  }; // 歩き
	// st[173] =	{  file=path+"SE173_Walk_BootsB", type=-1  }; // 歩き
	// st[174] =	{  file=path+"SE174_Walk_HeelsA", type=-1  }; // 歩き
	// st[175] =	{  file=path+"SE175_Walk_HeelsB", type=-1  }; // 歩き
	local _FSST_Shoes = 170;
	local _FSST_Boots = 172;
	local _FSST_Heels = 174;
	
	local typeA = "足音Ａ_ＳＥ番号";

	chrparam.Param[typeA] <- array(CHRMAX, -1);
	chrparam.Param[typeA][Def_ChrNo_Hyd] = _FSST_Shoes;
	chrparam.Param[typeA][Def_ChrNo_Lin] = _FSST_Boots;
	chrparam.Param[typeA][Def_ChrNo_Wal] = 25;
	chrparam.Param[typeA][Def_ChrNo_Car] = _FSST_Boots;
	chrparam.Param[typeA][Def_ChrNo_Ori] = _FSST_Heels;
	chrparam.Param[typeA][Def_ChrNo_Gor] = _FSST_Boots;
	chrparam.Param[typeA][Def_ChrNo_Mer] = -1;
	chrparam.Param[typeA][Def_ChrNo_Vat] = -1;
	chrparam.Param[typeA][Def_ChrNo_Set] = _FSST_Shoes;
	chrparam.Param[typeA][Def_ChrNo_Yuz] = _FSST_Heels;
	chrparam.Param[typeA][Def_ChrNo_Hil] = _FSST_Heels;
	chrparam.Param[typeA][Def_ChrNo_Elt] = _FSST_Boots;
	chrparam.Param[typeA][Def_ChrNo_Nan] = _FSST_Shoes;
	chrparam.Param[typeA][Def_ChrNo_Bya] = _FSST_Shoes;
	chrparam.Param[typeA][Def_ChrNo_Aka] = _FSST_Boots;
	chrparam.Param[typeA][Def_ChrNo_Cha] = _FSST_Shoes;
	chrparam.Param[typeA][Def_ChrNo_Wag] = _FSST_Heels;
	chrparam.Param[typeA][Def_ChrNo_Enk] = _FSST_Boots;
	chrparam.Param[typeA][Def_ChrNo_Lnd] = -1;
	chrparam.Param[typeA][Def_ChrNo_Mik] = _FSST_Boots;
	chrparam.Param[typeA][Def_ChrNo_Pho] = _FSST_Heels;
	chrparam.Param[typeA][Def_ChrNo_Kag] = _FSST_Heels;
	chrparam.Param[typeA][Def_ChrNo_Tsu] = _FSST_Shoes;
	chrparam.Param[typeA][Def_ChrNo_Kuo] = -1;
	chrparam.Param[typeA][Def_ChrNo_Udu] = -1;

	local typeB = "足音Ｂ_ＳＥ番号";
	
	chrparam.Param[typeB] <- array(CHRMAX, -1);
	chrparam.Param[typeB][Def_ChrNo_Hyd] = _FSST_Shoes+1;
	chrparam.Param[typeB][Def_ChrNo_Lin] = _FSST_Boots+1;
	chrparam.Param[typeB][Def_ChrNo_Wal] = 25;
	chrparam.Param[typeB][Def_ChrNo_Car] = _FSST_Boots+1;
	chrparam.Param[typeB][Def_ChrNo_Ori] = _FSST_Heels+1;
	chrparam.Param[typeB][Def_ChrNo_Gor] = _FSST_Boots+1;
	chrparam.Param[typeB][Def_ChrNo_Mer] = -1;
	chrparam.Param[typeB][Def_ChrNo_Vat] = -1;
	chrparam.Param[typeB][Def_ChrNo_Set] = _FSST_Shoes+1;
	chrparam.Param[typeB][Def_ChrNo_Yuz] = _FSST_Heels+1;
	chrparam.Param[typeB][Def_ChrNo_Hil] = _FSST_Heels+1;
	chrparam.Param[typeB][Def_ChrNo_Elt] = _FSST_Boots+1;
	chrparam.Param[typeB][Def_ChrNo_Nan] = _FSST_Shoes+1;
	chrparam.Param[typeB][Def_ChrNo_Bya] = _FSST_Shoes+1;
	chrparam.Param[typeB][Def_ChrNo_Aka] = _FSST_Boots+1;
	chrparam.Param[typeB][Def_ChrNo_Cha] = _FSST_Shoes+1;
	chrparam.Param[typeB][Def_ChrNo_Wag] = _FSST_Heels+1;
	chrparam.Param[typeB][Def_ChrNo_Enk] = _FSST_Boots+1;
	chrparam.Param[typeB][Def_ChrNo_Lnd] = -1;
	chrparam.Param[typeB][Def_ChrNo_Mik] = _FSST_Boots+1;
	chrparam.Param[typeB][Def_ChrNo_Pho] = _FSST_Heels+1;
	chrparam.Param[typeB][Def_ChrNo_Kag] = _FSST_Heels+1;
	chrparam.Param[typeB][Def_ChrNo_Tsu] = _FSST_Shoes+1;
	chrparam.Param[typeB][Def_ChrNo_Kuo] = -1;
	chrparam.Param[typeB][Def_ChrNo_Udu] = -1;
}

{
	local type = "空中受け身バリアタイプ";
	chrparam.Param[type] <- array(CHRMAX, Def_Sys_RecoverBarrierType);
	chrparam.Param[type][Def_ChrNo_Hyd] = 1;
	chrparam.Param[type][Def_ChrNo_Lin] = 1;
	chrparam.Param[type][Def_ChrNo_Wal] = 1;
	chrparam.Param[type][Def_ChrNo_Car] = 1;
	chrparam.Param[type][Def_ChrNo_Ori] = 1;
	chrparam.Param[type][Def_ChrNo_Gor] = 1;
	chrparam.Param[type][Def_ChrNo_Mer] = 1;
	chrparam.Param[type][Def_ChrNo_Vat] = 1;
	chrparam.Param[type][Def_ChrNo_Set] = 1;
	chrparam.Param[type][Def_ChrNo_Yuz] = 1;
	chrparam.Param[type][Def_ChrNo_Hil] = 0; // バリア継続しない
	chrparam.Param[type][Def_ChrNo_Elt] = 1;
	chrparam.Param[type][Def_ChrNo_Nan] = 1;
	chrparam.Param[type][Def_ChrNo_Bya] = 1;
	chrparam.Param[type][Def_ChrNo_Aka] = 1;
	chrparam.Param[type][Def_ChrNo_Cha] = 1;
	chrparam.Param[type][Def_ChrNo_Wag] = 1;
	chrparam.Param[type][Def_ChrNo_Enk] = 1;
	chrparam.Param[type][Def_ChrNo_Lnd] = 1;
	chrparam.Param[type][Def_ChrNo_Mik] = 1;
	chrparam.Param[type][Def_ChrNo_Pho] = 1;
	chrparam.Param[type][Def_ChrNo_Kag] = 1;
	chrparam.Param[type][Def_ChrNo_Tsu] = 1;
	chrparam.Param[type][Def_ChrNo_Kuo] = 1;
	chrparam.Param[type][Def_ChrNo_Udu] = 1;
}

{
	local type = "地上受け身着地エフェクトタイプ";
	chrparam.Param[type] <- array(CHRMAX, 0);
	chrparam.Param[type][Def_ChrNo_Hyd] = 0;
	chrparam.Param[type][Def_ChrNo_Lin] = 0;
	chrparam.Param[type][Def_ChrNo_Wal] = 1; // 大きい＋SE違い
	chrparam.Param[type][Def_ChrNo_Car] = 0;
	chrparam.Param[type][Def_ChrNo_Ori] = 0;
	chrparam.Param[type][Def_ChrNo_Gor] = 0;
	chrparam.Param[type][Def_ChrNo_Mer] = 0;
	chrparam.Param[type][Def_ChrNo_Vat] = 0;
	chrparam.Param[type][Def_ChrNo_Set] = 0;
	chrparam.Param[type][Def_ChrNo_Yuz] = 0;
	chrparam.Param[type][Def_ChrNo_Hil] = 0;
	chrparam.Param[type][Def_ChrNo_Elt] = 0;
	chrparam.Param[type][Def_ChrNo_Nan] = 0;
	chrparam.Param[type][Def_ChrNo_Bya] = 0;
	chrparam.Param[type][Def_ChrNo_Aka] = 0;
	chrparam.Param[type][Def_ChrNo_Cha] = 0;
	chrparam.Param[type][Def_ChrNo_Wag] = 0;
	chrparam.Param[type][Def_ChrNo_Enk] = 0;
	chrparam.Param[type][Def_ChrNo_Lnd] = 0;
	chrparam.Param[type][Def_ChrNo_Mik] = 0;
	chrparam.Param[type][Def_ChrNo_Pho] = 0;
	chrparam.Param[type][Def_ChrNo_Kag] = 0;
	chrparam.Param[type][Def_ChrNo_Tsu] = 0;
	chrparam.Param[type][Def_ChrNo_Kuo] = 0;
	chrparam.Param[type][Def_ChrNo_Udu] = 0;
}

{
	local type = "立ち挑発タイプ";
	chrparam.Param[type] <- array(CHRMAX, 0); // 0:モーション無し・挑発無し 1:モーションあり(512)・挑発あり　2:モーション無し・挑発あり
	chrparam.Param[type][Def_ChrNo_Hyd] = 1;
	chrparam.Param[type][Def_ChrNo_Lin] = 1;
	chrparam.Param[type][Def_ChrNo_Wal] = 1;
	chrparam.Param[type][Def_ChrNo_Car] = 1;
	chrparam.Param[type][Def_ChrNo_Ori] = 1;
	chrparam.Param[type][Def_ChrNo_Gor] = 1;
	chrparam.Param[type][Def_ChrNo_Mer] = 1;
	chrparam.Param[type][Def_ChrNo_Vat] = 1;
	chrparam.Param[type][Def_ChrNo_Set] = 1;
	chrparam.Param[type][Def_ChrNo_Yuz] = 1;
	chrparam.Param[type][Def_ChrNo_Hil] = 1;
	chrparam.Param[type][Def_ChrNo_Elt] = 1;
	chrparam.Param[type][Def_ChrNo_Nan] = 1;
	chrparam.Param[type][Def_ChrNo_Bya] = 1;
	chrparam.Param[type][Def_ChrNo_Aka] = 1;
	chrparam.Param[type][Def_ChrNo_Cha] = 1;
	chrparam.Param[type][Def_ChrNo_Wag] = 1;
	chrparam.Param[type][Def_ChrNo_Enk] = 1;
	chrparam.Param[type][Def_ChrNo_Lnd] = 1;
	chrparam.Param[type][Def_ChrNo_Mik] = 1;
	chrparam.Param[type][Def_ChrNo_Pho] = 1;
	chrparam.Param[type][Def_ChrNo_Kag] = 1;
	chrparam.Param[type][Def_ChrNo_Tsu] = 1;
	chrparam.Param[type][Def_ChrNo_Kuo] = 1;
	chrparam.Param[type][Def_ChrNo_Udu] = 1;
}

{
	local type = "しゃがみ挑発タイプ";
	chrparam.Param[type] <- array(CHRMAX, 0); // 0:モーション無し・挑発無し 1:モーションあり(512)・挑発あり　2:モーション無し・挑発あり
	chrparam.Param[type][Def_ChrNo_Hyd] = 0;
	chrparam.Param[type][Def_ChrNo_Lin] = 0;
	chrparam.Param[type][Def_ChrNo_Wal] = 0;
	chrparam.Param[type][Def_ChrNo_Car] = 0;
	chrparam.Param[type][Def_ChrNo_Ori] = 0;
	chrparam.Param[type][Def_ChrNo_Gor] = 0;
	chrparam.Param[type][Def_ChrNo_Mer] = 0;
	chrparam.Param[type][Def_ChrNo_Vat] = 0;
	chrparam.Param[type][Def_ChrNo_Set] = 0;
	chrparam.Param[type][Def_ChrNo_Yuz] = 0;
	chrparam.Param[type][Def_ChrNo_Hil] = 1;
	chrparam.Param[type][Def_ChrNo_Elt] = 0;
	chrparam.Param[type][Def_ChrNo_Nan] = 0;
	chrparam.Param[type][Def_ChrNo_Bya] = 0;
	chrparam.Param[type][Def_ChrNo_Aka] = 0;
	chrparam.Param[type][Def_ChrNo_Cha] = 0;
	chrparam.Param[type][Def_ChrNo_Wag] = 0;
	chrparam.Param[type][Def_ChrNo_Enk] = 0;
	chrparam.Param[type][Def_ChrNo_Lnd] = 0;
	chrparam.Param[type][Def_ChrNo_Mik] = 0;
	chrparam.Param[type][Def_ChrNo_Pho] = 0;
	chrparam.Param[type][Def_ChrNo_Kag] = 0;
	chrparam.Param[type][Def_ChrNo_Tsu] = 0;
	chrparam.Param[type][Def_ChrNo_Kuo] = 0;
	chrparam.Param[type][Def_ChrNo_Udu] = 0;
}

{
	local type = "ウェブやられエフェクトサイズ";
	chrparam.Param[type] <- array(CHRMAX, [100,100]); // X Y
	chrparam.Param[type][Def_ChrNo_Hyd] = [100,100];
	chrparam.Param[type][Def_ChrNo_Lin] = [ 90, 90];
	chrparam.Param[type][Def_ChrNo_Wal] = [130,100];
	chrparam.Param[type][Def_ChrNo_Car] = [100,100];
	chrparam.Param[type][Def_ChrNo_Ori] = [100,100];
	chrparam.Param[type][Def_ChrNo_Gor] = [100,100];
	chrparam.Param[type][Def_ChrNo_Mer] = [130,100];
	chrparam.Param[type][Def_ChrNo_Vat] = [ 90, 90];
	chrparam.Param[type][Def_ChrNo_Set] = [100,100];
	chrparam.Param[type][Def_ChrNo_Yuz] = [100,100];
	chrparam.Param[type][Def_ChrNo_Hil] = [100,100];
	chrparam.Param[type][Def_ChrNo_Elt] = [100,100];
	chrparam.Param[type][Def_ChrNo_Nan] = [100,100];
	chrparam.Param[type][Def_ChrNo_Bya] = [100,100];
	chrparam.Param[type][Def_ChrNo_Aka] = [100,100];
	chrparam.Param[type][Def_ChrNo_Cha] = [100,100];
	chrparam.Param[type][Def_ChrNo_Wag] = [100,100];
	chrparam.Param[type][Def_ChrNo_Enk] = [100,100];
	chrparam.Param[type][Def_ChrNo_Lnd] = [100,100];
	chrparam.Param[type][Def_ChrNo_Mik] = [ 90, 90];
	chrparam.Param[type][Def_ChrNo_Pho] = [100,100];
	chrparam.Param[type][Def_ChrNo_Kag] = [100,100];
	chrparam.Param[type][Def_ChrNo_Tsu] = [100,100];
	chrparam.Param[type][Def_ChrNo_Kuo] = [100,100];
	chrparam.Param[type][Def_ChrNo_Udu] = [100,100];
}

{
	//最小の値から行動可能になる（必殺技とかも出せる）
	//特殊技はABCによって分けられるので注意（J2CはJCのフレームになる）
	//同じフレームにしないとJ2Cを入れたのにJCが出たりして不快
	local type = "地上アサルト硬直"; // デフォ値10。飛ぶまでが5Fなので、5+値+ジャンプ攻撃のフレームが最速
	chrparam.Param[type] <- array(CHRMAX, [-1,-1,-1]); // JA, JB, JC
	chrparam.Param[type][Def_ChrNo_Hyd] = [-1,-1,9];
	chrparam.Param[type][Def_ChrNo_Lin] = [7,-1,-1];
	chrparam.Param[type][Def_ChrNo_Wal] = [-1,-1,9]; // バグ
	chrparam.Param[type][Def_ChrNo_Car] = [-1,8,-1];
	chrparam.Param[type][Def_ChrNo_Ori] = [-1,9,-1];
	chrparam.Param[type][Def_ChrNo_Gor] = [8,-1,-1];
	chrparam.Param[type][Def_ChrNo_Mer] = [9,8,8]; // バグ
	chrparam.Param[type][Def_ChrNo_Vat] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Set] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Yuz] = [7,8,9]; // バグ
	chrparam.Param[type][Def_ChrNo_Hil] = [7,8,7]; // バグ 85/80 85/96
	chrparam.Param[type][Def_ChrNo_Elt] = [-1,8,-1];
	chrparam.Param[type][Def_ChrNo_Nan] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Bya] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Aka] = [8,8,-1];
	chrparam.Param[type][Def_ChrNo_Cha] = [-1,9,-1];
	chrparam.Param[type][Def_ChrNo_Wag] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Enk] = [8,-1,-1]; // バグ
	chrparam.Param[type][Def_ChrNo_Lnd] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Mik] = [9,-1,-1];
	chrparam.Param[type][Def_ChrNo_Pho] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Kag] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Tsu] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Kuo] = [9,-1,11];
	chrparam.Param[type][Def_ChrNo_Udu] = [-1,-1,-1];
}

{
	//最小の値から行動可能になる（必殺技とかも出せる）
	//特殊技はABCによって分けられるので注意（J2CはJCのフレームになる）
	//同じフレームにしないとJ2Cを入れたのにJCが出たりして不快
	local type = "空中アサルト硬直"; // デフォ値9。飛ぶまでが5Fなので、5+値+ジャンプ攻撃のフレームが最速
	chrparam.Param[type] <- array(CHRMAX, [-1,-1,-1]); // JA, JB, JC
	chrparam.Param[type][Def_ChrNo_Hyd] = [8,-1,7];
	chrparam.Param[type][Def_ChrNo_Lin] = [7,8,8];
	chrparam.Param[type][Def_ChrNo_Wal] = [8,8,8];
	chrparam.Param[type][Def_ChrNo_Car] = [-1,7,8];
	chrparam.Param[type][Def_ChrNo_Ori] = [-1,7,7];
	chrparam.Param[type][Def_ChrNo_Gor] = [7,8,8];
	chrparam.Param[type][Def_ChrNo_Mer] = [8,8,8];
	chrparam.Param[type][Def_ChrNo_Vat] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Set] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Yuz] = [7,7,8];
	chrparam.Param[type][Def_ChrNo_Hil] = [7,7,7]; // 8,10,16
	chrparam.Param[type][Def_ChrNo_Elt] = [8,7,7];
	chrparam.Param[type][Def_ChrNo_Nan] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Bya] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Aka] = [7,7,7];
	chrparam.Param[type][Def_ChrNo_Cha] = [8,7,8];
	chrparam.Param[type][Def_ChrNo_Wag] = [-1,8,8];
	chrparam.Param[type][Def_ChrNo_Enk] = [7,8,7];
	chrparam.Param[type][Def_ChrNo_Lnd] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Mik] = [7,8,8];
	chrparam.Param[type][Def_ChrNo_Pho] = [-1,8,8];
	chrparam.Param[type][Def_ChrNo_Kag] = [-1,7,-1];
	chrparam.Param[type][Def_ChrNo_Tsu] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Kuo] = [8,-1,-1];
	chrparam.Param[type][Def_ChrNo_Udu] = [-1,-1,-1];
}

{
	// 格ゲー的なフレームにしたので、CLRだと4でも、今作だと5になる
	local type = "アサルトでかかりタメ"; // デフォ5
	chrparam.Param[type] <- array(CHRMAX, [5,5]); // 地上,空中
	chrparam.Param[type][Def_ChrNo_Hyd] = [5,4];
	chrparam.Param[type][Def_ChrNo_Lin] = [5,4];
	chrparam.Param[type][Def_ChrNo_Wal] = [5,5];
	chrparam.Param[type][Def_ChrNo_Car] = [5,4];
	chrparam.Param[type][Def_ChrNo_Ori] = [5,4];
	chrparam.Param[type][Def_ChrNo_Gor] = [5,4];
	chrparam.Param[type][Def_ChrNo_Mer] = [5,4];
	chrparam.Param[type][Def_ChrNo_Vat] = [5,4];
	chrparam.Param[type][Def_ChrNo_Set] = [5,5];
	chrparam.Param[type][Def_ChrNo_Yuz] = [5,4];
	chrparam.Param[type][Def_ChrNo_Hil] = [5,4];
	chrparam.Param[type][Def_ChrNo_Elt] = [5,4];
	chrparam.Param[type][Def_ChrNo_Nan] = [5,4];
	chrparam.Param[type][Def_ChrNo_Bya] = [5,4];
	chrparam.Param[type][Def_ChrNo_Aka] = [5,4];
	chrparam.Param[type][Def_ChrNo_Cha] = [5,4];
	chrparam.Param[type][Def_ChrNo_Wag] = [5,4];
	chrparam.Param[type][Def_ChrNo_Enk] = [5,4];
	chrparam.Param[type][Def_ChrNo_Lnd] = [5,4];
	chrparam.Param[type][Def_ChrNo_Mik] = [5,5];
	chrparam.Param[type][Def_ChrNo_Pho] = [5,4];
	chrparam.Param[type][Def_ChrNo_Kag] = [5,4];
	chrparam.Param[type][Def_ChrNo_Tsu] = [5,4];
	chrparam.Param[type][Def_ChrNo_Kuo] = [5,4];
	chrparam.Param[type][Def_ChrNo_Udu] = [5,4];
}

{	// 歩きベクトル定義
	local type = "歩きベクトル";
	chrparam.Param[type] <- array(CHRMAX,    [512, 1050, -512,  -900] );// 前進はじめ, 前進, 後退はじめ, 後退 // [400, 1000, -400, -700]
	
	chrparam.Param[type][Def_ChrNo_Hyd] = [512, 1340, -512,  -910]; // [512, 1300, -512,  -800];
	chrparam.Param[type][Def_ChrNo_Lin] = [512,  950, -512,  -860]; // [512,  800, -512,  -700];
	chrparam.Param[type][Def_ChrNo_Wal] = [  0,    0,    0,     0]; // [  0,    0,    0,     0];
	chrparam.Param[type][Def_ChrNo_Car] = [512, 1260, -512, -1000]; // [512, 1200, -512,  -900];
	chrparam.Param[type][Def_ChrNo_Ori] = [512, 1400, -512, -1050]; // [512, 1400, -512, -1100];
	chrparam.Param[type][Def_ChrNo_Gor] = [512, 1180, -512,  -860]; // [512, 1100, -512,  -700];
	chrparam.Param[type][Def_ChrNo_Mer] = [512,  740, -512,  -660]; // [512,  500, -512,  -400];
	chrparam.Param[type][Def_ChrNo_Vat] = [512, 1180, -512,  -910]; // [512, 1000, -512,  -800];
	chrparam.Param[type][Def_ChrNo_Set] = [512,  740, -512,  -790]; // [512,  550, -512,  -650];
	chrparam.Param[type][Def_ChrNo_Yuz] = [512, 1100, -512, -1000]; // [512, 1000, -512, -1000];
	chrparam.Param[type][Def_ChrNo_Hil] = [512, 1000, -512,  -970]; // [512,  900, -512,  -900];
	chrparam.Param[type][Def_ChrNo_Elt] = [512, 1100, -512,  -970]; // [800, 1000, -700,  -800];
	chrparam.Param[type][Def_ChrNo_Nan] = [512, 1000, -512,  -860]; // [512,  850, -512,  -650];
	chrparam.Param[type][Def_ChrNo_Bya] = [512, 1100, -512, -1000]; // [512, 1000, -512,  -900];
	chrparam.Param[type][Def_ChrNo_Aka] = [512, 1180, -512, -1000]; // [512, 1000, -512,  -800];
	chrparam.Param[type][Def_ChrNo_Cha] = [512,  950, -512,  -910]; // [512,  800, -512,  -800];
	chrparam.Param[type][Def_ChrNo_Wag] = [512,  950, -512,  -910]; // [512,  700, -512,  -700];
	chrparam.Param[type][Def_ChrNo_Enk] = [512, 1000, -512,  -860]; // [512,  900, -512,  -700];
	chrparam.Param[type][Def_ChrNo_Lnd] = [512, 1260, -512, -1000]; // [512, 1200, -512,  -900];
	chrparam.Param[type][Def_ChrNo_Mik] = [512, 1260, -512, -1000]; // [512, 1200, -512,  -900];
	chrparam.Param[type][Def_ChrNo_Pho] = [512,  950, -512,  -860]; // [512,  700, -700,  -600];
	chrparam.Param[type][Def_ChrNo_Kag] = [512, 1100, -512,  -970]; // [512,  900, -512,  -800];
	chrparam.Param[type][Def_ChrNo_Tsu] = [512, 1100, -512,  -860]; // [512,  800, -700,  -600];
	chrparam.Param[type][Def_ChrNo_Kuo] = [512, 1100, -512,  -910]; // [512, 1100, -512,  -800];
	chrparam.Param[type][Def_ChrNo_Udu] = [512, 1050, -512,  -940];
}

{	// 連キャンダメージ補正
	local type = "連キャンダメージ補正";
	chrparam.Param[type] <- array(CHRMAX,    [98,97] );// 0:補正なし
	
	chrparam.Param[type][Def_ChrNo_Hyd] = [98,97];
	chrparam.Param[type][Def_ChrNo_Lin] = [98,97];
	chrparam.Param[type][Def_ChrNo_Wal] = [98,97]; // 2Aは連キャンかからないけど一応設定あり
	chrparam.Param[type][Def_ChrNo_Car] = [98,98];
	chrparam.Param[type][Def_ChrNo_Ori] = [98,97];
	chrparam.Param[type][Def_ChrNo_Gor] = [97,98];
	chrparam.Param[type][Def_ChrNo_Mer] = [98,97];
	chrparam.Param[type][Def_ChrNo_Vat] = [98,98];
	chrparam.Param[type][Def_ChrNo_Set] = [98,97];
	chrparam.Param[type][Def_ChrNo_Yuz] = [97,98];
	chrparam.Param[type][Def_ChrNo_Hil] = [98,97];
	chrparam.Param[type][Def_ChrNo_Elt] = [98,97];
	chrparam.Param[type][Def_ChrNo_Nan] = [98,97];
	chrparam.Param[type][Def_ChrNo_Bya] = [98,97];
	chrparam.Param[type][Def_ChrNo_Aka] = [98,97];
	chrparam.Param[type][Def_ChrNo_Cha] = [98,97];
	chrparam.Param[type][Def_ChrNo_Wag] = [98,97];
	chrparam.Param[type][Def_ChrNo_Enk] = [98,97];
	chrparam.Param[type][Def_ChrNo_Lnd] = [98,97];
	chrparam.Param[type][Def_ChrNo_Mik] = [98,97];
	chrparam.Param[type][Def_ChrNo_Pho] = [98,97];
	chrparam.Param[type][Def_ChrNo_Kag] = [98,97];
	chrparam.Param[type][Def_ChrNo_Tsu] = [98,98];
	chrparam.Param[type][Def_ChrNo_Kuo] = [98,97];
	chrparam.Param[type][Def_ChrNo_Udu] = [98,97];
}
local rapidAtkAHoseiAr = chrparam.Get( { type="連キャンダメージ補正", chrnum=_ChrNo } );

//スマートステア専用必殺技を使用した時にかける補正・CP
//・SS技は基礎ダメは1600前後
//・SS技は可能な限り暴れつぶし不可にする
//・5A始動でSS技まで入れてダメージ2400〜2450
//・暴れつぶしで必殺技>SS技ヒット後のダメージと補正の効率が2700前後、CP16になるようにする（基礎ダメージが低い方が効率良くなるようにする）
//・基本的に出し切りで反確はなし、状況は密着微不利か離れて不利
//・原則としてキャンセルはDAMAGE時のみ
//・多段の飛び道具からキャンセルする時は飛び道具の二段目以降にボーナス補正が乗らないように補正をかけるフレームを遅らせる
{
	local type = "スマートステア補正";
	chrparam.Param[type] <- array(CHRMAX, [100,0, 1,0] ); // ダメージ補正,CP,補正をかけるフレーム,Mv移行する技かどうか
	chrparam.Param[type][Def_ChrNo_Hyd] = [110,0, 8,0];
	chrparam.Param[type][Def_ChrNo_Lin] = [ 91,0, 1,0];
	chrparam.Param[type][Def_ChrNo_Wal] = [110,0, 1,0];
	chrparam.Param[type][Def_ChrNo_Car] = [130,0, 1,0];// 体力消費するので意図的にダメージちょい高めになってる
	chrparam.Param[type][Def_ChrNo_Ori] = [150,0, 1,0];
	chrparam.Param[type][Def_ChrNo_Gor] = [115,0, 1,0];
	chrparam.Param[type][Def_ChrNo_Mer] = [108,0, 1,0];
	chrparam.Param[type][Def_ChrNo_Vat] = [128,0, 1,0];
	chrparam.Param[type][Def_ChrNo_Set] = [145,0, 1,0];
	chrparam.Param[type][Def_ChrNo_Yuz] = [150,0, 1,0];
	chrparam.Param[type][Def_ChrNo_Hil] = [133,0, 1,0];
	chrparam.Param[type][Def_ChrNo_Elt] = [135,0, 1,1];
	chrparam.Param[type][Def_ChrNo_Nan] = [145,0, 1,0];
	chrparam.Param[type][Def_ChrNo_Bya] = [168,0, 1,0];
	chrparam.Param[type][Def_ChrNo_Aka] = [153,0, 1,0];
	chrparam.Param[type][Def_ChrNo_Cha] = [135,0, 1,0];
	chrparam.Param[type][Def_ChrNo_Wag] = [138,0, 1,0];
	chrparam.Param[type][Def_ChrNo_Enk] = [138,0, 1,0];
	chrparam.Param[type][Def_ChrNo_Lnd] = [155,0, 1,0];
	chrparam.Param[type][Def_ChrNo_Tsu] = [157,0, 1,0];
	chrparam.Param[type][Def_ChrNo_Mik] = [146,0, 1,0];
	chrparam.Param[type][Def_ChrNo_Kag] = [168,0, 1,0];
	chrparam.Param[type][Def_ChrNo_Kuo] = [153,0,10,0];
	chrparam.Param[type][Def_ChrNo_Pho] = [150,0, 1,0];
	chrparam.Param[type][Def_ChrNo_Udu] = [120,0, 1,0];
}
local SS_ratio = chrparam.Get( { type="スマートステア補正", chrnum=_ChrNo } );

{
	local type = "ステアエンダー半ロック引き寄せ";
	chrparam.Param[type] <- array(CHRMAX, { power=35 });
	chrparam.Param[type][Def_ChrNo_Hyd] = { power=35, flags=(1<<6) };
	chrparam.Param[type][Def_ChrNo_Lin] = { power=35 };
	chrparam.Param[type][Def_ChrNo_Wal] = { power=35 };
	chrparam.Param[type][Def_ChrNo_Car] = 0; // オブジェクト
	chrparam.Param[type][Def_ChrNo_Ori] = { power=35 };
	chrparam.Param[type][Def_ChrNo_Gor] = { power=50 };
	chrparam.Param[type][Def_ChrNo_Mer] = { power=35 };
	chrparam.Param[type][Def_ChrNo_Vat] = { power=35 };
	chrparam.Param[type][Def_ChrNo_Set] = { power=40 };
	chrparam.Param[type][Def_ChrNo_Yuz] = { power=35 };
	chrparam.Param[type][Def_ChrNo_Hil] = 0;
	chrparam.Param[type][Def_ChrNo_Elt] = { power=50 };
	chrparam.Param[type][Def_ChrNo_Nan] = { power=35 };
	chrparam.Param[type][Def_ChrNo_Bya] = { power=35 };
	chrparam.Param[type][Def_ChrNo_Aka] = { [100]={ power=35 }, [200]={ power=35, flags=(1<<0) } } ; // 二段目X座標無効
	chrparam.Param[type][Def_ChrNo_Cha] = { power=35, flags=(1<<6) }; // 高めの相手の裏にいかないように
	chrparam.Param[type][Def_ChrNo_Wag] = { power=35 };
	chrparam.Param[type][Def_ChrNo_Enk] = { power=50 };
	chrparam.Param[type][Def_ChrNo_Lnd] = { power=65 };
	chrparam.Param[type][Def_ChrNo_Tsu] = { power=50 };
	chrparam.Param[type][Def_ChrNo_Udu] = { power=35, flags=(1<<6) };
	chrparam.Param[type][Def_ChrNo_Mik] = { power=35 };
	chrparam.Param[type][Def_ChrNo_Kag] = { power=35 };
	chrparam.Param[type][Def_ChrNo_Kuo] = { power=50 };
	chrparam.Param[type][Def_ChrNo_Pho] = { power=50 };
}
local SS_DamageLockParams = chrparam.Get( { type="ステアエンダー半ロック引き寄せ", chrnum=_ChrNo } );

{
	local type = "ステアエンダー時間停止F";
	chrparam.Param[type] <- array(CHRMAX, [6,10] ); // 通常時,スマートステア時
	chrparam.Param[type][Def_ChrNo_Hyd] = [6, 9];
	chrparam.Param[type][Def_ChrNo_Lin] = [6, 9];
	chrparam.Param[type][Def_ChrNo_Wal] = [6, 9];
	chrparam.Param[type][Def_ChrNo_Car] = [6,10];
	chrparam.Param[type][Def_ChrNo_Ori] = [6, 7];
	chrparam.Param[type][Def_ChrNo_Gor] = [6, 7];
	chrparam.Param[type][Def_ChrNo_Mer] = [6,10];
	chrparam.Param[type][Def_ChrNo_Vat] = [6,10];
	chrparam.Param[type][Def_ChrNo_Set] = [6, 7];
	chrparam.Param[type][Def_ChrNo_Yuz] = [6,10];
	chrparam.Param[type][Def_ChrNo_Hil] = [6,10];
	chrparam.Param[type][Def_ChrNo_Elt] = [6,10];
	chrparam.Param[type][Def_ChrNo_Nan] = [6, 9];
	chrparam.Param[type][Def_ChrNo_Bya] = [6,10];
	chrparam.Param[type][Def_ChrNo_Aka] = [10,14];
	chrparam.Param[type][Def_ChrNo_Cha] = [6, 7];
	chrparam.Param[type][Def_ChrNo_Wag] = [6, 7];
	chrparam.Param[type][Def_ChrNo_Enk] = [6, 8];
	chrparam.Param[type][Def_ChrNo_Lnd] = [6, 9];
	chrparam.Param[type][Def_ChrNo_Tsu] = [6, 9];
	chrparam.Param[type][Def_ChrNo_Udu] = [6, 9];
	chrparam.Param[type][Def_ChrNo_Mik] = [6,10];
	chrparam.Param[type][Def_ChrNo_Kag] = [6, 9];
	chrparam.Param[type][Def_ChrNo_Kuo] = [6,10];
	chrparam.Param[type][Def_ChrNo_Pho] = [6, 8];
}
local SteerEnderStoptime = chrparam.Get( { type="ステアエンダー時間停止F", chrnum=_ChrNo } );

//パターン定義
{	// 空中ガードからの戻りパターン
	local type = "空中ガードからの戻りパターン";
	chrparam.Param[type] <- array(CHRMAX, 20);
	chrparam.Param[type][Def_ChrNo_Pho] = 39;
}

_dp1p("\n[btl_ChrParamFunc] -> end");

//local test = chrparam.Get( { type="連キャンダメージ補正", chrnum=_ChrNo } );
//print("test:"+test);






// キャラクター固有ヒットエフェクト定義
// タイプ：Ａ〜Ｚ
// 強さ：弱　中　強　間引き　特大
// 回転・拡大・ＳＥは判定ツールのグラフィック側で設定する
// {
	// chrparam.Param["固有ヒットエフェクト1"] <- array(CHRMAX, -1);
	// chrparam.Param["固有ヒットエフェクト1"][Def_ChrNo_Cha] = [
	// { datatype=0, pat="eff_DahHitFlash", MaxFrameID=1 }, // 間引き
	// { datatype=0, pat="eff_DahHitFlash", MaxFrameID=1 }, // A
	// { datatype=0, pat="eff_DahHitFlash", MaxFrameID=1 }, // B
	// { datatype=0, pat="eff_DahHitFlash", MaxFrameID=1 }, // C
	// { datatype=0, pat="eff_DahHitFlash", MaxFrameID=1 } // D
	// ];
// }




local val_GroundRecoverEffectType = chrparam.Get( { type="地上受け身着地エフェクトタイプ", chrnum=_ChrNo } ); 
local callLandEffect = function() : (val_GroundRecoverEffectType)
{
	switch( val_GroundRecoverEffectType )
	{
	case 1: // ワレンとか重い
		BMvEff.CreateObject( { datatype=1, start_pat=290 } );
		BSound.SE_Play( { type=_SeType_Player, num=25 } );
		BMvEff.SetCamera_Quake( { time=20, type=0 } );
		break;
	default: // 通常
		BMvEff.CreateObject( { datatype=1, start_pat=20 } );
		break;
	}
}



//Enemy[] : 抽選に入れるキャラ。専用セリフ。未指定だと誰でもになるが、duetがあるときは相手もEnemyがないと抽選されない（enemy+commonよりduetが優先される）
//ExcludeEnemy[] : 抽選から除外するキャラ

local CommonStandbyParams = array(CHRMAX,0);

// 登場演出の定義
CommonStandbyParams[0] =
[
	{ WaitPAT = 50, timeline = [ { delay=112, SE=100, time=112 }, ], }, // 「出ろ！　インスレーター！」
	{ WaitPAT = 51, timeline = [ { delay=186, SE=101, time=186 }, ], }, // 「邪魔をするなら…片付けるまでだ！」
	{ WaitPAT = 50, timeline = [ { delay=124, SE=102, time=124 }, ], }, // 「……この力で終わらせてやる！」
	{ WaitPAT = 51, timeline = [ { delay=146, SE=103, time=146 }, ], }, // 「オレの力……見せてやる！」
	
	{
		Enemy=[1], WaitPAT = [50,900],
		duet_timeline =
		[
			{ PL=0, delay=164, SE=108, } // 「いつまでもあの頃の俺じゃないぜ？」
			{ PL=1, PAT=901, delay=144, SE=108, }, //「解っているさ、それくらいな」
		],
	},
	{
		Enemy=[2], WaitPAT = [902,50],
		duet_timeline =
		[
			{ PL=1, delay=229, SE=109, }, // 「ふん、一丁前の顔になりおったな」
			{ PL=0, PAT=903, delay=160, SE=111, }, //「あんたのお陰だ、礼を言うぜ」
		],
	},
	{
		Enemy=[16], WaitPAT = [902,50],
		duet_timeline =
		[
			{ PL=1, delay=234, SE=119, }, //「フッ、余程私の事が忘れられぬと見える」
			{ PL=0, PAT=903, delay=152, SE=113, }, //「誤解されるようなこと言うなよ！！」
		],
	},	
	{
		Enemy=[8], WaitPAT = [50,900],
		duet_timeline =
		[
			{ PL=0, delay=209, SE=115, }, //「ま、決着はつけなくちゃいけねぇよな」
			{ PL=1, PAT=901, delay=191, SE=109, }, //「解りきったことだ。必要なかろう……」
		],
	},
	{
		Enemy=[3], WaitPAT = [50,900],
		duet_timeline =
		[
			{ PL=0, delay=156, SE=118, }, //「懲りねぇヤロウだな、お前も。」
			{ PL=1, PAT=901, delay=186, SE=107, }, //「唯一の趣味だ、邪魔すんじゃねぇよ」
		],
	},
	{
		Enemy=[10], WaitPAT = [902,50],
		duet_timeline =
		[
			{ PL=1, delay=181, SE=110, }, //「その余裕、舐められたものね」
			{ PL=0, PAT=903, delay=188, SE=121, }, //「開き直ってるだけだ、気にすんなよ」
		],
	},
	
	{
		Enemy=[23], WaitPAT = [50,900],
		duet_timeline =
		[
			{ PL=0, delay=146, SE=124, }, //「さぁ、幕と行こうぜ！」
			{ PL=1, PAT=901, delay=145, SE=110, }, //「……久遠なる物語に終わりはない」
		],
	},
	{
		Enemy=[19], WaitPAT = [51,900],
		duet_timeline =
		[
			{ PL=0, delay=188, SE=127, }, //「呆れた腐れ縁だな、ったく」
			{ PL=1, PAT=901, delay=179, SE=110, }, //「運命の赤い糸、って言うんだよ」
		],
	},	

	{
		Enemy=[4], WaitPAT = [50,900],
		duet_timeline =
		[
			{ PL=0, delay=136, SE=130, }, //「……黙って退いちゃくれねぇか？」
			{ PL=1, PAT=901, delay=205, SE=113, }, //「出来ません、貴方もそうであるように」
		],
	},	
	{
		Enemy=[22], WaitPAT = [51,900],
		duet_timeline =
		[
			{ PL=0, delay=167, SE=133, }, //「アンタとは、やり合いたくねーんだが」
			{ PL=1, PAT=901, delay=204, SE=108, }, //「お気になさらずに。私も気にしませんから♪」
		],
	},	
	{
		Enemy=[7], WaitPAT = [902,50],
		duet_timeline =
		[
			{ PL=1, delay=272, SE=105, }, //「貴方を倒し先へ進む、これは私自身の意思……」
			{ PL=0, PAT=903, delay=209, SE=136, }, //「一番やりにくい相手だな、こりゃ」
		],
	},	
];

CommonStandbyParams[1] =
[
	{ WaitPAT = 50, timeline = [ { delay=125, SE=100, time=125 }, ], }, // 「厄介なのが現れたな」
	{ WaitPAT = 50, timeline = [ { delay=118, SE=101, time=118 }, ], }, // 「面倒なのと出くわしたな」
	
	{
		Enemy=[8], WaitPAT = [900,50],
		duet_timeline =
		[
			{ PL=1, delay=209, SE=112, }, //「俺が行くという約束、覚えていないか…？」（リンネ「あぁ、長生きすると物忘れが、な」）
			{ PL=0, PAT=901, delay=227, SE=111, }, //「あぁ、長生きすると物忘れが、な」
		],
	},
	{
		Enemy=[23], WaitPAT = [900,50],
		duet_timeline =
		[
			{ PL=1, delay=140, SE=119, }, //「幾度繰り返せば良いのだろうな…」（リンネ「安心しろ、もうすぐ終わるさ」）
			{ PL=0, PAT=901, delay=158, SE=114, }, //「安心しろ、もうすぐ終わるさ」
		],
	},
	{
		Enemy=[2], WaitPAT = [906,900],
		duet_timeline =
		[
			{ PL=0, PAT=907, delay=132, SE=117, }, //「真剣勝負は、久しいな」
			{ PL=1, PAT=901, delay=180, SE=115, }, //「ふん、少しは楽しめそうか……？」
		],
	},
	{
		Enemy=[10], WaitPAT = [906,50],
		duet_timeline =
		[
			{ PL=1, delay=248, SE=112, }, //「アンタも倒す、アイツも倒す。このアタシが」（リンネ「出来やしないさ。今のお前にはな……）
			{ PL=0, PAT=907, delay=189, SE=120, }, //「出来やしないさ。今のお前にはな……」
		],
	},
];

CommonStandbyParams[2] =
[
	{ WaitPAT = 50, timeline = [ { delay=195, SE=100, time=195 }, ], }, // 「グオオオオォォ！ （次に続く）」「粉！砕！！」
	{ WaitPAT = 50, timeline = [ { delay=195, SE=103, time=195 }, ], }, // 「覚悟を決めろ…（次に続く）」「ウオオオォ」
	
	{
		Enemy=[8], WaitPAT = [903,900],
		duet_timeline =
		[
			{ PL=0, delay=213, SE=112, }, // 「その細き腕で、なにが斬れようよ」
			{ PL=1, PAT=901, delay=187, SE=115, }, //（ワレン「その細き腕で、なにが斬れようよ」）「己を縛る鎖、断ち切れるさ……。」
		],
	},
	{
		Enemy=[23], WaitPAT = [903,900],
		duet_timeline =
		[
			{ PL=0, delay=191, SE=118, }, // 「この拳、受け取って貰うぞ！」
			{ PL=1, PAT=901, delay=241, SE=112, }, // （ワレン「この拳、受け取って貰うぞ！）「あぁ、待たせてしまったね。我が友よ」
		],
	},
	{
		Enemy=[21], WaitPAT = [903,910],
		duet_timeline =
		[
			{ PL=0, delay=257, SE=122, }, // 「秘められし強大なパワー。存分に語り合おうぞ。」
			{ PL=1, PAT=911, delay=226, SE=121, }, //（対ワレン「良かろう！　我らが共通言語、拳でな！）
		],
	},
];

CommonStandbyParams[3] =
[
	{ WaitPAT = 50, timeline = [ { delay=220, SE=100, time=220 }, ], }, //「ククク…後悔してももう遅ェ！」
	{ WaitPAT = 50, timeline = [ { delay=121, SE=101, time=121 }, ], }, //「雑魚はすっこんでろ…」
	{ WaitPAT = 50, timeline = [ { delay=128, SE=102, time=128 }, ], }, //「軽くひねってやんよォ」
	
	{
		Enemy=[5], WaitPAT = [900,50],
		duet_timeline =
		[
			{ PL=1, delay=157, SE=111, }, //「顔色悪いな。大丈夫か？」
			{ PL=0, PAT=901, delay=197, SE=110, }, //「けっ…、テメェの命だけ心配してな…」
		],
	},
	{
		Enemy=[23], WaitPAT = [50,900],
		duet_timeline =
		[
			{ PL=0, delay=145, SE=113, }, //「気取ってんなよ、ガキが……」
			{ PL=1, PAT=901, delay=279, SE=114, }, // （カーマイン「気取ってんなよ、ガキが……」）「あぁ、見くびらないでくれよ、怖いお兄さん」
		],
	},
];

CommonStandbyParams[4] =
[
	{ WaitPAT = 50, timeline = [ { delay=200, SE=100, time=200 }, ], }, //「正義の名の下に、貴方を救済します」
	{ WaitPAT = 50, timeline = [ { delay=135, SE=102, time=135 }, ], }, //「貴方にはここで引いていただきます」
	{ WaitPAT = 50, timeline = [ { delay=146, SE=103, time=146 }, ], }, //「定めに従い光の鉄槌を」
	
	//対ハイド　※掛け合いがあるので未使用
	// { PL=0, delay=120, SE=110, }, //「今すぐ立ち去りなさい…さもなければ…」
	// { PL=0, delay=120, SE=111, }, //「これも定め…なのかな」
	
	//対リンネ
	{ Enemy=[1], WaitPAT = 50, timeline = [ { delay=117, SE=115, time=117 }, ], }, //「あなたを糾(ただ)さねばなりません」
	
	{
		Enemy=[16], WaitPAT = [900,50],
		duet_timeline =
		[
			//対ワーグナー
			{ PL=1, delay=151, SE=112, }, //「謀らずとも機は熟したようだな」
			{ PL=0, PAT=901, delay=191, SE=108, }, //（ワーグナー「謀らずとも機は熟したようだな」）「えぇ、少し不本意だけれどね」
		],
	},
	{
		Enemy=[16], WaitPAT = [900,50],
		duet_timeline =
		[
			//対ワーグナー
			{ PL=1, delay=208, SE=109, }, //「あのときの決着だ、いくぞ優等生」
			{ PL=0, PAT=901, delay=191, SE=108, }, //（ワーグナー「謀らずとも機は熟したようだな」）「えぇ、少し不本意だけれどね」
		],
	},
	
	{
		Enemy=[21], WaitPAT = [900,900],
		duet_timeline =
		[
			//対ミカ
			{ PL=1, delay=211, SE=120, }, //（対オリエ）「へっ、お前ばかりに良いかっこはさせられねぇ！」
			{ PL=0, PAT=901, delay=178, SE=117, }, //（ミカ「へっ、お前ばかりに良いかっこはさせられねぇ！」）「その気持ちだけで十分だよ、ミカ」
		],
	},
	
	{
		Enemy=[6], WaitPAT = [50,900],
		duet_timeline =
		[
			//対メルカヴァ
			{ PL=0, delay=234, SE=120, }, //「貴方の中にある想いも、ここで潰えましょう」（メルカヴァ「それは思い上がりというものだ、小娘……）
			{ PL=1, PAT=902, delay=246, SE=109, }, //「それは思い上がりというものだ、小娘……」
		],
	},
	
	{
		Enemy=[23], WaitPAT = [50,900],
		duet_timeline =
		[
			//対クオン
			{ PL=0, delay=163, SE=122, }, //「リヒトクライスの名において貴方を！」（クオン「止められるかい、僕を……」）
			{ PL=1, PAT=901, delay=138, SE=117, }, // （オリエ「リヒトクライスの名において貴方を！」）「止められるかい、僕を……」
		],
	},
	
	{
		Enemy=[22], WaitPAT = [900,50],
		duet_timeline =
		[
			//対カグヤ
			{ PL=1, delay=235, SE=105, }, //「ここから先は汚れ仕事。私に任せておきなさい」
			{ PL=0, PAT=901, delay=199, SE=124, }, //（カグヤ「ここから先は汚れ仕事。私に任せておきなさい」）「いつまでも、貴女に甘えていられないから」
		],
	},
];

CommonStandbyParams[5] =
[
	{ WaitPAT = 50, timeline = [ { delay=128, SE=100, time=128 }, ], }, //「風が騒がしいな」
	{ WaitPAT = 51, timeline = [ { delay=112, SE=101, time=112 }, ], }, //「ようやくお出ましかい」
	{ WaitPAT = 50, timeline = [ { delay=126, SE=102, time=126 }, ], }, //「手短に終わらせようか」
	{ WaitPAT = 51, timeline = [ { delay=133, SE=103, time=133 }, ], }, //「退屈しないで済みそうだ」
	
	{
		Enemy=[15], WaitPAT = [50,900],
		duet_timeline =
		[
			// 対ケイアス
			{ PL=0, delay=179, SE=108, }, //「お前さんが出向いてくるたぁ珍しい」
			{ PL=1, PAT=901, delay=205, SE=108, }, //「キミを思っての事、それ以外にあるかい？」
		],
	},
	{
		Enemy=[10], WaitPAT = [905,50],
		duet_timeline =
		[
			// 対ヒルダ
			{ PL=1, delay=160, SE=113, }, //「白黒つけましょ？　ねぇ……？」（ゴルドー「踏み込みすぎると、大ケガするぜ？）
			{ PL=0, PAT=906, delay=152, SE=114, }, //「踏み込みすぎると、大ケガするぜ？」
		],
	},
	{
		Enemy=[17], WaitPAT = [50,900],
		duet_timeline =
		[
			// 対エンキドゥ
			{ PL=0, delay=164, SE=117, }, //「お眼鏡に叶う者は見つかったかい？」
			{ PL=1, PAT=901, delay=136, SE=112, }, //（ゴルドー「お眼鏡に叶う者は見つかったかい？）「あぁ、今丁度な……」
		],
	},
	{
		Enemy=[16], WaitPAT = [50,50],
		duet_timeline =
		[
			// 対ワーグナー
			{ PL=0, delay=160, SE=120, }, //「ようやく出会えたな、紅騎士(あかきし)よ。」
			{ PL=1, delay=139, SE=115, }, //「いいだろう、全力で来い。」
		],
	},
	{
		Enemy=[16], WaitPAT = [50,50],
		duet_timeline =
		[
			// 対ワーグナー
			{ PL=0, delay=135, SE=121, }, //「ま、少しばかりつきあえよ」」（ワーグナーいいだろう、全力で来い。）
			{ PL=1, delay=139, SE=115, }, //「いいだろう、全力で来い。」
		],
	},
	{
		Enemy=[16], WaitPAT = [50,50],
		duet_timeline =
		[
			// 対ワーグナー
			{ PL=0, delay=189, SE=123, }, //「何も変わらねぇことは解ってるんだがな…」（ワーグナー「御託はいいから来たらどうだ？」）
			{ PL=1, PAT=900, delay=178, SE=126, }, //「御託はいい。さっさと来たらどうだ？」
		],
	},
];

CommonStandbyParams[6] =
[
	{ WaitPAT = 50, timeline = [ { delay=155, SE=100, time=155 }, ], }, //「ギョッギョッギョー！（空から着陸しつつ）」
	{ WaitPAT = 50, timeline = [ { delay=105, SE=101, time=105 }, ], }, //「ギュオオーッ！（戦い前の雄叫び）」
	{ WaitPAT = 50, timeline = [ { delay=188, SE=102, time=188 }, ], }, //「存分に味わわせてもらおう」
	{ WaitPAT = 50, timeline = [ { delay= 71, SE=103, time= 71 }, ], }, //「キュエー！」
	{ WaitPAT = 50, timeline = [ { delay=111, SE=104, time=111 }, ], }, //「キュオァアアアアアアッ（戦い前の雄叫び）」
	
	{
		Enemy=[18], WaitPAT = [900,50],
		duet_timeline =
		[
			// 対ロンドレキア
			{ PL=1, delay=204, SE=116, }, //「僕たちの関係も、終わりというワケだね（メルカヴァ「あぁ、そのようなもの元より存在せぬ」）」
			{ PL=0, PAT=902, delay=257, SE=112, }, //「あぁ、そのようなもの元より存在せぬ」
		],
	},
	{
		Enemy=[23], WaitPAT = [50,900],
		duet_timeline =
		[
			// 対クオン
			{ PL=0, delay=217, SE=115, }, //「この世界を食らうのは我だ……っ！」
			{ PL=1, PAT=901, delay=185, SE=121, }, // （メルカヴァ「この世界を食らうのは我だ……っ！」）「収まりきるかい？　キミのその腹に」
		],
	},
];

CommonStandbyParams[7] =
[
	{ WaitPAT = 50, timeline = [ { delay=144, SE=100, time=144 }, ], }, //「能力の調査確認を開始」
	{ WaitPAT = 50, timeline = [ { delay=121, SE=101, time=121 }, ], }, //「オブリテレート タスクへ移行」
	{ WaitPAT = 50, timeline = [ { delay=101, SE=102, time=101 }, ], }, //「掃討を開始します」
	
	{
		Enemy=[23], WaitPAT = [900,50],
		duet_timeline =
		[
			//対クオン
			{ PL=1, delay=219, SE=124, }, //「彼（か）の時は世話になったな、天の御使(みつか)い」（バティスタ「廻(めぐ)る縁(えにし)。今は相対する者」）
			{ PL=0, PAT=901, delay=190, SE=107, }, //（クオン「彼の時は世話になったな、天の御使(みつか)い」）「廻(めぐ)る縁(えにし)。今は相対する者」
		],
	},
];

CommonStandbyParams[8] =
[
	{ WaitPAT = 50, timeline = [ { delay=156, SE=100, time=156 }, ], }, // 「命が惜しければ邪魔をするな。」
	{ WaitPAT = 50, timeline = [ { delay=110, SE=101, time=110 }, ], }, // 「無駄な抵抗はよせ」
	{ WaitPAT = 50, timeline = [ { delay=148, SE=102, time=148 }, ], }, // 「能書きはいい。構えろ」

	// 対ハイド　※掛け合いがあるので未使用
	// { Enemy=[0], WaitPAT = 50, timeline = [ { PAT=50, delay=148, SE=107, time=148 }, ], }, // 「お前ごときが…フン！」
	
	{
		Enemy=[9], WaitPAT = [900,50],
		duet_timeline =
		[
			// 対ユズリハ
			{ PL=1, delay=139, SE=108, }, // 「迷い、消えたみたいだね」
			{ PL=0, PAT=901, delay=188, SE=118, }, //（ユズリハ「迷い、消えたみたいだね」）「ふっ、今の俺に迷いなど……」
		],
	},
	{
		Enemy=[15], WaitPAT = [900,50],
		duet_timeline =
		[
			// 対ケイアス
			{ PL=1, delay=210, SE=113, }, //「どうだい？　再び手を組む最後のチャンス」
			{ PL=0, PAT=901, delay=212, SE=121, }, //「ケイアス「どうだい？　再び手を組む最後のチャンス」）「フッ、割れた皿は元には戻るまい……」
		],
	},
	{
		Enemy=[23], WaitPAT = [50,900],
		duet_timeline =
		[
			// 対クオン
			{ PL=0, delay=222, SE=124, }, //「このときを、待ち兼ねたぞ……『永劫』！」（クオン「僕もだ。役者が揃う、この瞬間をね……」）
			{ PL=1, PAT=901, delay=255, SE=108, }, // （セト「このときを、待ち兼ねたぞ……『永劫』！」）「僕もだ。役者が揃う、この瞬間をね……」
		],
	},
];


CommonStandbyParams[9] =
[
	{ WaitPAT = 50, timeline = [ { delay=145, SE=100, time=145 }, ], }, // 「よぉーし、覚悟なさーい！」
	{ WaitPAT = 50, timeline = [ { delay=141, SE=101, time=141 }, ], }, // 「お相手……願いましょうか！」
	{ WaitPAT = 50, timeline = [ { delay=224, SE=102, time=224 }, ], }, // 「やれやれ……楽には勝たせてもらえなさそうだ」
	{ WaitPAT = 50, timeline = [ { delay=231, SE=103, time=231 }, ], }, // 「いい目してるねぇ…、オーケーはじめましょう！」
	{ WaitPAT = 50, timeline = [ { delay=198, SE=104, time=198 }, ], }, // 「迷いなんてものは、もう捨てたからね」

	{
		Enemy=[16], WaitPAT = [900,50],
		duet_timeline =
		[
			// 対ワーグナー
			{ PL=1, delay=163, SE=123, }, //「侍よ、手合わせ願おう」
			{ PL=0, PAT=902, delay=167, SE=110, }, // 「よろしい、受けて立ちましょう！」
		],
	},
	{
		Enemy=[19], WaitPAT = [900,50],
		duet_timeline =
		[
			// 対ツルギ
			{ PL=1, delay=218, SE=113, }, // 「リーチとスピード…。近づけるかおい…？
			{ PL=0, PAT=902, delay=242, SE=112, }, // 「パワーと防御…か。こりゃ苦労しそうだ（心の声のようにつぶやくイメージです）」
		],
	},
	{
		Enemy=[23], WaitPAT = [900,50],
		duet_timeline =
		[
			// 対クオン
			{ PL=1, delay=263, SE=126, }, // 「淀みは死、生きるとは変わること、だったね」（ユズリハ「だから変える、アンタの運命も」）
			{ PL=0, PAT=902, delay=206, SE=114, }, // 「だから変える、アンタの運命も」
		],
	},
];


CommonStandbyParams[10] =
[
	{ WaitPAT = 50, timeline = [ { delay=195, SE=100, time=195 }, ], }, //「うふふふ、楽しませて頂戴？」
	{ WaitPAT = 50, timeline = [ { delay=140, SE=101, time=140 }, ], }, //「讃えなさい、このアタシを…！」
	{ WaitPAT = 50, timeline = [ { delay=194, SE=102, time=194 }, ], }, //「どぉ〜れ、少し遊んであげようかしら？」

	{
		Enemy=[15], WaitPAT = [50,900],
		duet_timeline =
		[
			//対ケイアス
			{ PL=0, delay=200, SE=111, }, //（ケイアス「ま、キミとぶつかるのも想定内ではある」）「一方的な敗北は、想定内かしら？」
			{ PL=1, PAT=901, delay=145, SE=110, }, //「ヒルダ…、またキミは（こんなことをして）…（呆れ）」
		],
	},
	{
		Enemy=[15], WaitPAT = [50,50],
		duet_timeline =
		[
			//対ケイアス
			{ PL=1, delay=189, SE=111, }, //「ま、キミとぶつかるのも想定内ではある」
			{ PL=0, delay=200, SE=111, }, //（ケイアス「ま、キミとぶつかるのも想定内ではある」）「一方的な敗北は、想定内かしら？」
		],
	},
	{
		Enemy=[17], WaitPAT = [50,900],
		duet_timeline =
		[
			//対エンキドゥ
			{ PL=0, delay=147, SE=114, }, //「今まで退屈だったでしょ〜？」（エンキドゥ「この瞬間のための、代償であろう）
			{ PL=1, PAT=901, delay=151, SE=116, }, //（ヒルダ「今まで退屈だったでしょ〜？」）「この瞬間のための、代償であろう」
		],
	},
	{
		Enemy=[23], WaitPAT = [50,900],
		duet_timeline =
		[
			//対クオン
			{ PL=0, delay=146, SE=115, }, //「ホントここまで長かったわぁ……」（クオン「永遠を望むなら、待つ事には慣れておくんだね」）
			{ PL=1, PAT=901, delay=239, SE=128, }, // （ヒルダ「ホントここまで長かったわぁ…」）「永遠を望むなら、待つ事には慣れておくんだね」
		],
	},
];

CommonStandbyParams[11] =
[
	{ WaitPAT = 50, timeline = [ { delay=195, SE=100, time=95 }, ], }, // 「お仕置きの時間です。」
	{ WaitPAT = 50, timeline = [ { delay=195, SE=101, time=167 }, ], }, // 「見せてあげましょう、年季の違いを。」

	{
		Enemy=[14], WaitPAT = [50,900],
		duet_timeline =
		[
			//対アカツキ
			{ PL=0, delay=179, SE=106, }, //「それではラストダンスと参りましょうか、先輩」
			{ PL=1, PAT=901, delay=122, SE=106, }, //「相変わらず妙なやつだ」
		],
	},
];

CommonStandbyParams[12] =
[
	{ WaitPAT = 50, timeline = [ { delay=175, SE=100, time=175 }, ], }, // 「この風の流れ…やる気なのねっ！」
	{ WaitPAT = 50, timeline = [ { delay=154, SE=101, time=154 }, ], }, // 「あたしの力、見せてあげるわ！」

	// 対ハイド
	{ Enemy=[0], WaitPAT = 50, timeline = [ { delay=225, SE=106, time=225 }, ], }, //「見つけた…　覚悟なさい、城戸ハイド！」
	
	{
		Enemy=[24], WaitPAT = [50,900],
		duet_timeline =
		[
			// 対フォノン
			{ PL=0, delay= 96, SE=108, }, //「あー先輩！」
			{ PL=1, PAT=901, delay=151, SE=111, }, //（ナナセ「あー、先輩！」）「余計なことは喋るなよぉ…？」
		],
	},
];

// あのこ、あのひと、の分岐用
// 女キャラには「あの子」、それ以外は「あの人」
// ヒルダは「あの人」
local girl_chara_list = [1,4,7,9,11,12,16,20,21,22,24];

CommonStandbyParams[13] =
[
	{ WaitPAT = 900, timeline = [ { SE=80, time=130, delay=130 }, { PAT=901, delay=100, SE=101, time=100 }, ], }, // 「後はお願いね、ビャクヤ」「任せてよ姉さん （姉へ向けて）」
	{ WaitPAT = 900, timeline = [ { SE=80, time=130, delay=130 }, { PAT=901, delay= 84, SE=104, time= 84 }, ], }, // 「後はお願いね、ビャクヤ」「や、こんばんは （相手に対して）」
	{ WaitPAT = 900, timeline = [ { SE=80, time=130, delay=130 }, { PAT=901, delay=103, SE=106, time=103 }, ], }, // 「後はお願いね、ビャクヤ」「懲りないね〜ホント（姉へ向けて）」

	{ ExcludeEnemy=girl_chara_list, WaitPAT = 900, timeline = [ { SE=81, time=134, delay=134 }, { PAT=901, delay=205, SE=105, time=205 }, ], }, // 「しつこいわね、あの人……」「早速でわるいんだけど。消えてもらうよ」
	{ ExcludeEnemy=girl_chara_list, WaitPAT = 900, timeline = [ { SE=81, time=134, delay=134 }, { PAT=901, delay=110, SE=107, time=110 }, ], }, // 「しつこいわね、あの人……」「や、また会ったね （相手に対して）」

	{ Enemy=girl_chara_list, WaitPAT = 900, timeline = [ { SE=82, time=130, delay=130 }, { PAT=901, delay=205, SE=105, time=205 }, ], }, // 「しつこいわね、あの子……」「早速でわるいんだけど。消えてもらうよ」
	{ Enemy=girl_chara_list, WaitPAT = 900, timeline = [ { SE=82, time=130, delay=130 }, { PAT=901, delay=110, SE=107, time=110 }, ], }, // 「しつこいわね、あの子……」「や、また会ったね （相手に対して）」
	{ WaitPAT = 900, timeline = [ { SE=83, delay=189}, { PAT=901, delay=137, SE=109, time=137 }, ], }, // 「我が弟ビャクヤがあなたを喰らいに来たわ」「僕の名でケンカ売るのやめて？」
	
	{
		Enemy=[22], WaitPAT = [50,50],
		duet_timeline =
		[
			// 対カグヤ
			// 同時にしゃべるので字幕位置調整
			{ PL=0, delay=  0, SE=118, time=152, flags=(1<<0) }, //「その笑顔、消してみせよう（次に続く）」152
			{ PL=1, delay=151, SE=106, time=151, flags=(1<<0) }, //「その笑顔、消してみせましょう（次に続く）」151

			{ PL=0, delay= 87, SE=120, }, //「……被らせないでよ」※上のと順番に再生する
			{ PL=1, PAT=911, delay=112, SE=107, time=103 }, //「……貴方の方こそ」
		],
	},
];

CommonStandbyParams[14] =
[
	{ WaitPAT = 50, timeline = [ {delay=155, SE=100, time=155 }, ], }, //「我、死すとも死せず！」
	{ WaitPAT = 50, timeline = [ {delay=209, SE=101, time=209 }, ], }, //「願わくば我に七難八苦を与えたまえ！」
	{ WaitPAT = 50, timeline = [ {delay=211, SE=102, time=211 }, ], }, //「憂き事の、尚この上に積もれかし（限りある身の、力試さん！）」
];

CommonStandbyParams[15] =
[
	{ WaitPAT = 50, timeline = [ { delay=150, SE=100, time=150 }, ], }, //「さて、片づけを始めようか」
	{ WaitPAT = 50, timeline = [ { delay=161, SE=101, time=161 }, ], }, //「僕は頭脳労働担当なんだけどね…」
	{ WaitPAT = 50, timeline = [ { delay=156, SE=102, time=156 }, ], }, //「キミはどこまで足掻いてくれるのかな」
	{ WaitPAT = 50, timeline = [ { delay= 97, SE=103, time= 97 }, ], }, //「お手柔らかに頼むよ」
	{ WaitPAT = 50, timeline = [ { delay=134, SE=104, time=134 }, ], }, //「メガネを壊すのは止めてくれよ？」

	{
		Enemy=[23], WaitPAT = [50,900],
		duet_timeline =
		[
			// 対クオン
			{ PL=0, delay=170, SE=115, }, //「僕が勝ったら…、解ってるだろ？」
			{ PL=1, PAT=901, delay=213, SE=130, }, // （ケイアス「僕が勝ったら…、解ってるだろ？」）「勿論さ、受け入れよう全てを」
		],
	},
];

CommonStandbyParams[16] =
[
	{ WaitPAT = 50, timeline = [ { delay=123, SE=100, time=123 }, ], }, //「出会った不運を呪うがいい」
	{ WaitPAT = 50, timeline = [ { delay=105, SE=101, time=105 }, ], }, //「一瞬で片付けてやる」
	{ WaitPAT = 50, timeline = [ { delay=136, SE=102, time=136 }, ], }, //「我が炎、試してみるか？」
	{ WaitPAT = 50, timeline = [ { delay=148, SE=103, time=148 }, ], }, //「顕現(イグジス)の使い方を教えてやろう」
	{ WaitPAT = 50, timeline = [ { delay=210, SE=104, time=210 }, ], }, //「私と出会うなど、お前も運が悪いな。」

	// 対メルカヴァ
	{ Enemy=[6], WaitPAT = 50, timeline = [ { delay=183, SE=117, time=183 }, ], }, //「この『虚無狩り』の前に姿を現すとは」
];

CommonStandbyParams[17] =
[
	{ WaitPAT = 50, timeline = [ { delay=148, SE=100, time=148 }, ], }, //「その力、試させてもらおう」
	{ WaitPAT = 50, timeline = [ { delay= 53, SE=101, time= 53 }, ], }, //「…参る！」
	{ WaitPAT = 50, timeline = [ { delay=111, SE=102, time=111 }, ], }, //「…風が、強いな」
	{ WaitPAT = 50, timeline = [ { delay=116, SE=103, time=116 }, ], }, //「さぁ、仕合おうぞ」
	{ WaitPAT = 50, timeline = [ { delay= 88, SE=104, time= 88 }, ], }, //「覚悟はできたか？」
	{ WaitPAT = 50, timeline = [ { delay=148, SE=105, time=148 }, ], }, //「待ち焦がれたぞ、この時を！」
	{ WaitPAT = 50, timeline = [ { delay= 92, SE=106, time= 92 }, ], }, //「時は満ちた」

	// 対ゴルドー　※掛け合いがある
	// { Enemy=[5], WaitPAT = 50, timeline = [ { PAT=50, delay=183, SE=110, time=183 }, ], }, //「強欲のものよ、いざ勝負っ！」

	// 対ヒルダ　※掛け合いがある
	// { Enemy=[10], WaitPAT = 50, timeline = [ { PAT=50, delay=183, SE=114, time=183 }, ], }, //「まばゆき闇よ、いざ勝負っ！」

	// 対ケイアス
	{ Enemy=[15], WaitPAT = 50, timeline = [ { delay=142, SE=119, time=142 }, ], }, //「混沌のものよ、いざ勝負っ！」

	
	{
		Enemy=[23], WaitPAT = [50,900],
		duet_timeline =
		[
			//対クオン
			{ PL=0, delay=187, SE=121, }, //「お前なら見せてくれるはずだ、答えを」（クオン「人の身のまま、この領域へ踏み込むか…」）
			{ PL=1, PAT=901, delay=213, SE=135, }, // （エンキ「お前なら見せてくれるはずだ、答えを」）「人の身のまま、この領域へ踏み込むか…」
		],
	},
];

CommonStandbyParams[18] =
[
	{ WaitPAT = 50, timeline = [ { delay=106, SE=100, time=106 }, ], }, //「これも僕の任務だ。」
	{ WaitPAT = 51, timeline = [ { delay=122, SE=102, time=122 }, ], }, //「偽誕者(インヴァース)…鎮圧する」
	{ WaitPAT = 50, timeline = [ { delay=173, SE=103, time=173 }, ], }, //「手ごわそうな相手だが…やってみせる。」
	{ WaitPAT = 51, timeline = [ { delay=173, SE=104, time=173 }, ], }, //「負けるワケにはいかない。リッターシルトの名にかけて」
	{ WaitPAT = 50, timeline = [ { delay=185, SE=105, time=185 }, ], }, //「森羅万象、凍らぬものはなし」
	{ WaitPAT = 51, timeline = [ { delay=221, SE=106, time=221 }, ], }, //「互いの誇りにかけて正々堂々、勝負だ」
	{ WaitPAT = 50, timeline = [ { delay=169, SE=107, time=169 }, ], }, //「どんな能力だろうと、凍らせよう」

	//対オリエ
	{ Enemy=[4], WaitPAT = 51, timeline = [ { delay=154, SE=110, time=154 }, ], }, //「君との出会い、光栄に思うよ」
	{ Enemy=[4], WaitPAT = 50, timeline = [ { delay= 85, SE=111, time= 85 }, ], }, //「お手合わせ、願おう！」
	
	//対ミカ
	{ Enemy=[21], WaitPAT = 51, timeline = [ { delay=144, SE=118, time=144 }, ], }, //「テ……テンス・イグゼクター！？」
	
	//対ワーグナー
	{ Enemy=[16], WaitPAT = 50, timeline = [ { delay=199, SE=121, time=199 }, ], }, //「燃え盛る炎だろうと、凍らせてみせる！」
	{ Enemy=[16], WaitPAT = 50, timeline = [ { delay= 93, SE=122, time= 93 }, ], }, //「勝負だ『虚無狩り』！」
	{ Enemy=[16], WaitPAT = 50, timeline = [ { delay=252, SE=123, time=252 }, ], }, //「君を倒し、証明しよう。僕たちの方が上であるとね。」
	
	// //対メルカヴァ　※掛け合いがある
	// { Enemy=[6], WaitPAT = 50, timeline = [ { PAT=50, delay=252, SE=113, time=252 }, ], }, //「つくづく、君とは縁があるようだ
	// { Enemy=[6], WaitPAT = 50, timeline = [ { PAT=50, delay=252, SE=114, time=252 }, ], }, //「君とまた、出会うことになるとはね」
];

CommonStandbyParams[19] =
[
	{ WaitPAT = 50, timeline = [ { delay=117, SE=100, time=117 }, ], }, // 「おっしゃぁ！行くぜ！」
	{ WaitPAT = 50, timeline = [ { delay=124, SE=101, time=124 }, ], }, // 「よし！ケンカしようぜ！」
	{ WaitPAT = 50, timeline = [ { delay=237, SE=102, time=237 }, ], }, // 「いっちょこの若輩者に、ドぎつい稽古お願いしましょうか！」
	{ WaitPAT = 50, timeline = [ { delay=189, SE=103, time=189 }, ], }, // 「邪魔するってんならしょうがねえ、ぶん殴る！」
	
	{
		Enemy=[24], WaitPAT = [50,900],
		duet_timeline =
		[
			{ PL=0, delay=225, SE=107, }, // 「良い機会だ。お前の実力、見せてくれよ」
			{ PL=1, PAT=901, delay=213, SE=113, }, //（ツルギ「良い機会だ。お前の実力、見せてくれよ」）「暑苦しいヤロウだ、あとで泣くなよ〜？」
		],
	},
];

CommonStandbyParams[21] =
[
	{ WaitPAT = 899, timeline = [ { PAT=901, delay= 80, SE=100, time= 80 }, ], }, //「おいーっす！」
	{ WaitPAT = 899, timeline = [ { PAT=901, delay= 79, SE=101, time= 79 }, ], }, //「ミカちゃん参上っ！」
	{ WaitPAT = 899, timeline = [ { PAT=901, delay=125, SE=102, time=125 }, ], }, //「アチシがお相手するんよ〜！」
	{ WaitPAT = 899, timeline = [ { PAT=901, delay=120, SE=103, time=120 }, ], }, //「ミカちゃんです！よろしくぅー！」
	{ WaitPAT = 899, timeline = [ { PAT=901, delay=104, SE=104, time=104 }, ], }, //「ちょっと通らせて貰います！」

	{ WaitPAT = 899, timeline = [ { PAT=900, delay=25 }, { delay=130, SE=106, time=130 }, ], }, //「あだ」「覚悟するんゆー！」
	{ WaitPAT = 899, timeline = [ { PAT=900, delay=25 }, { delay=149, SE=109, time=149 }, ], }, //「ぶっ」「勝負するんゆー！」
	{ WaitPAT = 899, timeline = [ { PAT=900, delay=25 }, { delay=180, SE=112, time=180 }, ], }, //「いでっ」「いざ尋常に成敗いたす！」
	
	{
		Enemy=[22], WaitPAT = [899,50],
		duet_timeline =
		[
			{ PL=0, PAT=901, delay=155, SE=122, }, //（対カグヤ）「ミカちゃん、ここは勝たせて貰います！！」
			{ PL=1, PAT=910, delay=224, SE=109, }, //「え〜？　絶対後悔させますよ？　今のセリフ」
		],
	},
];

CommonStandbyParams[22] =
[
	{ WaitPAT = 50, timeline = [ { delay=134, SE=100, time=134 }, ], }, //「派手に蹴散らしましょう〜！」
	{ WaitPAT = 50, timeline = [ { delay=182, SE=101, time=182 }, ], }, //「それではいきますよ〜、いざ勝負！」
	{ WaitPAT = 50, timeline = [ { delay=173, SE=102, time=173 }, ], }, //「ここは正攻法で挑むと致しましょう♪」
	{ WaitPAT = 50, timeline = [ { delay=184, SE=103, time=184 }, ], }, //「あらあら、お仕置きが必要かしら？」
	{ WaitPAT = 50, timeline = [ { delay=154, SE=104, time=154 }, ], }, //「お手並み拝見といきましょう〜」
	
	{
		Enemy=[23], WaitPAT = [50,900],
		duet_timeline =
		[
			{ PL=0, delay=144, SE=110, }, //「言い残すことは、ありませんか？」
			{ PL=1, PAT=901, delay=263, SE=132, }, // （カグヤ「言い残すことは、ありませんか？」）「無いよ。君に心配される必要は、ね」
		],
	},
];

CommonStandbyParams[23] =
[
	{ WaitPAT = 50, timeline = [ { delay=174, SE=100, time=174 }, ], }, // 「その『命』摘み取らせて貰うよ」
	{ WaitPAT = 50, timeline = [ { delay=202, SE=101, time=202 }, ], }, // 「それじゃあ始めよう、最後の夜をね」
	{ WaitPAT = 50, timeline = [ { delay=210, SE=102, time=210 }, ], }, // 「この力の意味、身を以て知ると良い」
	{ WaitPAT = 50, timeline = [ { delay=190, SE=103, time=190 }, ], }, // 「望み通り、全力で相手をしよう」
];

CommonStandbyParams[24] =
[
	{ WaitPAT = 50, timeline = [ { delay=128, SE=100, time=128 }, ], }, //「このアタシが見逃すとでも？」
	{ WaitPAT = 50, timeline = [ { delay=175, SE=101, time=175 }, ], }, //「フォノン様がお相手だ、覚悟しな」
	{ WaitPAT = 50, timeline = [ { delay=102, SE=102, time=102 }, ], }, //「…ったく、やかましい」
	{ WaitPAT = 50, timeline = [ { delay= 97, SE=103, time= 97 }, ], }, //「いくよ、ムーニー（ペットの蛇が鞭に変形する）」
	{ WaitPAT = 50, timeline = [ { delay=179, SE=105, time=179 }, ], }, //「ち…血の華…咲かせてやる」
	{ WaitPAT = 50, timeline = [ { delay=156, SE=106, time=156 }, ], }, //「かったるいけど、やるしかないな」
];

CommonStandbyParams[20] =
[
	{ WaitPAT = 50, timeline = [ { delay=150, SE=100, time=150 }, ], }, //「邪魔すんなら消しちまうぜぇ！」
	{ WaitPAT = 50, timeline = [ { delay=164, SE=101, time=164 }, ], }, //「旨そうな『顕現(イグジス)』だなぁおい！」
	{ WaitPAT = 901, timeline = [ { delay=242, SE=102, time=242 }, ], }, //「オメーにも見せてやろうか？地獄ってやつをよぉ！」
	{ WaitPAT = 901, timeline = [ { delay=205, SE=103, time= 205 }, ], }, //「オレ様に歯向かって無事で済むと思うなよぉ！」
	
	{
		Enemy=[4], WaitPAT = [900,900],
		duet_timeline =
		[
			{ PL=1, delay=167, SE=172 }, //「これが、死を連れ添う者……！」
			{ PL=0, delay=160, time=183, SE=108, PAT=901 }, //「失礼な、こいつらはトモダチだよ」
			{ PL=1, delay= 24, PAT=921 },
		],
	},
	{
		Enemy=[0], WaitPAT = [900,902],
		duet_timeline =
		[
			{ PL=1, delay=284, SE=138, PAT=911 }, //「怖ぇな。形だけは人間なのが尚更だ。」
			{ PL=0, delay=293, SE=111, PAT=901 }, //「ヒッヒッヒ、お前の魂もその器から解放してやろう」
		],
	},
	{
		Enemy=[23], WaitPAT = [900,50],
		duet_timeline =
		[
			{ PL=1, delay=120, SE=137, }, //「楽しんで貰えるよう、努めるよ」
			{ PL=0, delay=176, SE=114, PAT=50 }, //「そりゃ、テメェの悲鳴次第だなぁ」
		],
	},
	{
		Enemy=[10], WaitPAT = [50,50],
		duet_timeline =
		[
			{ PL=0, delay=187, SE=117, }, //「な？　こうなるのは運命なんだよ」
			{ PL=1, delay=159, SE=116, }, //「貴方が敗れるところまでが、ね」
		],
	},
	{
		Enemy=[17], WaitPAT = [900,50],
		duet_timeline =
		[
			{ PL=1, delay=201, SE=123, }, //「今の俺が相手なら、咎める者もなかろう」
			{ PL=0, delay=152, SE=120, PAT=50 }, //「んなモン、最初からねぇよ」
		],
	},
	{
		Enemy=[15], WaitPAT = [900,900],
		duet_timeline =
		[
			{ PL=0, delay=235, SE=123, PAT=901 }, //「隠し事、企み事…、嫌いじゃねぇがな」
			{ PL=1, delay=210, SE=117, PAT=901 }, //「同感だ、僕もキミのことは嫌いじゃない」
		],
	},	
];

CommonStandbyParams[27] =
[
	{ WaitPAT = 50, timeline = [ { delay=112, SE=100, time=112 }, ], }, // 「出ろ！　インスレーター！」
	{ WaitPAT = 51, timeline = [ { delay=186, SE=101, time=186 }, ], }, // 「邪魔をするなら…片付けるまでだ！」
	{ WaitPAT = 50, timeline = [ { delay=124, SE=102, time=124 }, ], }, // 「……この力で終わらせてやる！」
	{ WaitPAT = 51, timeline = [ { delay=146, SE=103, time=146 }, ], }, // 「オレの力……見せてやる！」
	
	{
		Enemy=[1], WaitPAT = [50,900],
		duet_timeline =
		[
			{ PL=0, delay=164, SE=108, } // 「いつまでもあの頃の俺じゃないぜ？」
			{ PL=1, PAT=901, delay=144, SE=108, }, //「解っているさ、それくらいな」
		],
	},
	{
		Enemy=[2], WaitPAT = [902,50],
		duet_timeline =
		[
			{ PL=1, delay=229, SE=109, }, // 「ふん、一丁前の顔になりおったな」
			{ PL=0, PAT=903, delay=160, SE=111, }, //「あんたのお陰だ、礼を言うぜ」
		],
	},
	{
		Enemy=[16], WaitPAT = [902,50],
		duet_timeline =
		[
			{ PL=1, delay=234, SE=119, }, //「フッ、余程私の事が忘れられぬと見える」
			{ PL=0, PAT=903, delay=152, SE=113, }, //「誤解されるようなこと言うなよ！！」
		],
	},	
	{
		Enemy=[8], WaitPAT = [50,900],
		duet_timeline =
		[
			{ PL=0, delay=209, SE=115, }, //「ま、決着はつけなくちゃいけねぇよな」
			{ PL=1, PAT=901, delay=191, SE=109, }, //「解りきったことだ。必要なかろう……」
		],
	},
	{
		Enemy=[3], WaitPAT = [50,900],
		duet_timeline =
		[
			{ PL=0, delay=156, SE=118, }, //「懲りねぇヤロウだな、お前も。」
			{ PL=1, PAT=901, delay=186, SE=107, }, //「唯一の趣味だ、邪魔すんじゃねぇよ」
		],
	},
	{
		Enemy=[10], WaitPAT = [902,50],
		duet_timeline =
		[
			{ PL=1, delay=181, SE=110, }, //「その余裕、舐められたものね」
			{ PL=0, PAT=903, delay=188, SE=121, }, //「開き直ってるだけだ、気にすんなよ」
		],
	},
	
	{
		Enemy=[23], WaitPAT = [50,900],
		duet_timeline =
		[
			{ PL=0, delay=146, SE=124, }, //「さぁ、幕と行こうぜ！」
			{ PL=1, PAT=901, delay=145, SE=110, }, //「……久遠なる物語に終わりはない」
		],
	},
	{
		Enemy=[19], WaitPAT = [51,900],
		duet_timeline =
		[
			{ PL=0, delay=188, SE=127, }, //「呆れた腐れ縁だな、ったく」
			{ PL=1, PAT=901, delay=179, SE=110, }, //「運命の赤い糸、って言うんだよ」
		],
	},	

	{
		Enemy=[4], WaitPAT = [50,900],
		duet_timeline =
		[
			{ PL=0, delay=136, SE=130, }, //「……黙って退いちゃくれねぇか？」
			{ PL=1, PAT=901, delay=205, SE=113, }, //「出来ません、貴方もそうであるように」
		],
	},	
	{
		Enemy=[22], WaitPAT = [51,900],
		duet_timeline =
		[
			{ PL=0, delay=167, SE=133, }, //「アンタとは、やり合いたくねーんだが」
			{ PL=1, PAT=901, delay=204, SE=108, }, //「お気になさらずに。私も気にしませんから♪」
		],
	},	
	{
		Enemy=[7], WaitPAT = [902,50],
		duet_timeline =
		[
			{ PL=1, delay=272, SE=105, }, //「貴方を倒し先へ進む、これは私自身の意思……」
			{ PL=0, PAT=903, delay=209, SE=136, }, //「一番やりにくい相手だな、こりゃ」
		],
	},	
];

CommonStandbyParams[28] =
[
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=100, time=226, delay=66 }, { PAT=921, delay=170 } ] }, // 「貴様は、我が姿に何を見る！」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=101, time=196, delay=86 }, { PAT=921, delay=120 } ] }, // 「世に地獄の種は尽きぬらしい！」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=102, time=301, delay=171 }, { PAT=921, delay=140 } ] }, // 「我が名は復讐者、巌窟王エドモン・ダンテス
	{ WaitPAT = 922, timeline = [ { PAT=922, SE=103, time=186, delay=166 }, { PAT=925, delay=70 } ] }, // 「捜し物は、貴様ではない……」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=104, time=282, delay=122 }, { PAT=921, delay=170 } ] }, // 「話し合いより、こちらの方が早い人種か」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=105, time=208, delay=78 }, { PAT=921, delay=140 } ] }, // 「ははは、ははははははははははは！」
];


//CommonStandbyParamsのエラーチェック処理
//timeよりも極端にdelayが少ないと字幕がかぶってしまうのでそれを調べる
//timeとparamの差も調べる
if( 0 && Def_Dbg_LocalDebugMode ){
	local limit_sa = 0;//10;
	local chr_mvs = BMvTbl.GetMvStatus();
	foreach( slot, val in CommonStandbyParams )
	{
		//slot = P0キャラ番号
		//
		//val = 配列?
		if( typeof val == "array" )
		{
			_dpn("キャラ:"+slot+" chr_mvs:"+chr_mvs.CharaNo);
			local check_voice_len = ( slot == chr_mvs.CharaNo)? 1 : 0; // 自キャラしか取得できないんでね
			
			for( local i=0; i<val.len(); i++ )
			{
				if( "timeline" in val[i] )
				{
					local tl = val[i].timeline;
					_dpn("TL["+i+"]");
					if( typeof tl != "array" ) break;
					
					local time = [0,0]; // 音声再生時間
					local delay = [0,0]; // アニメディレイ時間
					for( local j=0; j<tl.len(); j++ )
					{
						local id = ( "TAG" in tl[j] )? tl[j].TAG : 0;
						if( "delay" in tl[j] ) delay[id] += tl[j].delay;
						if( "time" in tl[j] ) time[id] += tl[j].time;
						local se = ( "SE" in tl[j] )? tl[j].SE : 0;
						
						if( check_voice_len && se )
						{
							local param = BSound.SE_GetUserParam( { type=_SeType_Player, num=se, } );//音声のフレーム数を取得
							local file_size = BSound.SE_GetBufferSize( { type=_SeType_Player, num=se } );
							local calc_frame = ((file_size / (48 * 2))*60)/1000;
							
							_dpn("se:"+se+" param:"+param+" -> "+calc_frame);
							
							if( abs(param-calc_frame) > 1 )
							{
								_dpn("エラーーー");
							}
						}
					}

					//？？？pl1ってある？
					for( local pl=0; pl<2; pl++ )
					{
						local sa = time[pl]+limit_sa - delay[pl];
						if( time[pl] > 0 && sa > 0 )
						{
							_dpn(" ★"+pl+1+"P時間:"+delay[pl]+" -> "+time[pl]+" 時間不足:"+sa );
						}
					}
				}
				if( "duet_timeline" in val[i] )
				{
					local tl = val[i].duet_timeline;
					local enemy_num = val[i].Enemy; // なぜか配列
					if( typeof enemy_num == "array" ) enemy_num = enemy_num[0]; // てきとう
					local check_enemy_voice_len = ( enemy_num == chr_mvs.CharaNo)? 1 : 0; // 自キャラしか取得できないんでね
					
					_dpn("DTL["+i+"]");
					if( typeof tl != "array" ) break;
					
					local time = [0,0]; // 音声再生時間
					local delay = [0,0]; // アニメディレイ時間
					for( local j=0; j<tl.len(); j++ )
					{
						local id = ( "PL" in tl[j] )? tl[j].PL : 0;
						if( "delay" in tl[j] ) delay[id] += tl[j].delay;
						if( "time" in tl[j] ) time[id] += tl[j].time;

						local time = ( "time" in tl[j] )? tl[j].time : 0;
						local delay = ( "delay" in tl[j] )? tl[j].delay : 0;
						if( time == 0 )
						{
							time = delay;
						}
						
						local se = ( "SE" in tl[j] )? tl[j].SE : 0;
						
						if( check_voice_len && se && id == 0 )
						{
							local param = BSound.SE_GetUserParam( { type=_SeType_Player, num=se, } );//音声のフレーム数を取得
							local file_size = BSound.SE_GetBufferSize( { type=_SeType_Player, num=se } );
							local calc_frame = ((file_size / (48 * 2))*60)/1000;
							
							_dpn("se:"+se+" param:"+param+" -> "+calc_frame+" time:"+time);
							
							if( abs(param-calc_frame) > 1 )
							{
								_dpn("★★★★★★★★★★★★★★★★★★★★エラーーー1");
							}
							if( abs(time-param) > 1 )
							{
								_dpn("★★★★★★★★★★★★★★★★★★★★エラーーー2");
							}
						}
						if( check_enemy_voice_len && id == 1 && se )
						{
							local param = BSound.SE_GetUserParam( { type=_SeType_Player, num=se, } );//音声のフレーム数を取得
							local file_size = BSound.SE_GetBufferSize( { type=_SeType_Player, num=se } );
							local calc_frame = ((file_size / (48 * 2))*60)/1000;
							
							_dpn("XX se:"+se+" param:"+param+" -> "+calc_frame+" time:"+time);
							
							if( abs(param-calc_frame) > 1 )
							{
								_dpn("★★★★★★★★★★★★★★★★★★★★★エラーーー3");
							}
							if( abs(time-param) > 1 )
							{
								_dpn("★★★★★★★★★★★★★★★★★★★★エラーーー4");
							}							
						}
					}
					for( local pl=0; pl<2; pl++ )
					{
						local sa = time[pl]+limit_sa - delay[pl];
						if( time[pl] > 0 && sa > 0 )
						{
							_dpn(" ★"+pl+1+"P時間:"+delay[pl]+" -> "+time[pl]+" 時間不足:"+sa );
						}
					}				
				}
			}
			_dpn("");
		}
		else
		{
			// 未定義キャラだと0が入っているのでここにくる
			// _dpn("タイプ:"+typeof val+" : "+slot+" -> "+val );
		}
	}
}



// ----------------------------------------------------------------------------
// Std_MoveTable作成
// ----------------------------------------------------------------------------

local Std_MoveTable = {} //基本行動リストテーブル


Battle_Std.AddHitEffects( Std_MoveTable, _ChrNo ); // ヒットエフェクトMvを追加する

// ----------------------------------------------------------------------------
// ゲーム全体の割り込み関数
// ----------------------------------------------------------------------------
//function Std_MoveTable::GeneralInterrupt( info )
Std_MoveTable.GeneralInterrupt <- function( info )
{
	// info は BMvTbl::MvInterruptInfo クラス
	switch( info.type ) // typeで分岐
	{
	case _InterruptType_Ko_Atk: // KOした
		//print( "\n_InterruptType_Ko_Atk" );
		
		Battle_Std.GS_AddFlag( def_PP_GS_KoAtk ); // 何かしらでKOしたのを記憶
		break;
	case _InterruptType_Ko_Def: // KOされた
		//print( "\n_InterruptType_Ko_Def" );
		//スローにする
		BMvEff.Slowmotion_Set( { type=1, time=120, power=6666 } ); //KOスローを他の登録を全消去して追加
		BMvEff.SetCamera_Quake( { type=2, time=40, clear=1 } ); //他の揺らしを止めて画面揺らし

		//キャラ別にいじれるオブジェクトを一応呼ぶ
		BMvEff.CreateObject( { mvname="Mv_KOImpact_Object" } );
		
		//オーラとかがあったら消す
		Battle_Std.PcAuraEffect_AllAuraEnd(); //ＫＯされたキャラはこのタイミングでオーラを消す
		
		BSound.SE_Play( { type=_SeType_Normal, num=71 } ); //ＫＯ効果音
		break;
	case _InterruptType_Judge: // Judge
		// _dpn( "_InterruptType_Judge" );
		// 1Pと2Pでそれぞれ処理が入る
		// 
		
		if( Def_Sys_CelesVorpal )
		{
			Battle_Std.GS_DelFlag( def_PP_GS_CelecVorpal ); // セレスヴォーパルかどうかをリセット
			//この処理がないとCVP後にブレイクして次のVPがCVPに見える
		}
		//ジャッジの結果を取得してペカらせる
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( player.push() )
		{
			local grd_judge_status = BMvEff.GRD_GetJudgeResult();
			Battle_Std.CharaBattleActivity_Increment(101,"両者ヴォーパル回数");
			
			if( grd_judge_status > 0 )
			{
				// ヴォーパルになったことが確定
				Battle_Std.CharaBattleActivity_Increment(100,"ヴォーパル回数");//自分のVP回数
				
				/*
				// リアルタイムで測定しようとすると、1P＞2Pの順で計測するのでちょっとズレてしまうので参考程度に
				Battle_Std.CharaBattleActivity_Calc( {
					title="ヴォーパル確率", 
					molecule=Battle_Std.CharaBattleActivity_Count("ヴォーパル回数"), denominator=Battle_Std.CharaBattleActivity_Count("両者ヴォーパル回数")
				} );
				*/
			
				//ヴォーパル確率＝回数/試合数
				//この計算式だと、タイムアップ放置とかで両者VPになり続けるとすごいことになってしまう
				//欲しい値としては、試合中相手よりどれくらいVPがとれているのか、で100%を目指す形にしたい
				//自分の回数/(自分の回数+相手の回数)=確率
				//これを試合数分記憶していき、フィルタできる形が良さそう
				
				//両者VPのとき、計算が合わなくなるので、引き分けのときは被VP回数は加算しない
				
				// トレモのリスタート時にVPすると色々演出が入ってやかましいのと、GRDも増えてしまって都合が悪いので処理を封じ込める処理
				local is_restart_first = ( Def_Sys_NoPlayTrainingRestartUpsetEffect && Battle_Std.GS_CheckFlag( def_PP_GS_ImmediatelyAfterRestart ) )? 1 : 0;
				
				//仕様変更でリスタート直後の状況が変わっている模様
				//明らかなリスタート直後っぽいところも検知するように
				if( Def_Sys_NoPlayTrainingRestartUpsetEffect )
				{
					local mvname = BMvTbl.GetMvName();
					local change_mvname = BMvTbl.ChangeMv_GetMvName();
					local mvs = BMvTbl.GetMvStatus();
					// _dpn((1+BMvTbl.GetPlayerSide())+"P: mvname:"+mvname+" change_mvname:"+change_mvname+" mvs.MvCount:"+mvs.MvCount);
					if( mvname == "Mv_StandbyNoMotionPass")
					{
						is_restart_first = 1;
					}
					if( change_mvname == "Mv_StandbyNoMotionPass" && mvs.MvCount <= 1 )
					{
						is_restart_first = 1;
					}
				}
				
				// _dpn("is_restart_first:"+is_restart_first);
				
				if( !is_restart_first )
				{
					
					Battle_Std.SetCharaFlash_GRDJudgeFlash();
					//集中わっか
					//わっかエフェクト側からオーラは呼ばれます（座標とタイミングの関係上仕方ない）
					local eff = BMvEff.CreateObject( { x=0, y=-200, datatype=1, start_pat=190, flags=_Position_ToolShift } );
					if( eff.push() )
					{
						BMvEff.SetObjectFlags({ flags=_ObjFlags_ParentMove|_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll });
						
						eff.pop();
					}
					if( Def_Dbg_NoPlayUpsetSE == 0 ) BSound.SE_Play( { type=_SeType_Normal, num=75 } ); //GRD勝利効果音を再生
				}
				
				// セレスティアルヴォーパル
				// GRDが6個以上だったら全部自分のものにする
				if( Def_Sys_CelesVorpal )
				{
					local is_celes_vp = 0;
					local grd_stock = BMvEff.GRD_CheckStock( { val=-1 } );
					
					if( grd_stock >= 6 )
					{
						local enemy = BMvCore.GetEnemyCharaData();
						if( enemy.push() )
						{
							local enemy_grd_stock = BMvEff.GRD_CheckStock( { val=-1 } );
							
							if( grd_stock > enemy_grd_stock )
							{
								is_celes_vp = 1;
								BMvEff.GRD_UseStock( { val=12 } );//空にする
							}
							enemy.pop();
						}
					}
					
					// セレスティアルの効果発動
					if( is_celes_vp )
					{
						BMvEff.AttackInfoString_Set({ word=def_AISW_CelesVorpal,} );

						BMvEff.GRD_AddValue( { val=10000*12, pressure=0, boundplus=1 } ); // GRDを最大に
						
						// セレスティアル・ヴォーパルの処理
						Battle_Std.GS_AddFlag( def_PP_GS_CelecVorpal ); // セレスヴォーパルなのを記憶

						BMvTbl.SetCelestialVorpalMode(1); // セレスティアルな攻撃力アップ
					}
					else if( is_restart_first )
					{
						// トレモのGRDの個数設定がズレるので何もしない
						BMvTbl.SetCelestialVorpalMode(0); // 通常の値に戻す
					}
					else
					{
						BMvEff.GRD_AddValue( { val=10000, pressure=0, boundplus=1 } ); // VP効果としてGRDを1つ増やす
						BMvTbl.SetCelestialVorpalMode(0); // 通常の値に戻す
					}
				}
				
				// ヴォーパルの演出
				// KO後に出すものでもない
				if( !Battle_Std.CharaisKO() && !is_restart_first )
				{
					BMvEff.CreateObject( { mvname="Mv_CVPCutinGrp" } );

					// ボイスに関しては被コンボ中などは再生しないようにする
					if( Def_Dbg_NoPlayUpsetSE == 0 && !Battle_Std.CheckPlayerisDamage() )
					{
						// トレモでは挑発設定を参照
						// ミッションとかでは再生しない
						// 対戦中はとうぜん再生する
						local stage_st = BMvTbl.GetMvStageStatus().IsTrainingBattle(); // 1-Training  2-Tutorial  3-Mission
						local appeal = BMvEff.TM_GetCharaGauge(Def_TMCG_EnableAppeal);//挑発の有無
						if( stage_st == 0 || ( stage_st == 1 && appeal ) )
						{
							local isDying = ( BMvTbl.GetMvStatus().flags & _MvStFlag_DangerHPDef )? 1 : 0; // 瀕死状態
							
							// (1<<3) : 最後に再生したSE番号を更新しない
							if( isDying )
							{
								if( !Battle_Std.TypeSE_Play({ type="ヴォーパル_瀕死", flags=(1<<3) }) )
								{
									Battle_Std.TypeSE_Play({ type="ヴォーパル", flags=(1<<3) });
								}
							}
							else
							{
								Battle_Std.TypeSE_Play({ type="ヴォーパル", flags=(1<<3) });
							}
						}
					}
				}
			}
			player.pop();
		}
		break;
	}
}


//超技中持続するオブジェクト
//超技での背景を切り替えたりする
Std_MoveTable.Mv_SPAfterImage_KanriObject <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender| _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );

		Battle_Std.GS_AddFlag( def_PP_GS_SPKanriObjFlag ); // 暗転中というフラグを立てる
	}
	function FrameUpdate_Std()
	{
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		local skillmove = 0;
		local spmove = 0;
		local object_daburi = 0; // このオブジェクトの２個目が出てきているっぽいかどうか
		
		local obj_mvs = BMvTbl.GetMvStatus();
		local obj_mvs_MvCount = obj_mvs.MvCount+1; // 超技中持続するMvのMvCount(呼び出し分1F遅いので足す)
		
		if( player.push() )
		{
			skillmove = ( Battle_Std.MoveCode.CheckFlag( def_MC_Skill ) );
			spmove = ( Battle_Std.MvAction.CheckFlag( def_MC_SPAction ) );
			
			player.pop();
		}
		
		if( obj_mvs_MvCount == def_FL_SPCutinStopTime ) // 暗転抜けたタイミング
		{
			_dp("\n 暗転おわり");
			Battle_Std.GS_DelFlag( def_PP_GS_SPKanriObjFlag ); // 暗転を抜けたのでフラグを消す
		}
		else if( obj_mvs_MvCount > def_FL_SPCutinStopTime )
		{
			if( Battle_Std.GS_CheckFlag( def_PP_GS_SPKanriObjFlag ) )
			{
				object_daburi = 1; // ２個目でてるっぽい
			}
		}

		if( skillmove && spmove ) //必殺技でＳＰ扱い
		{
		}
		else
		{	
			BMvTbl.SetFinalize(0);
		}
		if( object_daburi )
		{
			_dp("\n ダブリで終了");
			BMvTbl.SetFinalize(100);
		}
	}
	function Finalize()
	{
		if( BMvTbl.GetFinalizeCode() != 100 ) // ダブりで終了の時以外
		{
			local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			if( player.push() )
			{
				BMvEff.PcAfterImage_Clear(); //残像の消去
				BMvEff.CutInProc_Erase(); //カットインがあったら消去する
				
				player.pop();
			}
		}
		BMvTbl.SetDeleteMoveTable();
	}
}

//空振りガード関係
Std_MoveTable.Mv_VGuard_Stand <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする

		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.DataPattern!=def_PAT_VGuard_S )
		{
			BMvTbl.SetPattern(def_PAT_VGuard_S); // 任意
			BMvTbl.JumpFrameID(100); // 行動可能のガードポーズへ
			BMvTbl.VGuard_Time(def_PAT_VGuard_Time);
		}
		else //同じパターンでもFrameIDをチェック
		{
			if( (s.FrameID==120 || s.FrameID==130 ) ) //抜けてた
			{
				BMvTbl.JumpFrameID(100); // 行動可能のガードポーズへ
			}
		}		
		
		Battle_Std.InitCharaVector(); //InitCharaVectorでXMAX初期化するようにしたのでこっちでＯＫ
		//Battle_Std.InitVector(); //ダッシュの慣性が乗ってしまうのでこうする
	}
	function Update_Std() // 
	{
		local type = BMvTbl.VGuard_CheckKeep();
		if( type != 0 )
		{
			BMvTbl.VGuard_Time(def_PAT_VGuard_Time); // もどす
			if( type == 1 ); // そのまま継続
			else if( type == 2 ) BMvTbl.SetFinalize(2); // しゃがみへ
			else
			{
				// 例外、怖いので終わり
				BMvTbl.SetFinalize(0);
			}
		}
		else
		{
			if( BMvTbl.VGuard_Time(-1) == 0 ) // 時間を取得し0だと終了
			{
				BMvTbl.SetFinalize(0);
			}
		}
		//
		//print("\nKeep_Stand" + BMvTbl.VGuard_Time(-1) ); //-1で取得
	}
	function Finalize_Std() // 
	{
		BMvTbl.VGuard_Time(0); // 0にする
		Battle_Std.SwitchNextMoveTable("Mv_VGuard_StandEnd", [2,"Mv_VGuard_Crouch"]); //デフォ,[code,mv]...	
	}
	function LastUpdate_Std() // 
	{
		BMvTbl.VGuard_Time(0); // 0にする
	}
}

Std_MoveTable.Mv_VGuard_Crouch <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする

		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.DataPattern!=def_PAT_VGuard_C )
		{	
			//print("\n違うパターンなので設定");
			BMvTbl.SetPattern(def_PAT_VGuard_C); // 任意
			BMvTbl.JumpFrameID(100); // 行動可能のガードポーズへ		
			BMvTbl.VGuard_Time(def_PAT_VGuard_Time);
		}
		else //同じパターンでもFrameIDをチェック
		{
			if( (s.FrameID==120 || s.FrameID==130 ) ) //抜けてた
			{
				BMvTbl.JumpFrameID(100); // 行動可能のガードポーズへ
			}
		}
		Battle_Std.InitCharaVector(); //InitCharaVectorでXMAX初期化するようにしたのでこっちでＯＫ
		//Battle_Std.InitVector(); //ダッシュの慣性が乗ってしまうのでこうする
	}
	function Update_Std() // 
	{
		local type = BMvTbl.VGuard_CheckKeep();
		if( type != 0 )
		{
			// 継続
			BMvTbl.VGuard_Time(def_PAT_VGuard_Time); // もどす
			if( type == 1 )  BMvTbl.SetFinalize(1); // 立ちへ
			else if( type == 2 ); // そのまま継続
			else
			{
				// 例外、怖いので終わり
				BMvTbl.SetFinalize(0);
			}
		}
		else //継続しない
		{
			if( BMvTbl.VGuard_Time(-1) == 0 ) // 時間を取得し0だと終了
			{
				BMvTbl.VGuard_Time(0); // 0にする
				BMvTbl.SetFinalize(0);
			}
		}
		// 
		//print("\nKeep_Crouch" + BMvTbl.VGuard_Time(-1)+" type:"+type );
	}
	function Finalize_Std() // 
	{
		BMvTbl.VGuard_Time(0); // 0にする
		Battle_Std.SwitchNextMoveTable("Mv_VGuard_CrouchEnd", [1,"Mv_VGuard_Stand"]); //デフォ,[code,mv]...	
	}
	function LastUpdate_Std() // 
	{
		BMvTbl.VGuard_Time(0); // 0にする
	}
}


// 
Std_MoveTable.Mv_VGuard_StandEnd <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		Battle_Std.JumpFrameIDEX(120, def_PAT_VGuard_S, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.Mv_VGuard_CrouchEnd <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		Battle_Std.JumpFrameIDEX(120, def_PAT_VGuard_C, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}


if( Def_Dbg_GuardCancelAttack ) { //Def_Dbg_GuardCancelAttack
//ガードキャンセル　ガードスラスト
Std_MoveTable.Mv_GuardCancelAttack <-
{
	function Init_Std()
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern( def_PAT_GuardCancelAtk ); // パターン変更
		Battle_Std.InitCharaVector();
		//フラッシュとかゲージ消費とか
		
		//GuardCanselエフェクトよび
		//GuardCansel
		Battle_Std.CreateObjectEX({ x=0, y=-200, flags=_Position_ToolShift,
		datatype=1, pat="GuardCansel", angle="rand",
		objectflags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround
		});
		
		BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } ); //ＳＰゲージ予約分を消費
		BMvEff.SpGauge_SetLimitCombo( { val=25, time=180 } ); //ゲージ増加制限
		Battle_Std.TypeSE_Play({ type="ガーキャン" }); //発動ボイス
		
		//アナウンス表示
		BMvEff.AttackInfoString_Set({ word=def_AISW_GuardCancel,} );
		
		BMvTbl.SetPrio( _CharaPrio_Near ); // プライオリティ手前に
		
		//発動時にGRDを消費
		local stock = BMvEff.GRD_CheckStock( { val=-1 } );
		BMvEff.GRD_UseStock( { val=stock } ); // 全部消費
		BMvTbl.SetLP(9,stock); // 発動時のストックを記憶
		
		/*
		{
			// GRDの数に応じて割れる時間を短くする
			// 12個で0、6個で半分のようなイメージ
			//   0   6  12
			// 1.0 0.5 0.0
			local stockPar = (12-stock)*100/12;
			_dp("\n stockPar:"+stockPar+" stock:"+stock);
			
			// GRDブレイクする
			// テクニックとして、CS→すぐにGTでブレイクを回避できるんだよなぁ
			
			if( BMvTbl.GetPP(def_PP_GuardCancelStatus) == 1 ) // 200% or VO
			{
				local useframe = def_GRDBF_GuardCancel_Max * stockPar / 100;
				_dp("\n 200% GT:"+useframe);
				BMvEff.GRD_SetBreak( 0, useframe, useframe );
				// BMvTbl.Achievement_Unlock(7); // 【トロフィー】パリーン！
			}
			else // 100%
			{
				local useframe = def_GRDBF_GuardCancel * stockPar / 100;
				_dp("\n 100% GT:"+useframe);
				BMvEff.GRD_SetBreak( 0, useframe, useframe );
				// BMvTbl.Achievement_Unlock(7); // 【トロフィー】パリーン！
			}
		}
		*/
		BMvTbl.SetPP(def_PP_GuardCancelStatus,0); // 一応初期化
		
		// BMvEff.SetSpGauge( { value=-500000 } ); //ＳＰゲージ全消費 ※200% VOだと全部減るわけではないようだ？
		// ↑が無くても予約分は消費される。ここで消費して０にしないと、GC→VOで回復の流れになる
		// まぁいいかな…ってことでestからは減らさないようにする

		local stop_frame = 6; // 自分にだけかかるヒットストップ
		local muteki_frame = 15+stop_frame; // 無敵時間　相打ちが多いので+1Fした
		BMvEff.SetPlayerTimer( { muteki_dage=muteki_frame, muteki_dageX=muteki_frame, muteki_nage=muteki_frame, muteki_nageX=muteki_frame } );
		
		// ガーキャン演出強化
		BMvEff.SetStopTime( { time=7, stopme=0 } );
		BMvEff.SetCamera_Quake( { time=14, type=0, } );
		
		// 自分にヒットストップをかけて発生を遅くする
		local hitst = BMvTbl.MvHitStatus();
		hitst.Count = stop_frame;
		BMvTbl.SetMvHitStatus( hitst );				
		
		// ↑ 2Aの硬直差-3Fまではガードされる発生
		
		//念のため関係
		BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_None, special=_CancelFlag_None, time=254, flag=_ClearFlag_ChangeMv } );
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } );
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_ChainShift, time=0, flag=_ClearFlag_ChangeMv } );
		
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
	}
	function HitInterrupt_Std()
	{
		if( Battle_Std.CheckDamageTiming() )
		{
			local muteki_frame = 254; // 無敵時間
			BMvEff.SetPlayerTimer( { muteki_dage=muteki_frame, muteki_dageX=muteki_frame, muteki_nage=muteki_frame, muteki_nageX=muteki_frame } );
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
	function LastUpdate_Std()
	{
		// 無敵消去
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );
	}
}

Std_MoveTable.Mv_GuardCancelAttackEX <-
{
	function Init_Std()
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern( def_PAT_GuardCancelAtk ); // パターン変更
		Battle_Std.InitCharaVector();
		//フラッシュとかゲージ消費とか
		
		BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } ); //ＳＰゲージ予約分を消費
		
		//GuardCanselエフェクトよび
		//GuardCansel
		Battle_Std.CreateObjectEX({ x=0, y=-200, flags=_Position_ToolShift,
		datatype=1, pat="GuardCansel", angle="rand",
		objectflags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround
		});
		
		BMvEff.SpGauge_SetLimitCombo( { val=25, time=180 } ); //ゲージ増加制限
		Battle_Std.TypeSE_Play({ type="ガーキャン" }); //発動ボイス
		
		//アナウンス表示
		BMvEff.AttackInfoString_Set({ word=def_AISW_GuardCancel,} );
		
		BMvTbl.SetPrio( _CharaPrio_Near ); // プライオリティ手前に
		
		//発動時にGRDを消費
		local stock = BMvEff.GRD_CheckStock( { val=-1 } );
		BMvEff.GRD_UseStock( { val=stock } ); // 全部消費
		BMvTbl.SetLP(9,stock); // 発動時のストックを記憶
		
		BMvEff.GRD_ClearVorpal( 0 ); // ヴォーパルを解除する

		local stop_frame = 3; // 自分にだけかかるヒットストップ
		local muteki_frame = 15+stop_frame; // 無敵時間
		BMvEff.SetPlayerTimer( { muteki_dage=muteki_frame, muteki_dageX=muteki_frame, muteki_nage=muteki_frame, muteki_nageX=muteki_frame } );
		
		// ガーキャン演出強化
		BMvEff.SetStopTime( { time=7, stopme=0 } );
		BMvEff.SetCamera_Quake( { time=14, type=0, } );
		
		// 自分にヒットストップをかけて発生を遅くする
		local hitst = BMvTbl.MvHitStatus();
		hitst.Count = stop_frame;
		BMvTbl.SetMvHitStatus( hitst );				
		
		// ↑ 2Aの硬直差+0Fまではガードされる発生
		
		//念のため関係
		BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_None, special=_CancelFlag_None, time=254, flag=_ClearFlag_ChangeMv } );
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } );
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_ChainShift, time=0, flag=_ClearFlag_ChangeMv } );
		
		// BMvTbl.Achievement_Unlock(6); // 【トロフィー】安全な切り返し
		
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
	}
	function HitInterrupt_Std()
	{
		if( Battle_Std.CheckDamageTiming() )
		{
			local muteki_frame = 254; // 無敵時間
			BMvEff.SetPlayerTimer( { muteki_dage=muteki_frame, muteki_dageX=muteki_frame, muteki_nage=muteki_frame, muteki_nageX=muteki_frame } );
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
	function LastUpdate_Std()
	{
		// 無敵消去
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );
	}
}

} //Def_Dbg_GuardCancelAttack





















// ----------------------------------------------------------------------------
// コンセントレーション
// ----------------------------------------------------------------------------
//コンセントレーションエフェクト
Std_MoveTable.Mv_ConvertChargeEff <-
{
	function Init_Std()
	{
		BSound.SE_Play( { num=239 } ); //コンセントレーション効果音再生でだし
		BMvTbl.SetLP(0,0); //カウンタ初期化
	}
	function FrameUpdate_Std()
	{
		local id = Battle_Std.GetPlayerFrameID();
		local mv = Battle_Std.GetPlayerMvName();
		
		local mvcnt = BMvTbl.GetLP(0); //カウンタ取得
		BMvTbl.AddLP(0,1); //1F進める
		
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( mvcnt%50==49 )
		{
			BSound.SE_Play( { num=238 } ); //コンセントレーションループ＋フェード効果音再生		
		}
		
		if( id==256 && mv=="Mv_ConvertCharge_Modori" )
		{
			BMvTbl.JumpFrameID(256);
			BMvEff.EraseObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_EraseParentDamage } );	
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();	
	}
	function LastUpdate_Std()
	{
		BSound.SE_Stop( { type=_SeType_Normal, num=239, fadetime=10 } ); // コンセントＳＥフェードアウト
	}
}

//コンセントレーション
Std_MoveTable.Mv_ConvertCharge <- 	//コンバート
{
	function Init_Std() //
	{
		//共通処理
		BMvTbl.SetMuki(_Direction_Auto);
		
		BMvTbl.ClearHitStatus(); //ヒット情報のクリア（空振りキャンセル可能フラグをたててるため必要）

		BMvTbl.SetPattern(def_PAT_Convert);
		local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		if( rc.sx != _Hantei_Error ) // 存在するか
		{
			local eff = BMvEff.CreateObject( { x=rc.sx, y=0, mvname="Mv_ConvertChargeEff", datatype=1, start_pat=84, flags=_Position_ToolShift } );
			if( eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_EraseParentDamage } );	
				BMvTbl.SetPosition( { y=0 } );
				eff.pop();
			}
		}
		Battle_Std.InitVector(); // ベクトル初期化

		Battle_Std.TypeSE_Play({ type="コンセントレーション" });
		
		//D連打でCS出せるように空振りCS可能に
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_ChainShift, time=60, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // DDでCSが出せるようにする
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
		
		BMvTbl.SetWallCount(0); // 無敵バグ対策に壁バウンド回数をリセットする
		
		BMvTbl.SetLP(0,0); //カウンタ初期化
		
		BMvTbl.SetLP(5,0); //前回のMvCount
		
		// ループの抜け先を予約
		local stopframe = BMvEff.GetFrameIDNum( 256 );
		if( stopframe != -1 ) // FrameIDがあるかどうか
		{
			BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Convert, frame=stopframe, rest=4 } );
		}
		
		// これは後半行動可能になるし出ないほうが自然
		// Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
	}
	function FrameUpdate_Std()
	{
		Battle_Std.CallLoopEndCache_FrameID( def_PAT_Convert, 256, 10 ); // キャッシュ予約Pat, 予約FrameID, 何F毎に呼ぶか
	
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		
		//キャラをちょっと青く光らせる
		if( s.MvCount%4==0 )
		{
			Battle_Std.SetCharaFlash_ConvertCharge();
		}
		
		// 1Fに１回の処理
		if( s.CallCount == 0 )
		{
			// GRD増加関係
			//チャージ中のGRD増加基本値
			local mGRDAddVal = def_GRD_Convert_Frame;
			local eGRDAddVal = def_GRD_Convert_Frame_Enemy;
			
			local okure_hosei = 0;
			if( Def_Sys_DelayedConvertChargeDemerit )
			{
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
				if( enemy.push() )
				{
					local emv = BMvTbl.GetMvName();
					local emvs = BMvTbl.GetMvStatus();

					enemy.pop();
					
					local p_cnt = s.MvCount;
					local e_cnt = emvs.MvCount;
					
					// 1P→2Pの処理順でややこしいので1F目は飛ばす
					// 2P側から見ると1Pは処理済みなので、1F分減らして計算する
					
					if( emv == "Mv_ConvertCharge" && p_cnt >= 1 && e_cnt >= 1 )
					{
						
						local pside = BMvTbl.GetPlayerSide();
						
						if( pside == 1 )
						{
							e_cnt--; // 1F減らす
						}
						
						local cnt_sa = p_cnt - e_cnt; // 勝ってるか
						
						// 少しだけマージン入れる ある程度F以上遅れてたら勝てなくする
						// あまりマージンがあると、見てからDで引き分けに持って行きやすくなるが、それも面白いかもなのでよくある26Fにする
						if( cnt_sa <= -26 )
						{
							// _dpn("遅れ補正あり");
							okure_hosei = 1;
						}
						// _dpn(format("%dP 同じ構え:%3d - %3d = %d",(pside+1), p_cnt, e_cnt, cnt_sa) );
					}
				}
			}
			
			local enemyBoundAirUkemiOk = 0; // 敵が空中受身可能かどうか（やられかどうかは別に調べる必要あり）
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				local ebs = BtlMvStd.GetBoundStatus();
				enemy.pop();
				
				enemyBoundAirUkemiOk = ebs.AirUkemi;
			}
			local enemyIsDamage = Battle_Std.CheckEnemyisDamage();
			
			local useDamageGRD = (enemyIsDamage && !enemyBoundAirUkemiOk)? 1 : 0; // ダメージ時のGRD増加を参照するかどうか

			local comboConcentrationFrame = 0;
			if( Def_Sys_Concentration_EnemyDamageCheck && useDamageGRD )
			{
				comboConcentrationFrame = BMvTbl.AddPP(def_PP_ComboConcentrationCounter,1); // 発動した時間を記憶していく
			}
			
			if( BMvEff.Liberate_Get()!=_SpGaugeMode_Normal ) //ヴェールオフ中
			{
				mGRDAddVal = def_GRD_Convert_Frame_VeilOff;
				eGRDAddVal = def_GRD_Convert_Frame_VeilOff_Enemy;
			}
			if( BMvEff.GRD_GetBreak( 1 ) != 0 ) //相手がブレイク中
			{
				// _dpn("相手がブレイク中");
				mGRDAddVal = def_GRD_Convert_Frame_EnemyisBreak;
				eGRDAddVal = def_GRD_Convert_Frame_EnemyisBreak_Enemy;
			}
			else if( BCMDTbl.GetComboGauge()==0 ) //自分のEXSが空
			{
				mGRDAddVal = def_GRD_Convert_Frame_NoEXS;
				eGRDAddVal = def_GRD_Convert_Frame_NoEXS_Enemy;		
			}
			else if( enemyIsDamage ) // 旧仕様
			{
				mGRDAddVal = def_GRD_Convert_Frame_EnemyisDamage;
				eGRDAddVal = def_GRD_Convert_Frame_EnemyisDamage_Enemy;
			}

			// ダメージ時は優先度を最大でチェックして、今のやつと比較して悪い方を選ぶ
			if( useDamageGRD && Def_Sys_Concentration_EnemyDamageCheck )  //相手がやられ＆受け身不可能なとき
			{
				local mGRDAddVal_Damage = mGRDAddVal;
				local eGRDAddVal_Damage = eGRDAddVal;

				// _dpn("comboConcentrationFrame:"+comboConcentrationFrame);
				
				// コンボ中の総コンセ時間が一定値を越えたらどんどん効果が減っていく
				local limitFrame = 25;
				local maxFrame = 70;
				if( comboConcentrationFrame >= limitFrame )
				{
					if( comboConcentrationFrame > maxFrame ) comboConcentrationFrame = maxFrame;
					comboConcentrationFrame = comboConcentrationFrame - limitFrame; // 0〜60(90-60)
					local conceFramePar = comboConcentrationFrame * 100 / (maxFrame-limitFrame); // 長いと数値が増える
					// _dpn("conceFramePar:"+conceFramePar);

					mGRDAddVal_Damage = def_GRD_Convert_Frame_EnemyisDamage - (def_GRD_Convert_Frame_EnemyisDamage*80/100)*conceFramePar/100;
					eGRDAddVal_Damage = def_GRD_Convert_Frame_EnemyisDamage_Enemy - (def_GRD_Convert_Frame_EnemyisDamage_Enemy*80/100)*conceFramePar/100;
				}
				else
				{
					mGRDAddVal_Damage = def_GRD_Convert_Frame_EnemyisDamage;
					eGRDAddVal_Damage = def_GRD_Convert_Frame_EnemyisDamage_Enemy;
				}
				
				// 悪い方を選ぶ
				// _dpn(" mGRDAddVal Damage:"+mGRDAddVal_Damage+" "+mGRDAddVal);
				// _dpn(" mGRDAddVal Damage:"+eGRDAddVal_Damage+" "+eGRDAddVal);
				
				if( mGRDAddVal > mGRDAddVal_Damage ) mGRDAddVal = mGRDAddVal_Damage;
				if( eGRDAddVal < eGRDAddVal_Damage ) eGRDAddVal = eGRDAddVal_Damage; // こっちはマイナスなので符号逆
			}
			
			if( s.MvCount<def_FL_Shield_SPCostStartFrame )
			{
				//でかかりはたまりにくく
				mGRDAddVal = mGRDAddVal * 25 / 100; //整数化:0.25;
				eGRDAddVal = eGRDAddVal * 45 / 100; //整数化:0.45;
			}
			else
			{
				// でかかり以降で差が出て少し緊張感を持たせる
				if( Def_Sys_DelayedConvertChargeDemerit && okure_hosei )
				{
					//okure_hosei
					// mGRDAddVal = mGRDAddVal * 70 / 100;
					eGRDAddVal = eGRDAddVal * 70 / 100; // 相手を減らすパワーだけ減る
				}
			}
			
			// 距離が離れてるときは効果が下がる
			if( Def_Sys_Concentration_CheckEnemyKyori )
			{
				local enemy_kyori = abs( Battle_Std.GetEnemyDistance()/128 );

				local apart_kyori = enemy_kyori = enemy_kyori - 640;
				if( apart_kyori <   0 ) apart_kyori =   0;
				if( apart_kyori > 640 ) apart_kyori = 640;
				
				local apart_par = apart_kyori * 100 / 640; // 0〜100 計算用のどれだけ離れているか
				// 最低で30%まで落ちる
				
				if( Def_Sys_Concentration_CheckEnemyKyoriWithGRDStock )
				{
					local grd_stock = BMvEff.GRD_CheckStock( { val=-1 } ); // 今何個ある？
					// if( grd_stock>11 ) grd_stock = 11; //最大
					if( grd_stock>6 ) grd_stock = 6; //最大6個判定で考える
					
					// GRD個数による影響度（GRDが少ないときは距離補整の影響を受けにくい）
					local stock_par_ar =[
					20, // 0
					40, // 1
					60, // 2
					80, // 3
					100, // 4
					100, // 5
					100, // 6
					];
					local stock_par = stock_par_ar [ grd_stock%stock_par_ar.len() ];
					// _dpn("grd_stock:"+grd_stock+" stock_par:"+stock_par+" apart_par:"+apart_par);
					apart_par = apart_par * stock_par / 100;
					// _dp(" -> "+apart_par);
				}
				
				local calc_par = 100 - 70 * apart_par / 100
				// _dpn("GRD1:"+mGRDAddVal+", "+eGRDAddVal);
				mGRDAddVal = mGRDAddVal * calc_par / 100;
				eGRDAddVal = eGRDAddVal * calc_par / 100;
				// _dpn("GRD2:"+mGRDAddVal+", "+eGRDAddVal);

				// _dpn("calc_par:"+calc_par);
			}
			
			// _dpn("計算後:"+mGRDAddVal+" / "+eGRDAddVal+" time_bonus_val:"+time_bonus_val );
			// _dpn("mGRDAddVal:"+mGRDAddVal+" eGRDAddVal:"+eGRDAddVal);
			
			Battle_Std.GRD_AddValue({ val=Battle_Std.GetGRD_AddValue(mGRDAddVal), pressure=0 }); //自分の増加
			Battle_Std.GRD_AddValue({ val=Battle_Std.GetGRD_AddValue(eGRDAddVal), pressure=0, target=1 }); //相手の減少

			if( Def_Sys_Concentration_SubExs )
			{
				Battle_Std.SetSpGauge_ConvertChargeFU( {value=def_SP_ConvertCharge_Frame,} ); //モーション中のEXS消費
			}
			
			//それとは別に
			//自分のエリアまで侵食しているGRDは強く減らす
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
			if( enemy.push() )
			{
				local enemyGRD_count = BMvEff.GRD_CheckStock( { val=-1 } );
				if( enemyGRD_count>=6 ) 
				{
					BMvEff.GRD_AddValue( { val=-600, } ); //固定値で減る
				}
				
				enemy.pop();
			}
			
			if( Def_Sys_Concentration_AddTS )
			{
				// コンセ中はTSの速度を変更してみる
				// VP時だけ早くするとかすると曖昧なので、シンプルにちょっと早くする効果にした
				// local speed = BMvEff.GRD_TS_SetPlusValue( { val=120 } ); // 2倍速度
				BMvEff.GRD_TS_AddValue( { val=Def_Sys_Concentration_AddTS } );
			}
			
			
			// パーティクル関係
			// つぶを出す
			if( s.MvCount%3==0 ) //気持ち軽くする
			{
				local muki = BMvEff.Random_Limit(2); //BMvTbl.SetMuki( muki )
				local iRnd = BMvEff.Random_Limit(100); //0〜99 基本ランダム値
				local posx = iRnd;
				local vecy = (-2300 + (iRnd*15))*150/100;
				local vecx = (posx*3)*150/100;
				local frame = 45;
				if( muki==1 )
				{
					posx*=-1;
				}
				local eff = BMvEff.CreateObject( { x=posx, y=-25, mvname="", datatype=1, start_pat=27, flags=_Position_ToolShift } );
				if( eff.push() )
				{
					BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround } );	
					if( muki==1 ) BMvTbl.SetMuki( _Direction_Reverse );
					BMvTbl.SetVector( { x=vecx, y=vecy, addx=0, addy=-vecy/frame, flags=_Vector_Div } );
					BMvTbl.JumpFrameID(20);
					
					eff.pop();
				}
			}
		}
		
		// 1Fに2回以上やってもいい重要な処理
		switch( s.FrameID )
		{
		case 100: //ループ開始
			break;
		case 200: //ループ分岐
			BMvTbl.JumpFrameID(100);
			break;
		}
		
		if( s.MvCount>def_FL_ConvertMinTime && !BMvTbl.CheckCommandString( [ "@H,0D@" ] ) )
		{
			BMvTbl.SetFinalize(256);
		}
		
		// Ver1.03での無敵バグ防止用
		// 今はもう不要だが、無限に続けられるパターンはそれなりに危険なので一応残しておく
		if( s.MvCount>def_FL_ConvertMaxTime )
		{
			BMvTbl.SetFinalize(256);		
		}
		
		//200225:コンセで2Pが必ず勝ってしまうの対応
		BMvEff.GRD_SetSpFlag(1);
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_ConvertCharge_Modori"]); //デフォ,[code,mv]...	
	}
	function LastUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount>4 )
		{
		}
		else
		{
			Battle_Std.PlayerSE_StopLastPlaySound( 0 ); //直前に再生したＳＥを停止（コンセントレーション）
		}
	}
}

//コンセントレーションの戻り
//一応スクリプトでも行動可能にしておこう
Std_MoveTable.Mv_ConvertCharge_Modori <-
{
	function Init_Std() // 
	{
		Battle_Std.JumpFrameIDEX(256, def_PAT_Convert, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
		BMvTbl.SetMoveableFlag( { move=1, time=64, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); //行動可能に変更
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

// ----------------------------------------------------------------------------
// やられ関係
// ----------------------------------------------------------------------------
// ○特殊なもの
// Mv_Bound_0023 投げ抜け押し返し攻撃
// Mv_Bound_0024 投げ抜けられガードポーズ

Std_MoveTable.Mv_Bound <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit();		
	}
	function Update_Std()
	{
		Battle_Std.BoundUpdate();
	}
	function FrameUpdate_Std()
	{
		local useval = (BMvEff.GRD_GetJudgeResult()>0)? ( (BMvEff.GRD_CheckStock( { val=-1 } )>=6)? def_GRD_BoundFU_GRD6Vorpal : def_GRD_BoundFU_Vorpal) : def_GRD_BoundFU;
		Battle_Std.GRD_AddValue({ val=useval, pressure=0, boundplus=1 });	
	}
	function Finalize_Std() // 
	{
		//抜け先が無いかも？
		//状態の移行だけ行う
		BtlMvStd.SetBoundFinalize();
		// print("\nMv_Bound Finalize()");
	}
	function LastUpdate_Std() // 
	{
		if( Def_Rule_GroundBoundSlideKeep )
		{
			//地上状態では慣性を残す
			if( BMvTbl.CheckPosState( _PosState_Ground  ) )
			{
				local vec = BMvTbl.GetVector( { flags=_Vector_Bound } );
				BMvTbl.SetVector( { x=vec.x, addx=-vec.x/10, flags=_Vector_DivKeep } );
				// print("\n vec.x:"+vec.x);
			}
		}
		BtlMvStd.ClearBound(); // 状態解除(ベクトルが無くなる)
		// print("\nMv_Bound LastUpdate()");		
	}
}

//捕まれ中はMv_BoundではなくMv_Bound_Captureになります(毎フレームInitする)
//Mv_Bound_Captureは名前だけでBoundではないため、Bound関係で何かしようとすると危ない
//Mv_Bound_Captureという状態を取得できるだけと考えたほうがいい
//エラーがうざいので一応定義するけど何もしない
Std_MoveTable.Mv_Bound_Capture <- 
{
	function Init_Std() // 
	{
		if( BMvTbl.ChangeMv_GetMvName() != "Mv_Bound_Capture" )
		{
			// print("\nMv_Bound_Capture Init()");
			// ベクトル初期化だけ行う
			// つかみ成立→前MvのLastUpdateでベクトル設定→このMvで動きっぱなしになる
			Battle_Std.InitVector();
			
			// やられボイス再生処理
			local sound_st = BMvTbl.GetPP(def_PP_SoundStatus);
			if( sound_st&def_PP_SS_NoBoundVoice )
			{
			}
			else if( sound_st&def_PP_SS_NoBoundVoiceOnce )
			{
			}
			else
			{
				Battle_Std.PlayerSE_StopLastPlaySound( 1 ); //直前に再生した音声を停止
			}
			BMvEff.CutInProc_Erase(); //カットインがあったら消去する
			
			local anno_flags = BMvTbl.GetPP(def_PP_ImpactAnnounce);
			BMvTbl.SetPP(def_PP_ImpactAnnounce,0);//すぐ初期化
			Battle_Std.DrawPunishAnnounce( anno_flags ); //やられアナウンス処理
		}
	}
	function Finalize_Std() // 
	{
		// Finalizeすると無限ループして落ちるし、そもそも何もしないでおく
		// BMvTbl.SetNextMoveTable( "Mv_Bound_Capture" );
	}
}

// ----------------------------------------------------------------------------
// Guard
// ----------------------------------------------------------------------------
Std_MoveTable.Mv_Guard <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		Battle_Std.InitVector(); // ベクトル初期化
		BtlMvStd.SetGuardStatus();
		//print("\nMv_Bound Init()\n");
		
		// ガードキャンセル用処理
		BMvTbl.SetLP(9,0); //ガードしてから何フレーム経過したか

		BMvTbl.SetLP(5,0); // ガードシールドを次のフレームで発動する
		BMvTbl.SetLP(6,0); // ガードシールド状態になって何フレームたったか。ガード開始時でのみリセット。2回目の発動があった場合継続。
		BMvTbl.SetLP(7,0); // ガードシールド発動回数
		//BMvTbl.SetPP(def_PP_ShieldStatus,0); //シールドステータスはここで初期化
		BMvTbl.SetLP(8,0); // ガードフロートで無敵時間のついたガードだよ
		
		//ガードのボイスを選んで再生
		local bs = BtlMvStd.GetBoundStatus();
		if( bs.isBound )
		{
			//_dm("pow:"+bs.Power+" def_BS_Pow_LV2"+def_BS_Pow_LV2);
			local bs_power = bs.Power;
			
			if( bs_power&def_BS_Pow_LV1 )
			{
				// _dpn("A");
				Battle_Std.TypeSE_Play({ type="ガード弱" });
			}
			else if( bs_power&def_BS_Pow_LV0 )
			{
				// 声無し
			}
			else if( bs_power&def_BS_Pow_LV3 )
			{
				// _dpn("C");
				Battle_Std.TypeSE_Play({ type="ガード強" });
			}
			else
			{
				//def_BS_Pow_LV2 == 0 なのでフラグのチェックは絶対に0になるからelseに置く
				// _dpn("B");
				Battle_Std.TypeSE_Play({ type="ガード中" });
			}
			
			if( bs_power&def_BS_Pow_GuardFloat ) 
			{
				// ガードフロートなので無敵にします
				_dp("\n ガードフロートなので無敵をセット");
				BMvEff.SetPlayerTimer( { muteki_dage=64, muteki_dageX=64 } ); // 怖いので時間は短め
				BMvTbl.SetLP(8,1); // 無敵をセットしたことを記憶
			}
		}

		//シールド成功時の処理
		if( BMvEff.GuardSP_Success() )
		{
			// _dm("シールド成功（旧ＥＸ）");
			
			// バリアガード（シールド）が成功したときの処理
			Battle_Std.TypeSE_Play({ type="シールド成功" });	
			
			//シールドに成功
			BMvEff.AttackInfoString_Set({ word=def_AISW_SPGuard,} );									
			
			Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_ShiledSuccess ); // シールド成功
			
			
			Battle_Std.SetShieldSuccessGRDEffect(0); // シールド成功によるGRDとTSの処理
			
			//距離を離れやすくする
			local vec = BMvTbl.GetVector( { flags=_Vector_Bound }); //増やすため今のガードベクトル取得
			if( vec.x<=0 ) //離れるベクトルのみ増やす
			{
				local isGround = BCMDTbl.CheckPosState( _PosState_Ground ); //def_VEC_GuardSP_Xvec_Air
				local useXvec = (isGround)? def_VEC_GuardSP_Xvec : def_VEC_GuardSP_Xvec_Air;//地上と空中で別の係数を使う
				local useXmax = (isGround)? def_VEC_GuardSP_Xmax : def_VEC_GuardSP_Xmax_Air;//地上と空中で別

				//係数をかけて最大値を制限
				//_dp("\n nowvecx:"+vec.x);
				vec.x = vec.x * useXvec/100;
				if( vec.x<useXmax) vec.x = useXmax;
				vec.addx = vec.addx * useXvec/100;
			
				BMvTbl.SetVector( { x=vec.x, addx=vec.addx, flags=_Vector_Bound } );
			}
			
			//シールドによる時間停止（ヒットストップ）
			if( def_FL_ShieldStopTime )
			{
				BMvEff.SetStopTime( { time=def_FL_ShieldStopTime, stopme=2 } );
			}
			
			local enemy_atk_is_airatk = 0;
			local enemy_atk_is_shield_steady = 0;
			
			//殴られた相手の行動がジャンプ攻撃だったらキャンセル不可とシールドされたフラグを与える　＋　※できない：空中ガード可能にする（多段シールドめんどくさい）
			local enemy_LastDmgChr = BMvCore.GetLastDamageCharaData( 0 ); // 殴られた敵情報を得る
			if( enemy_LastDmgChr.push() )
			{
				Battle_Std.MoveCode.AddFlag( def_MC_Shielded ); // シールドを取られたMvとする
				
				local grd_add = Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_ShieldWeakGRDAdd );//被シールドでGRDが多く増える攻撃
				local grd_add_comp = Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_CompletedShieldWeakGRDAdd );//被シールドでGRDが多く増える攻撃を処理済みかどうか
				
				Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_CompletedShieldWeakGRDAdd ); // 処理済みということにする
				
				local grd_add_timing = (!grd_add_comp && grd_add); // このタイミングで専用GRD増加処理を入れる
				
				Battle_Std.SetShieldSuccessCancelEffect(); // シールド成功によるキャンセル制限処理

				local isJumpAtk = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_AtkJump );
				if( isJumpAtk ) //ジャンプ攻撃なら
				{
					enemy_atk_is_airatk = 1;
				}
				
				if( Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_ShieldSteady ) )
				{
					enemy_atk_is_shield_steady = 1;
				}
				
				enemy_LastDmgChr.pop();
				
				if( grd_add_timing )
				{
					//GRD増加？
					_dpn("シールドによるGRD増加:"+def_GRD_Shield_Success_WeakBonus);
					Battle_Std.GRD_AddValue( { val=def_GRD_Shield_Success_WeakBonus, boundplus=1 } );
					
					local enemy_LastDmgPlayer = BMvCore.GetLastDamageCharaData( 1 ); // 殴られた敵情報を得る
					if( enemy_LastDmgPlayer.push() )
					{
						BMvEff.GRD_AddValue( { val=def_GRD_Shield_Success_WeakBonus_Enemy, pressure=0 } ); //val:10000で１ストック
						
						enemy_LastDmgPlayer.pop();
					}
				}
			}
			
			// シールド時にベクトルを減らす
			if( Def_Sys_ShieldSuccess_MinusVecTime )
			{
				if( BCMDTbl.CheckPosState(_PosState_Air) )
				{
					BMvEff.SetBoundSt( { addtime = -6 } );
				}
				else
				{
					if( Def_Sys_AirAtkShieldSubVecTime && enemy_atk_is_airatk )
					{
						local bound_time = BMvEff.SetBoundSt( { addtime = 0 } ); // 現在値
						if( bound_time >= 17 ) bound_time = 17; // 強ガードぐらいを限界値にする
						local set_bound_time = bound_time - 6;
						if( set_bound_time <= 8 ) set_bound_time = 8; // 弱ガード-3Fよりは減らない
						_dpn("シールドガード硬直:"+set_bound_time);
						BMvEff.SetBoundSt( { settime = set_bound_time } );
						
					}
					else if( enemy_atk_is_shield_steady )
					{
						BMvEff.SetBoundSt( { addtime = -2 } ); // 少しだけ減らす
					}
					else
					{
						BMvEff.SetBoundSt( { addtime = -3 } );
					}
				}
			}			
			
			if( Def_Sys_Shield_EraseEnemyUniqCancel )
			{
				local enemy_LastDmgMainChr = BMvCore.GetLastDamageCharaData( 1 ); // 殴られた敵の本体を得る
				
				if( enemy_LastDmgMainChr.push() )
				{
					if( Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_ActiveEraseEnemyUniqCancel ) )
					{
						if( Battle_Std.MoveCode.CheckFlag( def_MC_EnableCansel_SkilltoAtk ) )
						{
							Battle_Std.MoveCode.DelFlag( def_MC_EnableCansel_SkilltoAtk );
							_dpn("[シールド効果] 必殺技＞通常技 を不可に変更");
						}
						
						if( Battle_Std.MoveCode.CheckFlag( def_MC_EnableCansel_SkilltoSkill ) )
						{
							Battle_Std.MoveCode.DelFlag( def_MC_EnableCansel_SkilltoSkill );
							_dpn("[シールド効果] 必殺技＞必殺技 を不可に変更");
						}
					}

					enemy_LastDmgMainChr.pop();
				}
				
			}
			
			
			if( Def_Sys_HajiShield_EnemyNockBack )
			{
				// 画面端背負ってたら　＆　端へのベクトルが入っていたら
				if( Battle_Std.GetHaimenStageHajiDistance() <= 0 && vec.x < 0 )
				{
					if( enemy_LastDmgChr.push() )
					{
						local nosend_vector = Battle_Std.MoveCode.CheckFlag(def_MC_NoSend_ScriptKnockBackVecor);
						
						enemy_LastDmgChr.pop();
						
						if( nosend_vector==0 )
						{
							local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
							if( enemy.push() )
							{
								local divvec = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
								if( divvec.x == 0 ) // 何もベクトルが設定されて無い時だけにする
								{
									local nockbackvec = vec.x * 200 / 100;
									if( nockbackvec < -4000 ) nockbackvec = -4000; // 上限きめとく
									BMvTbl.SetVector( { x=nockbackvec, addx=-nockbackvec/6, flags=_Vector_DivKeep } );
									// _dp("\n nockbackvec:"+nockbackvec);
								}
								enemy.pop();
							}
						}
					}
				}
			}
		}
		
		// パターンによってフラグをつけておく
		local mvs = BMvTbl.GetMvStatus();
		local nowpat = mvs.DataPattern;
		if( nowpat == def_PAT_GuardS ) Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_StatusStd );
		if( nowpat == def_PAT_GuardC ) Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_StatusCro );
		if( nowpat == def_PAT_GuardA ) Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_StatusAir );
		
		// なんかエラーが出やすいのでhint予約を入れた
		if( Def_Rule_GuardPat_HitStopAnime )
		{
			BMvCore.CallEntryBCCachePreTransfer( { pat=nowpat, frame=1, rest=2 } );
			BMvCore.CallEntryBCCachePreTransfer( { pat=nowpat, frame=2, rest=4 } );
			BMvCore.CallEntryBCCachePreTransfer( { pat=nowpat, frame=3, rest=6 } );
			BMvCore.CallEntryBCCachePreTransfer( { pat=nowpat, frame=4, rest=8 } );
			BMvCore.CallEntryBCCachePreTransfer( { pat=nowpat, frame=5, rest=10 } );
		}
	}
	function Update_Std() // 
	{
		// ガードキャンセル用処理
		local updateCnt = BMvTbl.AddLP(9,1); // ヒットストップも含めて何フレーム経過したか加算
		
		if( Def_Rule_GuardPat_HitStopAnime )
		{
			//ガード中ヒットストップ時もアニメさせる
			local mvs = BMvTbl.GetMvStatus();
			local bst = BtlMvStd.GetBoundStatus();
			local nowFra = BMvTbl.Frame_Proc( 0, _ValAdd );
			// _dp("\n updateCnt:"+updateCnt+" bst:"+bst.BoundTime );
			if( mvs.FrameID == 10 && bst.isBound && bst.BoundTime == 0 && ( nowFra >= 0 && nowFra < Def_Rule_GuardPat_HitStopAnime ) )
			{
				//ガードのモーション＆ヒットストップ中
				//6枚ループのガードポーズ、3F枚に絵を進める
				//0 0
				//1 0
				//2 0
				//3 1
				//4 1
				//5 1
				//6 2 ...
				local guardFra = (updateCnt/5)%Def_Rule_GuardPat_HitStopAnime;
				// _dpn(nowFra+" -> guardFra:"+guardFra );
				BMvTbl.Frame_Proc( guardFra, _ValSet );
			}
		}
		
		//地上状態では符号が反転しないようにする
		if( BMvTbl.CheckPosState( _PosState_Ground  ) )
		{
			//今プラスのベクトルで、次のフレームがマイナスベクトルか？
			local vec = BMvTbl.GetVector( { flags=_Vector_Bound });
			if( (( vec.x<0 ) && ( (vec.x + vec.addx)>=0 )) || (( vec.x>0 ) && ( (vec.x + vec.addx)<=0 )) )
			{
				BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_Bound } );
			}
		}

		// SP状態でのガードかどうかでGRDのフレーム毎増加値を変える
		// BMvEff.GuardSP_Success()の戻り値
		// 0 何もなし
		// 1 成功
		// -1 ブレイク技をガードした
		// ガード成立時に更新され、次のガード成立まで変化しません
		local noChange = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_GuardGRDChangeStop );
		if( !noChange )
		{
			if( BMvEff.GuardSP_Success() )
			{
				local useval = (BMvEff.GRD_GetJudgeResult()>0)? ( (BMvEff.GRD_CheckStock( { val=-1 } )>=6)? def_GRD_GuardSP_Frame_GRD6Vorpal : def_GRD_GuardSP_Frame_Vorpal) : def_GRD_GuardSP_Frame;
				Battle_Std.GRD_AddValue({ val=useval, pressure=0,boundplus=1 });
			}
			else
			{
				local useval = (BMvEff.GRD_GetJudgeResult()>0)? ( (BMvEff.GRD_CheckStock( { val=-1 } )>=6)? def_GRD_Guard_Frame_GRD6Vorpal : def_GRD_Guard_Frame_Vorpal) : def_GRD_Guard_Frame;
				Battle_Std.GRD_AddValue({ val=useval, pressure=0,boundplus=1 });
			}
		}


		//ジャストでシールドを成功すると、シールドした直後にガードシールドが出てしまう
		//ガードのMvに入った直後＆シールド成功中は検知しないようにする…と
		//はりっぱのあと出そうとしてもでないので、直前のMvがシールド1Fのときは出ないようにする
		//1回の入力で、シールド→ガードシールドとなるのがよくない
		// local t_mvs_cnt = BMvTbl.GetMvStatus().MvCountFrame;
		// local justSpGguard = 0;//(t_mvs_cnt == 0 && BMvEff.GuardSP_Success() );
		// _dp("\n チェック:"+t_mvs_cnt+", "+BMvEff.GuardSP_Success()+" ？:"+justSpGguard );
		local cmd_info0 = BCMDTbl.GetCmdInfoEx(0);
		local last_mvname = BMvTbl.ChangeMv_GetMvName();
		local isJustTiming = (cmd_info0.GetFrame() == 0 && (last_mvname=="Mv_Barrier_Std" || last_mvname=="Mv_Barrier_Cro" || last_mvname=="Mv_Barrier_Air") );
		// _dp("\n frame:"+cmd_info0.GetFrame()+" Mv:"+last_mvname+" -> "+isJustTiming );
		
		//普通のガードの時はガードシールドの入力チェック
		//ガードシールドのコマンドが後ろ+Dなので、投げコマンドと被っていて、暴発を防ぐために1F遅らせる
		if( BMvEff.GuardSP_Get() != 1 && !isJustTiming ) // ガードシールド状態でない、普通のガードのとき（ガードシールド発動するとsetの値）
		{
			local grd = BMvEff.GRD_GetBreak( 0 ); //GRDのブレイク状態を取得
			local notGRDBreak = !( grd==1 || grd==255 ); //ブレイクorオーバーブレイク以外かどうか
			
			//ガード中投げ抜けを入力した時にガードシールドが出ないようにする　その１
			if( BMvTbl.CheckCommandString( { command=[ "A+D" ], lastdelay=1, } ) )
			{
				BMvEff.GuardSP_Set( { val=0 } ); // バリアガード状態解除
				BMvTbl.SetLP(5,0); //ガードシールド入力フラグを消す				
			}
			else if( notGRDBreak ) //ガードシールドはGRDブレイク中は出せない
			{
				local guard_shield = BMvTbl.GetLP(5); //次のフレームでガードシールド発動するかどうかフラグ(おしっぱのフレーム)
				
				/*
				// ガードシールドのコマンドが変わったのでこの処理は不要
				// ちょっと突貫処理っぽいけど、まぁ大丈夫だべ
				if( BMvTbl.CheckCommandString( [ "214D" ] ) && BMvEff.GetPlayerMuteki( 0 ) == 10 && BMvEff.GetPlayerMuteki( 1 ) == 10 )
				{
					// _dp("\n ガードスラスト出したい！");
				}
				else
				*/
				if( BMvTbl.CheckCommandString( [ "4+D","7+D","1+D" ] ) || BMvTbl.TM_GetCancelShieldTiming() ) //Dを押したら次のフレーム用にフラグをたてる
				{
					BMvTbl.AddLP(5,1); //次のフレームで反応
					//自分が空中の時は空中投げ抜け無いので1F遅らせを無くそう（まぁあるキャラもいるけど、空ガの状況もないし）
					//これで密度の高いジャンプ攻撃も連続シールドできるよ
					if( BCMDTbl.CheckPosState( _PosState_Air ) )
					{
						guard_shield = BMvTbl.GetLP(5); //1F目からガードシールド反応させる
					}
				}
				else
				{
					BMvTbl.SetLP(5,0); //ダメならリセット
				}
				
				local guard_shield_canseled = (BMvTbl.GetLP(7) >= 1 && BMvTbl.GetLP(6) > 4); // ガードシールド発動回数1回以上＆発動時間も4F以上
				if( guard_shield >= 1 && !guard_shield_canseled ) // Dボタンを前のフレームで押していたらガードシールド発動＆ガードシールド発動キャンセルしてなかったら
				{
					//ガードシールド発動処理
					
					BMvEff.GuardSP_Set( { val=1 } ); // ガードシールド状態にセット
					BMvTbl.SetLP(5,0); // ガードシールド入力フラグを消す
					
					Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_GuardShiled ); // ガードシールド状態
					
					// カウンタはリセットしない。ガード状態になった時点でしかリセットされない。
					// BMvTbl.SetLP(6,0); // 何フレームガードシールド発動したかのカウンタリセット
					
					BMvTbl.AddLP(7,1); // ガードシールド発動回数を加算

					//ガードシールド発動直後に終了する場合もあるのでコストなどは Mv_GuadShieldEff で処理するように変更
					//特殊判定の座標にガードシールドエフェクトを表示
					local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 1 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
					if( rc.sx != _Hantei_Error ) // 存在するか
					{			
						BMvEff.CreateObject( { x=rc.sx, y=rc.sy, datatype=1, start_pat=74, mvname="Mv_GuadShieldEff", flags=_Position_ToolShift } );
					}
				}
			}
		}
		
		if( BMvEff.GuardSP_Get() == 1 ) //ガードシールド中の処理
		{
			local guard_shield_cnt = BMvTbl.AddLP(6,1); // ガードシールド状態のカウンター加算
			//ガード中投げ抜けを入力した時にガードシールドが出ないようにする　その２
			
			// print("\n guard_shield_cnt:"+ guard_shield_cnt);
		
			//A+Dの同時押しをD→Aとしてしまい、先にガードシールドが発動してしまった場合は、ここで投げコマンドかどうかチェックして解除
			if( guard_shield_cnt <=2 && BMvTbl.CheckCommandString( { command=[ "A+D" ], lastdelay=1, } ) )
			{
				BMvEff.GuardSP_Set( { val=0 } ); // バリアガード状態解除
				BMvTbl.SetLP(5,0); //ガードシールド入力フラグを消す
				BMvEff.SetCharaFlash( { color = 0xAAAAFF, type = 0, time = 0 } ); //ガードシールド入力での発光を消す
			}
		}
	}
	function FrameUpdate_Std() : (callLandEffect)
	{
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		
		//空中ガード中に着地したら立ちガードポーズに移行
		if( mvs.isLanding )
		{
			BMvTbl.SetPattern(def_PAT_GuardS);
			//Yベクトルだけ初期化（着地・念のため）
			BMvTbl.SetVector( { y=0, addy=0, flags=_Vector_Normal|_Vector_Div|_Vector_Bound|_Vector_Keep|_Vector_DivKeep } );
			//着地エフェクトを呼ぶ
			callLandEffect(); // 着地エフェクト
			
			// ガードフロートからの着地だったら打撃無敵を削除
			if( BMvTbl.GetLP(8) ==1 ) // 無敵をセットされていた
			{
				// 打撃無敵を削除
				BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0 } );
			}
		}
	}
	function Finalize_Std() // 
	{
		//状態の移行だけ行う
		BtlMvStd.SetGuardFinalize();
		//print("SetGuardFinalize()");
	}
	function LastUpdate_Std() // 
	{
		//ガードシールドを発動したが攻撃をとれなかった場合のみGRDコストを消費する
		//ガードシールドを入力してて　かつ　シールド成功フラグはないかどうかチェック
		if( BMvEff.GuardSP_Get()!=0 && BMvEff.GuardSP_Success()!=1 )
		{
			//_dm("ガードシールドコスト消費");
			
			//失敗によるコスト消費
			Battle_Std.UseGRDStock( def_GRD_GuardShieldCost, def_GRD_GuardShieldNotEnough_Enemy); // 消費GRD数, 相手増加GRD値(単位違注意)
			
			_dp("\n 失敗シールド！");
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ShieldFailed ); // 失敗シールドなの
		}
		
		if( Def_Rule_GroundGuardSlideKeep )
		{
			//地上状態では慣性を残す
			if( BMvTbl.CheckPosState( _PosState_Ground  ) )
			{
				local vec = BMvTbl.GetVector( { flags=_Vector_Bound } );
				BMvTbl.SetVector( { x=vec.x, addx=-vec.x/10, flags=_Vector_DivKeep } );
				// print("\n vec.x:"+vec.x);
			}
		}		
		
		// ガードフロートで浮いて、空中だったら空ガ不能技でハメられないように無敵時間をセットする
		if( BMvTbl.GetLP(8) ==1 && BMvTbl.CheckPosState( _PosState_Air ) ) // ガードフロートで無敵をセットされていた,空中だった
		{
			// 抜けるときに少し打撃無敵をつける（ハメ回避）
			BMvEff.SetPlayerTimer( { muteki_dage=def_FL_ModoriGuardFloatDagekiMuteki, muteki_dageX=def_FL_ModoriGuardFloatDagekiMuteki } );
		}
		
		BtlMvStd.ClearGuard(); // 状態解除
		Battle_Std.Reversal.SetTime(); //リバーサル受付＋判定オブジェクト生成
		//print("ClearGuard()");
		
	}
}

//ガードシールド発動エフェクト
//LPが1の間は成功チェックして、成功エフェクトもこっから呼ぶ
Std_MoveTable.Mv_GuadShieldEff <-
{
	function Init_Std() // 
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove } );
		
		BMvTbl.SetLP(0,0); //0: ガードシールドの成功をチェックする 1:もうチェックしない
		
		//呼び出し後、そのフレーム内に終了してしまうケースが有る
		if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) == 0 )
		{
			BMvTbl.SetFinalize(0);
		}
		else
		{
			//ガードシールド発動が確定した
			//ここでゲージとか消費するように変更 18/6/13
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				BSound.SE_Play( { type=_SeType_Normal, num=193 } ); //ガードシールド発動音

				local guardshield_flashtime = 10;
			
				//発動時のゲージ消費
				if( Def_Sys_GuardShield_UseEXS )
				{
					BMvEff.SetSpGauge( { value=def_SP_GuardShield_Init } );
				}
				
				if( Def_Sys_GuardShield_PlusVecTime )
				{
					local bound_time = BMvEff.SetBoundSt( { addtime = 0 } ); // 現在値
					local set_bound_time = bound_time + Def_Sys_GuardShield_PlusVecTime;
					if( set_bound_time < Def_Sys_GuardShield_PlusVecTimeMin ) set_bound_time = Def_Sys_GuardShield_PlusVecTimeMin;
					guardshield_flashtime = set_bound_time;
					
					// BMvEff.SetBoundSt( { addtime = Def_Sys_GuardShield_PlusVecTime } ); // ガードシールド発動すると硬直が増加する
					_dpn("ガード時間:"+bound_time+" -> "+set_bound_time);
					BMvEff.SetBoundSt( { settime = set_bound_time } ); // ガードシールド発動すると硬直が増加する
				}
				
				//自分を少し離れるようにする
				//ガードシールド＝ガード中のみだからDIVをいじっても大丈夫なはず
				//相手をいじるのは何か怖い。地上のみにする？
				BMvTbl.SetVector( { x=-1400, addx=200, flags=_Vector_DivKeep } );//UNIst x:-1000, add:200
				
				Battle_Std.SetCharaFlash_GuardSPCommand( guardshield_flashtime ); //発動の発光

				player.pop();
			}
		}
	}
	function FrameUpdate_Std()
	{
		local mode = BMvTbl.GetLP(0);
		
		switch( mode )
		{
		case 0: //Mvの変化をチェック。変わったらもうガードシールドは成功するはずがない。
			local mv = Battle_Std.GetPlayerMvName();
			if( mv!="Mv_Guard" )
			{
				BMvTbl.SetLP(0,1)
				// print("\nガードシールド成功チェック終了");
				return;
			}
			//Mvが変わらずガードＳＰになってたらエフェクトを呼ぶ
			
			local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			if( player.push() )
			{
				local guardSP_get = BMvEff.GuardSP_Get(); //SPガード（バリガ）状態の取得
				local guardSP_success = BMvEff.GuardSP_Success(); //SPガード（バリガ）状態でガードが成立したかどうか
				local guardSP_effcallok = (guardSP_get==0 && guardSP_success); //SPガード（バリガ）状態じゃないガードでかつSPガードが成立
				
				local is_end = ( guardSP_effcallok || guardSP_get!=1 )? 1 : 0;
				if( is_end )
				{
					BMvEff.SetCharaFlash( { type = 0 } ); //発光を止める
				}
				
				player.pop();
				
				if( guardSP_effcallok )
				{
					// print("\nガードシールド成功");
					local eff = BMvEff.CreateObject( { datatype=1, start_pat=72, } );
					if( eff.push() )
					{
						BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_MoveTimeStopAll } );
						BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull } ); // これがないと_ObjFlags_ParentMoveがおかしくなる
						eff.pop();
					}
					BMvTbl.SetLP(0,1);
				}
				if( is_end )
				{
					BMvTbl.SetFinalize(0); // 消滅へ
				}
			}
			
			break;
		case 1: //Ｍｖが変わったorガードシールド成功エフェクトをもうよんだ後
			break;	
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_GroundUkemi <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BtlMvStd.SetGroundUkemiStatus();
	}
	function Update_Std() // 
	{
	}
	function Finalize_Std() // 
	{
		//状態の移行だけ行う
		BtlMvStd.SetGroundUkemiFinalize();
	}
	function LastUpdate_Std() // 
	{
	}
}

// ----------------------------------------------------------------------------
// 基本アクション
// ----------------------------------------------------------------------------
//全キャラほぼ共通部分（個別に変えたい場合はキャラ別で同名Mv作っておく）---------------------------------------------------------------

local val_StdTyouhatsuType = chrparam.Get( { type="立ち挑発タイプ", chrnum=_ChrNo } ); 

Std_MoveTable.Mv_Neutral <- // ニュートラル待機
{
	function Init_Std() // 
	{	
		// Mv_Standbyからきたときは同じPATにしない
		// この処理戻ってくるたびにするのちょっと嫌な感じがある
		if( BMvTbl.ChangeMv_GetMvName() == "Mv_Standby" && BMvTbl.GetMvStatus().DataPattern == def_PAT_Neutral )
		{
			// _dpn("何もしない");
		}
		else
		{
			BMvTbl.SetPattern(def_PAT_Neutral);
		}
		
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetFinalizeCode(0); //初期状態が0でない＋GetFinalizeCodeで分岐してるので初期化
		BMvTbl.SetMoveableFlag( { move=1, time=255, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		BMvTbl.SetPP(def_PP_TMP0,0); // 挑発待機
	}
	function FrameUpdate_Std() : (val_StdTyouhatsuType)
	{
		BMvTbl.SetMoveableFlag( { move=1, time=32, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ループに含める行動可能
		
		if( BMvTbl.CheckFurimuki() ) // 振り向きチェック
		{
			BMvTbl.SetFinalize(256); // コード256を振り向きとしてFinalize
		}


		// 通常時と、トレーニング時（キャラ固有で挑発有効時のみ）に挑発を行う
		// チュートリアルとミッションは除外
		local stage_st = BMvTbl.GetMvStageStatus().IsTrainingBattle(); // 1-Training  2-Tutorial  3-Mission
		local appeal = BMvEff.TM_GetCharaGauge(Def_TMCG_EnableAppeal);//挑発の有無
		if( stage_st == 0 || ( stage_st == 1 && appeal ) )
		{
			local s = BMvTbl.GetMvStatus(); // ステータス取得
			//挑発再生チェック
			switch( val_StdTyouhatsuType )
			{
			case 0: // 挑発無し
				break;
			case 1: // 挑発あり・モーションあり
				if( BMvTbl.GetPP(def_PP_TMP0) <= 0 && s.MvCount>def_FL_NeutralWaitMin && s.MvCount%def_FL_NeutralWaitStep==0 && BMvTbl.GetFinalizeCode() == 0 ) //振り向き中は反応しないとか
				{
					if( BMvEff.Random_Limit(100) < 15 ) //発動確率
					{
						if (BMvTbl.JumpFrameID( 512 )!= -1 ) //あった？
						{
							BMvTbl.SetPP(def_PP_TMP0,10); // 10F後に挑発を行う予約
							Battle_Std.CallSkillSoonCache( 512, 10 );
						}
					}
				}
				break;
			case 2: // 挑発あり・モーション無し ※暫定未実装
				// if( Def_Dbg_NoPlayUpsetSE == 0 ) Battle_Std.TypeSE_Play({ type="挑発" });
				break;
			}
		}
	}
	function Update_Std()
	{
		if( BMvTbl.GetPP(def_PP_TMP0)>0 )
		{
			// _dp("\n 挑発予約:"+BMvTbl.GetPP(def_PP_TMP0) );
			local left_frame = BMvTbl.AddPP(def_PP_TMP0,-1);
			if( left_frame <=0 )
			{
				BMvTbl.SetFinalize(512); // 立ち待機アニメへ
			}
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Furimuki_S"], [512,"Mv_NeutralWait"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_NeutralWait <- // ニュートラル待機
{
	function Init_Std() // 
	{
		if( Def_Dbg_NoPlayUpsetSE == 0 ) Battle_Std.TypeSE_Play({ type="挑発" });
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする		
	}
	function Update_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=1, time=2, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );	
		if( BMvTbl.CheckFurimuki() ) // 振り向きチェック
		{
			BMvTbl.SetFinalize(256); // コード256を振り向きとしてFinalize
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Furimuki_S"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_NeutralWaitNoMotion <- // ニュートラル待機
{
	function Init_Std() // 
	{
		if( Def_Dbg_NoPlayUpsetSE == 0 ) Battle_Std.TypeSE_Play({ type="挑発" });
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする		
	}
	function Update_Std() // 
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		BMvTbl.SetMoveableFlag( { move=1, time=2, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );		
		if( BMvTbl.CheckFurimuki() ) // 振り向きチェック
		{
			BMvTbl.SetFinalize(256); // コード256を振り向きとしてFinalize
		}
		if( s.MvCount>180 ) BMvTbl.SetFinalize(0); // 時間で終了（ポーズが無い人だっているんです）
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Furimuki_S"] ); //デフォ,[code,mv]...
	}
}

local footstepA_senum = chrparam.Get( { type="足音Ａ_ＳＥ番号", chrnum=_ChrNo } );
local footstepB_senum = chrparam.Get( { type="足音Ｂ_ＳＥ番号", chrnum=_ChrNo } );



//Param0が10の時足音を再生する
Std_MoveTable.Mv_Null_PlayFootstepSE <- 
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_NoRender|_ObjFlags_EraseParentPatChange } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetLP(0,0);
		
		//デバッグ用間隔表示
		BMvTbl.SetLP(1,0);
	}
	function FrameUpdate_Std() : ( footstepA_senum, footstepB_senum)
	{
		local my_st = BMvTbl.GetMvStatus();
		if( my_st.CallCount!=0 )
		{
			return;
		}
		
		local player = BMvCore.GetPlayerCharaData();
		if( player.isdone() )
		{
			local playtiming = 0;
			if( player.push() )
			{
				if( Battle_Std.GetUpdateParam0() == 10 )
				{
					playtiming = 1;
				}
				player.pop();
			}

			if( playtiming==1 )
			{
				local setype = BMvTbl.GetLP(0);
				BMvTbl.SetLP(0, 1-setype ); // 0 1 0 1 ...
				switch( setype )
				{
				case 0:
					if( footstepA_senum != -1 ) BSound.SE_Play( { type=_SeType_Normal, num=footstepA_senum } );
					break;
				case 1:
					if( footstepB_senum != -1 ) BSound.SE_Play( { type=_SeType_Normal, num=footstepB_senum } );
					break;
				}
				// デバッグ
				local mvs = BMvTbl.GetMvStatus();
				local aida = mvs.MvCount - BMvTbl.GetLP(1);
				BMvTbl.SetLP(1,mvs.MvCount);
				if( aida != 0 )
				{
					// print("\nＳＥ間隔："+aida+" setype:"+setype+" mvs.MvCount:"+mvs.MvCount);
				}
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

local walk_vectorar = chrparam.Get( { type="歩きベクトル", chrnum=_ChrNo } );
local walk_f_vector = { start=walk_vectorar[0], loop=walk_vectorar[1] };
local walk_b_vector = { start=walk_vectorar[2], loop=walk_vectorar[3] };

Std_MoveTable.Mv_Walk_F <- // 前進
{
	function Init_Std() // 
	{
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Walk_F);
		Battle_Std.Call_FootStepSE(); // //足音再生監視オブジェクト
	}
	function FrameUpdate_Std() : (walk_f_vector)
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount == 0 )
		{
			BMvTbl.SetVector( { x=walk_f_vector.start, y=0, addx=0, addy=0, flags=_Vector_Normal } );
		}
		else if( mvs.MvCount == 2 )
		{
			BMvTbl.SetVector( { x=walk_f_vector.loop, y=0, addx=0, addy=0, flags=_Vector_Normal } );
		}		
		
		BMvTbl.SetMoveableFlag( { move=1, time=32, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ループに含める行動可能
		if( BMvTbl.CheckStickHold( (1<<0) ) || !BMvTbl.CheckStickHold( (1<<6) ) )
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_WalkStop_F" );
	}
}

Std_MoveTable.Mv_WalkStop_F <- // 前進停止
{
	function Init_Std() // 
	{
		Battle_Std.JumpFrameIDEX(256, def_PAT_Walk_F, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}		

Std_MoveTable.Mv_Walk_B <- // 後退
{
	function Init_Std() // 
	{
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Walk_B);
		Battle_Std.Call_FootStepSE(); // //足音再生監視オブジェクト
	}
	function FrameUpdate_Std() : (walk_b_vector)
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount == 0 )
		{
			BMvTbl.SetVector( { x=walk_b_vector.start, y=0, addx=0, addy=0, flags=_Vector_Normal } );
		}
		else if( mvs.MvCount == 2 )
		{
			BMvTbl.SetVector( { x=walk_b_vector.loop, y=0, addx=0, addy=0, flags=_Vector_Normal } );
		}
		
		BMvTbl.SetMoveableFlag( { move=1, time=32, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ループに含める行動可能
		if( BMvTbl.CheckStickHold( (1<<0) ) || !BMvTbl.CheckStickHold( (1<<4) ) )
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_WalkStop_B" );
	}
}

Std_MoveTable.Mv_WalkStop_B <- // 後退停止
{
	function Init_Std() // 
	{
		Battle_Std.JumpFrameIDEX(256, def_PAT_Walk_B, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

// カットインの絵だけ
Std_MoveTable.Mv_CutinGrp <- //カットイン スクロールの影響を受けない
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPattern(def_PAT_IWCutinGrp);
		BMvTbl.SetPrio( _CharaPrio_Parent_BG  );//BG手前
		BMvTbl.SetPosition( { x=0, y=0 } );
		Battle_Std.PcAuraEffect_CutinInit();
		// _dm("カットイン呼ばれ");
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

// カットインの絵だけ　使わない

Std_MoveTable.Mv_IWXCutinGrp <- //カットイン スクロールの影響を受けない
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPattern(def_PAT_IWXCutinGrp);
		BMvTbl.SetPrio( _CharaPrio_Near ); //一番手前にする
		BMvTbl.SetPosition( { x=0, y=0 } );
		Battle_Std.PcAuraEffect_CutinInit();
		//_dm("カットイン呼ばれ");
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

// これは絵だけじゃない、表示して他をとめる
//インフィニットワースイグジスト
Std_MoveTable.Mv_IWXCutin <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPattern(def_PAT_IWXCutinGrp);
		BMvTbl.SetPrio( _CharaPrio_Near ); //一番手前にする
		BMvTbl.SetPosition( { x=0, y=0 } );
		Battle_Std.PcAuraEffect_CutinInit();
		//_dm("カットイン呼ばれ");
		
		local eff = BMvEff.CreateObject( { datatype=1, start_pat=998 }); //黒い板を呼ぶ
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
			BMvTbl.SetPosition( { x=0, y=-360*128 } );			
			
			eff.pop();
		}


		BMvEff.SetStopTime( { time=50, stopme=2 } ); //自分以外をとめてしまう
	}
	function FrameUpdate_Std()
	{
		//print("\n.");
	}
	function Finalize_Std()
	{
		//print("\n -------------------☆");
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		//
	}
}

// ヴォーパルのカットイン
// VORPALのアナウンスとあわせるため、向きではなく1Pと2Pのサイドで分ける
// 急に出てきてびっくりするという意見もあったので、少しフェードイン要素を強め＋位置をカットイン寄りに変更
Std_MoveTable.Mv_CVPCutinGrp <- //カットイン スクロールの影響を受けない
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPattern(996);
		BMvTbl.SetPrio( _CharaPrio_Parent_BG  );//BG手前
		
		if( Def_Sys_VorpalCutinPosType == 0 )
		{
			local pside = BMvTbl.GetPlayerSide();
			local pos_muki = ( pside == 0)? 1 : -1;
			local grp_muki = ( pside == 0)? _Direction_Right : _Direction_Left;
			// _dpn("psidepside:"+pside);
			// BMvTbl.SetPosition( { x=-520*BMvTbl.GetMuki()*128, y=-8*128 } );
			BMvTbl.SetPosition( { x=-520*pos_muki*128, y=-8*128 } );
			BMvTbl.SetMuki( grp_muki );
		}
		else
		{
			local muki = BMvTbl.GetMuki();
			BMvTbl.SetPosition( { x=-520*muki*128, y=-8*128 } );
		}

		// フェードイン＆少し暗くしてびっくりしにくく調整
		if( Def_Sys_VorpalCutinDrawType )
		{
			BMvTbl.SetDrawAlpha( { val=0, time=255, flag=_ClearFlag_ChangeMv } ); // フェードイン設定
			BMvEff.SetCharaColor( { color=0xCCCCCC, type=3, time=255 } ); // 少し暗くする
		}
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		local mvcount = mvs.MvCount;
		if( mvcount == 13 )
		{
			BMvTbl.SetVector( { y=-10 } );
		}
		
		// フェードインでびっくりしにくく調整
		if( Def_Sys_VorpalCutinDrawType )
		{
			local fadeInFrame = 30;
			if( mvcount < fadeInFrame )
			{
				local par = mvcount * 100 / fadeInFrame;
				local alpha = 128 + (127 * par / 100);
				// _dpn("par:"+par+" alpha:"+alpha);
				BMvTbl.SetDrawAlpha( { val=alpha, time=255, flag=_ClearFlag_ChangeMv } );
			}
			else if( mvcount == fadeInFrame )
			{
				BMvTbl.SetDrawAlpha( { val=255, time=0, flag=0 } ); // 通常描画に戻す
			}
		}
		
		// KO後はすぐに消える
		if( Battle_Std.CharaisKO() )
		{
			BMvTbl.SetFinalize();
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}			
}

// EXカットインの絵だけ
Std_MoveTable.Mv_EXCutinGrp <- //カットイン スクロールの影響を受けない
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPattern(def_PAT_EXCutinGrp);
		BMvTbl.SetPrio( _CharaPrio_Parent_BG  );//BG手前
		BMvTbl.SetPosition( { x=0, y=0 } );
		//_dm("Mv_EXCutinGrp　EXカットイン呼ばれ");		
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}			
}

//暫定カットイン処理
Std_MoveTable.Mv_CutinObject <- //カットイン スクロールの影響を受けない
{
	function Init_Std()
	{
	}
	function Update_Std()
	{
		local effcallflag = false;
		if( BMvTbl.GetLP(0) == 0) //まだ出てない
		{
			//特殊判定を見つけたらカットイン集中エフェクトをそこに出す
			local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			if( player.push() )
			{
				local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
				if( rc.sx != _Hantei_Error ) // 存在するか
				{	
					local eff = BMvEff.CreateObject( { x=rc.sx, y=rc.sy, mvname="", datatype=1, start_pat=43, flags=_Position_ToolShift } );
					if( eff.push() )
					{
						BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_MoveTimeStopAll } );	
						eff.pop();
					}
					effcallflag = true;
				}
				player.pop();
			}
			if( effcallflag ) BMvTbl.SetLP( 0, 1); //エフェクト出した			
		}
		else
		{
			BMvTbl.SetFinalize(0);
		}
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.MvCount>60 ) BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}			
}

local chp_DashJumpKansei = chrparam.Get( { type="ダッシュジャンプ慣性", chrnum=_ChrNo } );

//地上ジャンプの離陸から着地まで持続するオブジェクト
Std_MoveTable.Mv_JumpKanseiCheckObject <- //ジャンプ中の慣性（収束ベクトルじゃなくする）
{
	function Init_Std() : (chp_DashJumpKansei)
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPosition( { y=1024, flags=_Position_CaptureShift } );
		
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		if( player.push() )
		{
			local v = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
			
			local use_dashJumpKansei = chp_DashJumpKansei;
			//_dpn("ダッシュジャンプ慣性:"+use_dashJumpKansei);
			BMvTbl.SetVector( { x=v.x*use_dashJumpKansei/100, addx=0, flags=_Vector_DivKeep } ); //メルブラジャンプ

			player.pop();
		}
	}
	function Update_Std() // 
	{
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		if( player.push() )
		{
			local playerisground = ( (BMvTbl.CheckPosState( _PosState_Ground ))==1 );
			if( playerisground )	
			{
				BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_DivKeep } ); //メルブラジャンプ終了
			}
			player.pop();
		
			if ( playerisground )	
			{
				BMvTbl.SetFinalize(0);
				BMvTbl.SetPP(def_PP_JumpStatus,0); //ジャンプステータスを初期化
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}	
}

local func_JumpWaitInit = function()
{
	BMvTbl.SetMuki(_Direction_Auto);
	local vec = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
	Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
	BMvTbl.SetVector( { x=vec.x, addx=-vec.x/20, flags=_Vector_DivKeep } ); //メルブラジャンプ
	BMvEff.SetPlayerTimer( { muteki_nage=def_FL_JumpWaitNageMuteki, muteki_nageX=def_FL_JumpWaitNageMuteki } ); //ジャンプ移行は投げ無敵に設定
	
	// BMvTbl.SetLP(0,0);
	
	BMvTbl.AirSkill_Begin(); // ジャンプ準備フレームのはじめに呼ぶ

	Battle_Std.PassBeforeMoveCodeEx( 2, def_MC2_DashKansei ); // ダッシュ慣性フラグを引き継ぐ
}

local func_JumpWaitFU = function()
{
	/*
	// ここでボタンを何か押していたら先行入力を受け付ける、みたいな
	if( BMvTbl.CheckCommandString( ["A","B","C","D"] ) )
	{
		// _dp("\n 先行入力！");
		BMvTbl.SetLP(0,1); // 先行入力チェック用
	}
	*/
}

// ジャンプで空中に浮いた時共通処理
local func_JumpFlightInit = function()
{
	BMvTbl.AirSkill_Check(); // ジャンプ開始フレームのはじめに呼ぶ
	
	Battle_Std.PassBeforeMoveCodeEx( 2, def_MC2_DashKansei ); // ダッシュ慣性フラグを引き継ぐ
	Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Jump ); // 空中属性
	
	Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_LightLegsMuteki );//小足属性へ空振り予定のMV
	BMvTbl.SetHitCheckFlag( { type=0, val=Def_HitCheckFlag_LightLegs, time=255, flag=_ClearFlag_ChangeMv } ); // 小足無敵にスカる
	
	BMvTbl.SetPP(def_PP_JumpFrame,0);//離陸から何フレームかを記憶する
	Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_EnableJumpFramePP ); // def_PP_JumpFrameが有効なMV
}

//二段ジャンプで浮いたときの共通処理
local func_MultiJumpInit = function()
{
	local angle = Battle_Std.CCharaVector_GetToolAngle();
	local eff = BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=233, flags=_Position_ToolShift } );
	if( eff.push() )
	{
		BMvTbl.SetAngle({ angle=angle });
		
		eff.pop();
	}
	
	BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );
	BMvTbl.SetAirJumpOK(0);  //再度ジャンプできないようにする
	BMvTbl.AddAirJumpCount(1);  //回数を加算
	
	Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_LightLegsMuteki );//小足属性へ空振り予定のMV
	BMvTbl.SetHitCheckFlag( { type=0, val=Def_HitCheckFlag_LightLegs, time=255, flag=_ClearFlag_ChangeMv } ); // 小足無敵にスカる
}

// CVO中の簡易IW用かませMv
Std_MoveTable.Mv_41236SP_ABC <-
{
	function Init_Std() // 
	{
		//【トロフィー】実戦でクロスキャストヴェールオフ中にA+B+Cの入力でインフィニットワースを使用した。
		// BMvTbl.Achievement_Unlock(3);
		
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Skill_41236SP" );
	}
}

//ジャンプキャンセル制限フラグを立てる用のかませMv
Std_MoveTable.Mv_JumpCanselWait_F <-
{
	function Init_Std() // 
	{
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_JumpWait_F" );
	}
}

// ジャンプ待機
Std_MoveTable.Mv_JumpWait_F <- 
{
	function Init_Std() : (func_JumpWaitInit)
	{
		func_JumpWaitInit();
		BMvTbl.SetPattern(def_PAT_Jump_F);
	}
	function FrameUpdate_Std() : (func_JumpWaitFU)
	{
		if( BMvTbl.CheckPosState( _PosState_Air ) == 1) //空中に進んだ
		{
			BMvTbl.SetFinalize(0);
		}		
		func_JumpWaitFU();
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_nageX=0 } ); //抜けるときに初期化
		if( BMvTbl.CheckPosState( _PosState_Air ) == 1) //空中に進んだ
		{
			BMvEff.CreateObject( { mvname="", datatype=1, start_pat=255, flags=_Position_ToolShift } );		
			BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );		
		}
		
		// ダッシュジャンプでかかり必殺技でスーっと滑るのが強いので補正
		if( !BMvTbl.FromFinalize() )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
			BMvTbl.SetVector( { x=vec.x*100/150, addx=-vec.x/10,flags=_Vector_DivKeep } ); // 収束ダッシュ慣性を減少
		}
	}
	function Finalize_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount<4 ) _dem("【警告】ジャンプ移行フレームが["+(s.MvCount-1)+"F]しかありません")

		BMvTbl.SetNextMoveTable( "Mv_Jump_F" ); //

		//前の行動がジャンプキャンセルだったら消費
		//ここで消費しないとジャンプキャンセルをキャンセルしたときにフラグがたってしまう
		if( BMvTbl.ChangeMv_GetMvName() == "Mv_JumpCanselWait_F" )
		{
			Battle_Std.EnemyDamageFlag_Add( def_DF_JumpCanseled ); // 「ジャンプキャンセルをされた」を相手に記憶
		}	
	}
}

// ジャンプ
Std_MoveTable.Mv_Jump_F <- 
{
	function Init_Std() : (func_JumpFlightInit)
	{
		Battle_Std.JumpStatus.Add( def_PP_JS_JumpF ); //前ジャンプからフラグを立てる
		
		func_JumpFlightInit(); // ジャンプ空中に移行した時共通処理
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		BMvTbl.SetPP(def_PP_JumpFrame,mvs.MvCount);//離陸から何フレームかを記憶　※LastUpdateだと0Fが取得できない
	}
	function FrameUpdate_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
}

//ジャンプ共通着地Mv
Std_MoveTable.Mv_Jump_Land <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=0, time=def_FL_Jump_LandRecovery, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		Battle_Std.InitVector(); //ベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}		

//ジャンプキャンセル制限フラグを立てる用のかませMv
Std_MoveTable.Mv_JumpCanselWait_B <-
{
	function Init_Std() // 
	{
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_JumpWait_B" );
	}
}



// ジャンプ待機
Std_MoveTable.Mv_JumpWait_B <- 
{
	function Init_Std() : (func_JumpWaitInit)
	{
		func_JumpWaitInit();
		BMvTbl.SetPattern(def_PAT_Jump_B);
	}
	function FrameUpdate_Std() : (func_JumpWaitFU)
	{
		if( BMvTbl.CheckPosState( _PosState_Air ) == 1) //空中に進んだ
		{
			BMvTbl.SetFinalize(0);
		}
		func_JumpWaitFU();
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_nageX=0 } ); //抜けるときに初期化
		if( BMvTbl.CheckPosState( _PosState_Air ) == 1) //空中に進んだ
		{
			BMvEff.CreateObject( { mvname="", datatype=1, start_pat=257, flags=_Position_ToolShift } );		
			BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );		
		}		

		// ダッシュジャンプでかかり必殺技でスーっと滑るのが強いので補正
		if( !BMvTbl.FromFinalize() )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
			BMvTbl.SetVector( { x=vec.x*100/150, addx=-vec.x/10,flags=_Vector_DivKeep } ); // 収束ダッシュ慣性を減少
		}
	}
	function Finalize_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount<4 ) _dem("【警告】ジャンプ移行フレームが["+(s.MvCount-1)+"F]しかありません")
		
		BMvTbl.SetNextMoveTable( "Mv_Jump_B" ); //
		
		//前の行動がジャンプキャンセルだったら消費
		//ここで消費しないとジャンプキャンセルをキャンセルしたときにフラグがたってしまう
		if( BMvTbl.ChangeMv_GetMvName() == "Mv_JumpCanselWait_B" )
		{
			Battle_Std.EnemyDamageFlag_Add( def_DF_JumpCanseled ); // 「ジャンプキャンセルをされた」を相手に記憶
		}
	}
}	

Std_MoveTable.Mv_Jump_B <- 
{
	function Init_Std() : (func_JumpFlightInit)
	{
		Battle_Std.JumpStatus.Add( def_PP_JS_JumpB ); //後ろジャンプからフラグを立てる
		
		func_JumpFlightInit(); // ジャンプ空中に移行した時共通処理
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		BMvTbl.SetPP(def_PP_JumpFrame,mvs.MvCount);//離陸から何フレームかを記憶　※LastUpdateだと0Fが取得できない
	}
	function FrameUpdate_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
}


//ジャンプキャンセル制限フラグを立てる用のかませMv
Std_MoveTable.Mv_JumpCanselWait_N <-
{
	function Init_Std() // 
	{
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_JumpWait_N" );
	}
}

// ジャンプ待機
Std_MoveTable.Mv_JumpWait_N <- 
{
	function Init_Std() : (func_JumpWaitInit)
	{
		func_JumpWaitInit();
		BMvTbl.SetPattern(def_PAT_Jump_N);		
	}
	function FrameUpdate_Std() : (func_JumpWaitFU)
	{
		if( BMvTbl.CheckPosState( _PosState_Air ) == 1) //空中に進んだ
		{
			BMvTbl.SetFinalize(0);
		}
		func_JumpWaitFU();
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_nageX=0 } ); //抜けるときに初期化
		if( BMvTbl.CheckPosState( _PosState_Air ) == 1) //空中に進んだ
		{
			BMvEff.CreateObject( { mvname="", datatype=1, start_pat=256, flags=_Position_ToolShift } );		
			BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );		
		}
		
		// ダッシュジャンプでかかり必殺技でスーっと滑るのが強いので補正
		if( !BMvTbl.FromFinalize() )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
			BMvTbl.SetVector( { x=vec.x*100/150, addx=-vec.x/10,flags=_Vector_DivKeep } ); // 収束ダッシュ慣性を減少
		}
	}
	function Finalize_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount<4 ) _dem("【警告】ジャンプ移行フレームが["+(s.MvCount-1)+"F]しかありません")
		
		BMvTbl.SetNextMoveTable( "Mv_Jump_N" ); //

		//前の行動がジャンプキャンセルだったら消費
		//ここで消費しないとジャンプキャンセルをキャンセルしたときにフラグがたってしまう
		if( BMvTbl.ChangeMv_GetMvName() == "Mv_JumpCanselWait_N" )
		{
			Battle_Std.EnemyDamageFlag_Add( def_DF_JumpCanseled ); // 「ジャンプキャンセルをされた」を相手に記憶
		}
	}
}	

Std_MoveTable.Mv_Jump_N <- 
{
	function Init_Std() : (func_JumpFlightInit)
	{
		Battle_Std.JumpStatus.Add( def_PP_JS_JumpN ); //垂直ジャンプからフラグを立てる
		
		func_JumpFlightInit(); // ジャンプ空中に移行した時共通処理
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		BMvTbl.SetPP(def_PP_JumpFrame,mvs.MvCount);//離陸から何フレームかを記憶　※LastUpdateだと0Fが取得できない
	}
	function FrameUpdate_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_MultiJump_F <-
{
	function Init_Std() : (func_MultiJumpInit)// 
	{
		//BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_MultiJump_F);

		func_MultiJumpInit();
		
		Battle_Std.JumpStatus.Add( def_PP_JS_MultiJumpF ); //ジャンプフラグを立てる	
	}
	function FrameUpdate_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
}	

Std_MoveTable.Mv_MultiJump_B <-
{
	function Init_Std() : (func_MultiJumpInit)// 
	{
		//BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_MultiJump_B);

		func_MultiJumpInit();
		
		Battle_Std.JumpStatus.Add( def_PP_JS_MultiJumpB ); //ジャンプフラグを立てる
	}
	function FrameUpdate_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
}	

Std_MoveTable.Mv_MultiJump_N <-
{
	function Init_Std() : (func_MultiJumpInit)// 
	{
		BMvTbl.SetPattern(def_PAT_MultiJump_N);
		
		func_MultiJumpInit();
		
		Battle_Std.JumpStatus.Add( def_PP_JS_MultiJumpN ); //ジャンプフラグを立てる		
	}
	function FrameUpdate_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_Crouch <- // しゃがみ移行
{
	function Init_Std() // 
	{
		//print("\n->しゃがみいこう");
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Crouch);
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする		
	}
	//遅立ちテクを残すためにここのUpdateではキー受付をしない
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}

local val_CroTyouhatsuType = chrparam.Get( { type="しゃがみ挑発タイプ", chrnum=_ChrNo } ); 


Std_MoveTable.Mv_Crouch_Wait <- // しゃがみ待機
{
	function Init_Std() // 
	{
		// BMvTbl.SetMuki(_Direction_Auto); // これ不要。あるとしゃがみ振り向き発生しないでしょ
		BMvTbl.SetPattern(def_PAT_Crouch_Wait);
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		
		BMvTbl.SetLP(0,0); //挑発状態かフラグ　0:通常 1:挑発
		BMvTbl.SetFinalizeCode(0); //初期状態が0でない＋GetFinalizeCodeで分岐してるので初期化
	}
	function FrameUpdate_Std() : (val_CroTyouhatsuType)
	{
		BMvTbl.SetMoveableFlag( { move=1, time=32, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ループに含める行動可能
		
		// トレモ的なやつ以外なら挑発を行う
		if( BMvTbl.GetMvStageStatus().IsTrainingBattle() == 0 )
		{
			switch( val_CroTyouhatsuType )
			{
			case 0: // 挑発無し
				break;
			case 1: // 挑発あり・モーションあり
				local s = BMvTbl.GetMvStatus();
				
				if( s.MvCount>def_FL_NeutralWaitMin && s.MvCount%def_FL_NeutralWaitStep==0 && BMvTbl.GetFinalizeCode() == 0 && BMvTbl.GetLP(0)==0 )
				{
					local r = BMvEff.Random_Limit(100);
					if( r<20 ) //発動確率
					{
						if (BMvTbl.JumpFrameID( 512 )!= -1 ) //あった？
						{
							BMvTbl.SetLP(0,1); //挑発状態へ
							if( Def_Dbg_NoPlayUpsetSE == 0 ) Battle_Std.TypeSE_Play({ type="挑発" });
						}
					}
				}
				if( Battle_Std.GetUpdateFrameID( s ) == 900 && BMvTbl.GetLP(0)==1 )
				{
					BMvTbl.SetLP(0,0); //挑発状態解除
				}		
				break;
			}
		}
	}	
	function Update_Std() // 
	{
		// 下方向でないとき立ち上がる
		if( !BMvTbl.CheckStickHold( (1<<1) | (1<<2) | (1<<3) ) )
		{
			BMvTbl.SetFinalize(0); // コード0を立ち上がりとしてFinalize
		}
		else if( BMvTbl.CheckFurimuki() ) // 振り向きチェック
		{
			BMvTbl.SetFinalize(256); // コード256を振り向きとしてFinalize
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Crouch_toN", [256,"Mv_Furimuki_C"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_Crouch_toN <- //立ち上がり
{
	function Init_Std() // 
	{
		//print("\n->たちいこう");
	
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Crouch_toN);
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする		
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

// 振り向き音声を再生するべきかどうかチェック
local checkFurimukiVoice = function()
{
	if( Battle_Std.CheckEnemyisBound() ) return 0;
	if( Battle_Std.CheckEnemyisUkemi() ) return 0;
	
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		local e_muki = BMvTbl.GetMuki();
		enemy.pop();
		
		local p_muki = BMvTbl.GetMuki();
		
		if( p_muki == e_muki )
		{
			// お互い右向きとか、お互い左向きとか
			// 先に振り向くキャラがこっちに入ることが多い
			// _dp("\n しゃべってもいい");
			return 1;
		}
		else
		{
			// お互い向き合うorお互い逆を向いている（後者でしゃべらないのは変だけど、レアケースなので除外）
			// 後から振り向くキャラがこのセリフに入ることが多い
			// _dp("\n これはしゃべらない");
			return 0;
		}
	}
	return 0; // 相手が取得できない＝よくわからないので声はなし
}

// 立ち振り向き
Std_MoveTable.Mv_Furimuki_S <- 
{
	function Init_Std() : (checkFurimukiVoice)// 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Furimuki_S);		
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		//相手がやられ中や受け身中なら音声は不要なのでチェック
		if( checkFurimukiVoice() )
		{
			Battle_Std.TypeSE_Play({ type="振り向き" });
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

// しゃがみ振り向き
Std_MoveTable.Mv_Furimuki_C <- 
{
	function Init_Std() : (checkFurimukiVoice)// 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Furimuki_C);		
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		//相手がやられ中や受け身中なら音声は不要なのでチェック
		if( checkFurimukiVoice() )
		{
			Battle_Std.TypeSE_Play({ type="振り向き" });
		}
	}
	function Update_Std() // 
	{
		// 下方向でないとき立ち上がる
		if( !BMvTbl.CheckStickHold( (1<<1) | (1<<2) | (1<<3) ) )
		{
			BMvTbl.SetFinalize(256); // コード256を立ち上がりとしてFinalize
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Crouch_Wait", [256,"Mv_Crouch_toN"] ); //デフォ,[code,mv]...
	}
}


// 立ち通常技
Std_MoveTable.Mv_Atk_StdA <- 
{
	function Init_Std()
	{
		Battle_Std.InitGroundAtk( { type="A" } ); //通常攻撃共通Init
		Battle_Std.MoveCode.AddFlag( def_MC_GRDLowBreak ); // GRDブレイクの効果が短いMv
		
		BMvTbl.SetComboLimit(DEF_BS_CL_STDA);			
		BMvTbl.SetPattern(def_PAT_Atk_StdA);
		BMvTbl.SetPP(def_PP_StdComboChain,1);
	}
	function Start_Std() : (rapidAtkAHoseiAr)
	{
		Battle_Std.StartGroundAtk();
		Battle_Std.SetRapidAtkAHosei( rapidAtkAHoseiAr[0] ); // 連キャン補正を設定
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="立ち弱攻撃" });
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}
Std_MoveTable.Mv_Atk_StdB <- 
{
	function Init_Std()
	{
		Battle_Std.InitGroundAtk( { type="B" } ); //通常攻撃共通Init
		
		BMvTbl.SetComboLimit(DEF_BS_CL_STDB);
		BMvTbl.SetPattern(def_PAT_Atk_StdB);
	}
	function Start_Std()
	{
		Battle_Std.StartGroundAtk();
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="立ち中攻撃" });
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}
Std_MoveTable.Mv_Atk_StdC <- 
{
	function Init_Std()
	{
		Battle_Std.InitGroundAtk( { type="C" } ); //通常攻撃共通Init
		//Battle_Std.MoveCode.AddFlag( def_MC_NoJumpCansel ); // 行動コード(通常ＣでもＪＣ不可)を設定

		BMvTbl.SetComboLimit(DEF_BS_CL_STDC);
		BMvTbl.SetPattern(def_PAT_Atk_StdC);
	}
	function Start_Std()
	{
		Battle_Std.StartGroundAtk();
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="立ち強攻撃" });
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

// しゃがみ通常技
Std_MoveTable.Mv_Atk_CroA <- 
{
	function Init_Std()
	{
		Battle_Std.InitGroundAtk( { type="A" } ); //通常攻撃共通Init
		Battle_Std.MoveCode.AddFlag( def_MC_GRDLowBreak ); // GRDブレイクの効果が短いMv

		BMvTbl.SetComboLimit(DEF_BS_CL_CROA);
		BMvTbl.SetPattern(def_PAT_Atk_CroA);
	}
	function Start_Std() : (rapidAtkAHoseiAr)
	{
		Battle_Std.StartGroundAtk();
		Battle_Std.SetRapidAtkAHosei( rapidAtkAHoseiAr[1] ); // 連キャン補正を設定
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="しゃがみ弱攻撃" });
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}
Std_MoveTable.Mv_Atk_CroB <- 
{
	function Init_Std()
	{
		Battle_Std.InitGroundAtk( { type="B" } ); //通常攻撃共通Init

		BMvTbl.SetComboLimit(DEF_BS_CL_CROB);
		BMvTbl.SetPattern(def_PAT_Atk_CroB);
	}
	function Start_Std()
	{
		Battle_Std.StartGroundAtk();
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="しゃがみ中攻撃" });
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}
Std_MoveTable.Mv_Atk_CroC <- 
{
	function Init_Std()
	{
		Battle_Std.InitGroundAtk( { type="C" } ); //通常攻撃共通Init
		//Battle_Std.MoveCode.AddFlag( def_MC_NoJumpCansel ); // 行動コード(通常ＣでもＪＣ不可)を設定

		BMvTbl.SetComboLimit(DEF_BS_CL_CROC);
		BMvTbl.SetPattern(def_PAT_Atk_CroC);
	}
	function Start_Std()
	{
		Battle_Std.StartGroundAtk();
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="しゃがみ強攻撃" });
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}

//ジャンプ攻撃着地に与えるヒットステータス
local set_AirAtkLandStatus = function()
{
	local hitst = BMvTbl.GetMvHitStatus();
	if( hitst.Type&_HitType_Damage ) //ダメージ与えていたら
	{
		Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_Damage );
	}
	else if( hitst.Type&_HitType_Guard ) //ガードされていたら
	{
		Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_Guard );
	}

}

// ジャンプ通常技
Std_MoveTable.Mv_Atk_AirA <- 
{
	function Init_Std()
	{
		Battle_Std.InitAirAtk( { type="A" } ); //通常攻撃共通Init
		Battle_Std.MoveCode.AddFlag( def_MC_GRDLowBreak ); // GRDブレイクの効果が短いMv
		
		Battle_Std.SetStatus_AirAtkStatus(); //ジャンプ攻撃の各種フラグをリセット＋立てる
		
		BMvTbl.SetComboLimit(DEF_BS_CL_AIRA);
		BMvTbl.SetPattern(def_PAT_Atk_AirA);
	}
	function Start_Std()
	{
		Battle_Std.StartAirAtk();
	}	
	function FrameUpdate_Std() : (set_AirAtkLandStatus)
	{
		Battle_Std.TypeSE_Play({ type="ジャンプ弱攻撃" });
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			set_AirAtkLandStatus(); // def_PP_AirAtkStatus に着地情報を入れる
			BMvTbl.SetFinalize(256); //着地したらLandへ
		}
		Battle_Std.CheckAirAtkFsiki(); // 切り替え中段は上段に変更
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Atk_AirA_Land"] ); //デフォ,[code,mv]...
	}
	function GetFinalizeCode_Std()
	{
		return [ [0,"Mv_Neutral"], [256,"Mv_Atk_AirA_Land"] ];//XXX:256はやめる
	}
}

local set_AirAtk_LandMoveableFrame = function( nohit, shield, damage, guard, a_nohit, a_shield, a_damage, a_guard )
{
	local atkst = BMvTbl.GetPP(def_PP_AirAtkStatus);
	
	if( atkst&def_PP_AAS_Shielded ) //シールドされた
	{
		local frame = (atkst&def_PP_AAS_inAssault)? a_shield : shield;
		BMvTbl.SetMoveableFlag( { move=0, time=frame, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );		
	}
	else if( !(atkst&def_PP_AAS_Hit) ) //空振りした（ヒットorガードしなかった）
	{
		local frame = (atkst&def_PP_AAS_inAssault)? a_nohit : nohit;
		BMvTbl.SetMoveableFlag( { move=0, time=frame, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
	}
	else if( atkst&def_PP_AAS_Damage ) //ダメージを与えた
	{
		local frame = (atkst&def_PP_AAS_inAssault)? a_damage : damage;
		BMvTbl.SetMoveableFlag( { move=0, time=frame, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );		
	}
	else if( atkst&def_PP_AAS_Guard ) //ガードされた
	{
		local frame = (atkst&def_PP_AAS_inAssault)? a_guard : guard;
		BMvTbl.SetMoveableFlag( { move=0, time=frame, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );		
	}
	BMvTbl.SetPP(def_PP_AirAtkStatus,0); //ジャンプ攻撃ステータス初期化
}

Std_MoveTable.Mv_Atk_AirA_Land <- 
{
	function Init_Std() : (set_AirAtk_LandMoveableFrame)
	{
		Battle_Std.InitAitAtkLand();
		
		set_AirAtk_LandMoveableFrame(			//着地硬直を設定
		def_FL_AtkAirA_LandRecovery,			//空振りした
		def_FL_AtkAirA_LandRecovery_Shielded,	//シールドされた
		def_FL_AtkAirA_LandRecovery_Damage,		//ダメージを与えた
		def_FL_AtkAirA_LandRecovery_Guard,		//ガードされた
		def_FL_AtkAirA_LandRecovery_Assault		//アサルトから出して空振りした
		def_FL_AtkAirA_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
		def_FL_AtkAirA_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
		def_FL_AtkAirA_LandRecovery_AssaultGuard		//アサルトから出してガードされた
		);
	}
	function FrameUpdate_Std()
	{
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

Std_MoveTable.Mv_Atk_AirB <- 
{
	function Init_Std()
	{
		Battle_Std.InitAirAtk( { type="B" } ); //通常攻撃共通Init

		Battle_Std.SetStatus_AirAtkStatus(); //ジャンプ攻撃の各種フラグをリセット＋立てる
	
		BMvTbl.SetComboLimit(DEF_BS_CL_AIRB);
		BMvTbl.SetPattern(def_PAT_Atk_AirB);
	}
	function Start_Std()
	{
		Battle_Std.StartAirAtk();
	}	
	function FrameUpdate_Std() : (set_AirAtkLandStatus)
	{
		Battle_Std.TypeSE_Play({ type="ジャンプ中攻撃" });
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			set_AirAtkLandStatus(); // def_PP_AirAtkStatus に着地情報を入れる
			BMvTbl.SetFinalize(256); //着地したらLandへ
		}
		Battle_Std.CheckAirAtkFsiki(); // 切り替え中段は上段に変更
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Atk_AirB_Land"] ); //デフォ,[code,mv]...
	}
	function GetFinalizeCode_Std()
	{
		return [ [0,"Mv_Neutral"], [256,"Mv_Atk_AirB_Land"] ];//XXX:256はやめる
	}
}

Std_MoveTable.Mv_Atk_AirB_Land <- 
{
	function Init_Std() : (set_AirAtk_LandMoveableFrame)
	{
		Battle_Std.InitAitAtkLand();
		
		set_AirAtk_LandMoveableFrame(			//着地硬直を設定
		def_FL_AtkAirB_LandRecovery,			//空振りした
		def_FL_AtkAirB_LandRecovery_Shielded,	//シールドされた
		def_FL_AtkAirB_LandRecovery_Damage,		//ダメージを与えた
		def_FL_AtkAirB_LandRecovery_Guard,		//ガードされた
		def_FL_AtkAirB_LandRecovery_Assault		//アサルトから出して空振りした
		def_FL_AtkAirB_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
		def_FL_AtkAirB_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
		def_FL_AtkAirB_LandRecovery_AssaultGuard		//アサルトから出してガードされた
		);	
	}
	function FrameUpdate_Std()
	{
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

Std_MoveTable.Mv_Atk_AirC <- 
{
	function Init_Std()
	{
		Battle_Std.InitAirAtk( { type="C" } ); //通常攻撃共通Init

		Battle_Std.SetStatus_AirAtkStatus(); //ジャンプ攻撃の各種フラグをリセット＋立てる
	
		BMvTbl.SetComboLimit(DEF_BS_CL_AIRC);
		BMvTbl.SetPattern(def_PAT_Atk_AirC);
	}
	function Start_Std()
	{
		Battle_Std.StartAirAtk();
	}	
	function FrameUpdate_Std() : (set_AirAtkLandStatus)
	{
		Battle_Std.TypeSE_Play({ type="ジャンプ強攻撃" });
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			set_AirAtkLandStatus(); // def_PP_AirAtkStatus に着地情報を入れる
			BMvTbl.SetFinalize(256); //着地したらLandへ
		}
		Battle_Std.CheckAirAtkFsiki(); // 切り替え中段は上段に変更
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Atk_AirC_Land"] ); //デフォ,[code,mv]...
	}
	function GetFinalizeCode_Std()
	{
		return [ [0,"Mv_Neutral"], [256,"Mv_Atk_AirC_Land"] ];//XXX:256はやめる
	}
}

Std_MoveTable.Mv_Atk_AirC_Land <- 
{
	function Init_Std() : (set_AirAtk_LandMoveableFrame)
	{
		Battle_Std.InitAitAtkLand();
		
		set_AirAtk_LandMoveableFrame(			//着地硬直を設定
		def_FL_AtkAirC_LandRecovery,			//空振りした
		def_FL_AtkAirC_LandRecovery_Shielded,	//シールドされた
		def_FL_AtkAirC_LandRecovery_Damage,		//ダメージを与えた
		def_FL_AtkAirC_LandRecovery_Guard,		//ガードされた
		def_FL_AtkAirC_LandRecovery_Assault		//アサルトから出して空振りした
		def_FL_AtkAirC_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
		def_FL_AtkAirC_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
		def_FL_AtkAirC_LandRecovery_AssaultGuard		//アサルトから出してガードされた
		);		
	}
	function FrameUpdate_Std()
	{
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}


// ダッシュ通常技
Std_MoveTable.Mv_Atk_DashStdB <- 
{
	function Init_Std()
	{
		Battle_Std.InitDashAtk(def_PAT_Atk_DashStdB);
	}
	function Start_Std()
	{
		Battle_Std.StartDashAtk();
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="ダッシュ中攻撃" });
	}
	function LastUpdate_Std()
	{
		BMvEff.PcAfterImage_Clear(); //残像の消去
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}
Std_MoveTable.Mv_Atk_DashStdC <- 
{
	function Init_Std()
	{
		Battle_Std.InitDashAtk(def_PAT_Atk_DashStdC);
	}
	function Start_Std()
	{
		Battle_Std.StartDashAtk();
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="ダッシュ強攻撃" });
	}
	function LastUpdate_Std()
	{
		BMvEff.PcAfterImage_Clear(); //残像の消去
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.Mv_Dash_F_KazeEff <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove  | _ObjFlags_NoRender|_ObjFlags_EraseParentPatChange } );
		//BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPattern(990);
		
		BMvTbl.SetLP(0,0);
		BMvTbl.SetLP(1,0);
	}
	function FrameUpdate_Std()
	{
		local pmv = Battle_Std.GetPlayerMvName();
		if( pmv != "Mv_Dash_F" && pmv != "Mv_DashWait_F" )
		{
			BMvTbl.SetFinalize(0);
			return;
		}	
	
		local cnt = BMvTbl.GetLP(1);
		BMvTbl.AddLP(1,1); //カウンタ勧める
		
		if( cnt>5 && cnt%10==0 ) //おそらくそろそろ走ってる＆一定時間おき
		{
			Battle_Std.CreateObjectEX( { datatype=1, pat="Dash_Kaze", FrameID=[1,2], flags=_Position_ToolShift,
			objectflags=_ObjFlags_EraseParentPatChange
			} );
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

// A+Bで出したときに経由する
Std_MoveTable.Mv_DirectSSSkill <-
{
	function Init_Std()
	{
		BMvTbl.SetFinalize();
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable("Mv_Skill_SSRelayAtk");
	}
}

// Mv名見て色々やってるので注意
Std_MoveTable.Mv_Skill_SSRelayAtk <-
{
	// SkillだとInit_Stdに書いても動かないのでBeforeに記述している
	// TODO:※作りが強引すぎるのでできれば直したい
	function GetCPLevel()
	{
		local ret_lv = 0;
		local cp = BMvTbl.ComboPoint_Calc( { num=0 } ); // 今のCPを取得
		local isOnce = BMvTbl.HitPat_Check( { num = BMvTbl.GetMvStatus().DataPattern } );
		if( isOnce )
		{
			ret_lv = 0;
		}
		else if( cp >= 65 )
		{
			ret_lv = 3;
		}
		else if( cp >= 36 )
		{
			ret_lv = 2;
		}
		else if( cp >= 22 )
		{
			ret_lv = 1;
		}
		else
		{
			ret_lv = 0;
		}
		return ret_lv;
	}
	function GetKyoriHosei( hmax=85 )
	{
		local kyori = Battle_Std.GetEnemyDistance() / 128;
		
		local xmin = 350;
		local xmax = 600; // 800
		local hmin = 100;
		//local hmax = 85; // 85
		
		if( kyori >= xmin )
		{
			local sa = kyori - xmin; // 
			local val = hmin - ( sa * (hmin - hmax) / (xmax - xmin) );
			if( val < hmax ) val = hmax;
			_dpn("距離補正:"+val+" 距離:"+kyori);
			return val;
		}
		return 100;
	}
	function Init_Before()
	{
		local isDirectSS = 0; // A+Bで直接だしたとき
		if( BMvTbl.ChangeMv_GetMvName() == "Mv_DirectSSSkill" )
		{
			isDirectSS = 1;
		}
		
		if( isDirectSS )
		{
			// CVOの同時押し猶予のために必要
			// これを入れるとボーナス補正をかけつつCVOにいきかねないので気をつける
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
		}
		
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GuardChainShiftOK ); //ガード時CS可能
		// Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_NoWhiffEXCancel ); // 空振りEXやCSを不可　※保険処理　これがあるとCVOが出ない
		// Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_ShieldSteady ); // シールドされても隙が増えにくい技
		
		// XXX:EX技扱いにしているせいでEX技の同技補正の制限を受けてしまうのを応急措置的に対応
		Battle_Std.MoveCodeEx.AddFlag( 6, def_MC6_NoSetUseExSkillFlag ); // EX技扱いだがEX技の保証補正制限はかけない
		
		BMvTbl.SetLPEx(1,0,0); // 補正を適用済みかどうか
		BMvTbl.SetLPEx(1,1,isDirectSS); // ABで直接出したかどうか　※キャラ別で参照してることもあるので変更不可
		
		BMvTbl.SetForceUkemiTimeLimitFlag( { val=31, time=255, flag=_ClearFlag_ChangeMv } );
	}
	function Start_Before() : (SS_ratio, SteerEnderStoptime) // SkillなのでBefore
	{
		// Initで暗転処理をしてしまうと同時押しの猶予がなくなってしまう
		
		local isDirectSS = BMvTbl.GetLPEx(1,1);
		
		local flash_color = ( isDirectSS )? 0x660022 : 0x660022; // 同じ
		BMvEff.SetCharaFlash( { color = flash_color, type = 0, time = 60 } );
		
		// 残像発生
		BMvEff.PcAfterImage_Set( { type=1, range=14, delay=2, color=0xDDCCCCFF, blendmode=1 } ); // 残像の開始
		
		// 暗転処理
		//相手に、暗転後動けるようになると消えるオブジェクトを呼ぶ
		Battle_Std.CallAntenStopObject();
		
		local stoptime = ( isDirectSS )? SteerEnderStoptime[0] : SteerEnderStoptime[1]; //暗転停止時間
		if( stoptime > 0 )
		{
			BMvEff.SetStopTime( { time=stoptime } ); //時間停止
			BMvEff.CutInProc_Set({ time=[3,stoptime+4,10], cutin_mv="",erasetype=0, bgtype=1 }); // ちょい長めで演出強化
		}
		
		BMvEff.CreateObject( { datatype=1, start_pat="Eff_SS_Skill", x=0, y=-200*128 } ); // 発動エフェクト
		
		if( Def_Sys_SSRelayType )
		{
			// やられ中のみ増やす。ガードの上から増えていくのはよくない
			// 厳密にはこのチェックだとよくない気もするが、基本的には問題ないのでOKにした
			if( isDirectSS )
			{
				// CPに応じてGRDをゲット
				// CPが少ないとGRDは逆に減る
				local add_grd = 0;
				local sub_grd = 0;
				local cp_level = GetCPLevel(); // 0〜3
				if( cp_level == 3 )
				{
					add_grd = 20000;
				}
				else if( cp_level == 2 )
				{
					add_grd = 10000;
				}
				else if( cp_level == 1 )
				{
					add_grd = 0;
					sub_grd = 0;
				}
				else
				{
					add_grd = 0;
					sub_grd = 1;
				}
				
				add_grd = add_grd * GetKyoriHosei(50) / 100;
				
				// 特殊なときだけボーナス
				if( add_grd && Battle_Std.CheckEnemyisDamage() ) // 相手やられ中のみボーナス発生
				{
					_dpn("GRD増加:"+add_grd);
					Battle_Std.GRD_AddValue({ val=Battle_Std.GetGRD_AddValue(add_grd), pressure=0 }); // 流石に後半は増えにくい
					
					// アナウンスはごちゃごちゃするので一旦廃止
					// BMvEff.AttackInfoString_Set({ word=def_AISW_SwiftBonus,} ); // アナウンスを入れる
				}
				
				// CPがきついときはペナルティがある
				// FFと同じ扱いな感じ（厳密にはVPとかが違う）
				if( sub_grd )
				{
					_dpn("GRD減少:"+sub_grd);
					Battle_Std.UseGRDStock( 1, 10000 ); // 消費GRD数, 相手増加GRD値(単位違注意)
					// Battle_Std.GRD_AddValue( { val= sub_grd, boundplus=1 } );
				}
			}
			else
			{
				// 固定のボーナス
				// GRDの増加を入れる
				Battle_Std.GRD_AddValue({ val=def_GRD_SSkill_SmartSteer, pressure=0, boundplus=1 });
			}
		}
	}
	function Update_Before() : (SS_ratio) // SkillなのでBefore
	{
		if( Battle_Std.MoveCodeEx.CheckFlag( 3, def_MC3_AfterFrameUpdateStartTiming ) )
		{
			local isDirectSS = BMvTbl.GetLPEx(1,1);
			if( BMvTbl.GetLPEx(1,0) == 0 )
			{
				local mvs = BMvTbl.GetMvStatus();
				// 飛び道具系の多段技からキャンセルするとすぐに補正がかかって飛び道具のダメージが増えてしまうので攻撃直前に補正をかける
				if( mvs.MvCount>=SS_ratio[2] )
				{
					BMvTbl.SetLPEx(1,0,1); // 補正を適用済みかどうか
					if( Battle_Std.CheckEnemyisDamage() ) // 相手がダメージ中のみ補正を適用する
					{
						if( isDirectSS )
						{
							local totaldamage = BMvTbl.GetComboInfo(1);//現在のコンボダメージ
							
							// 残りCPに応じたボーナスが入る
							local bonus_hosei = 100;
							
							local add_bonus_hosei = 0;
							local cp_level = GetCPLevel(); // 0〜3
							if( cp_level == 3 )
							{
								bonus_hosei = 150;
							}
							else if( cp_level == 2 )
							{
								bonus_hosei = 140;
							}
							else if( cp_level == 1 )
							{
								bonus_hosei = 120;
							}
							
							// 2300ぐらいのダメージで収束させる
							// 基礎ダメージ1700ぐらい
							// 攻撃前のコンボダメージが1000が最大として、それより先はボーナスは収束する
							// 2000ダメージが下限…みたいな計算をする
							local maxBonusComboDamage = 1000;
							local overDamageLength = 1300;
							if( totaldamage > maxBonusComboDamage )
							{
								local over_val = totaldamage - maxBonusComboDamage; // 越えた分
								if( over_val > overDamageLength ) over_val = overDamageLength; // 1000+1000で2000を最大とする
								
								// over_val:0〜1000(overDamageLength)

								local par = over_val * 100 / overDamageLength; // どれだけ超えているか。100なら2000コンボダメージ
								
								local minus_hosei = -30 * par / 100;
								
								_dpn("オーバー:"+over_val+" 割合:"+par+" : "+bonus_hosei+""+minus_hosei+"->"+(bonus_hosei+minus_hosei) );

								bonus_hosei = bonus_hosei + minus_hosei;
							}
							
							
							// 距離補正を強めにかける
							local kyori_hosei = GetKyoriHosei(85);
							bonus_hosei = bonus_hosei * kyori_hosei / 100;
							
							if( bonus_hosei )
							{
								_dpn("SS Directボーナス補正:"+bonus_hosei);
								BMvEff.ComboView_Set( { val=bonus_hosei, type=1 } ); // 補正を乗算
							}
						}
						else
						{
							_dpn("SS 補正を適用:"+SS_ratio[0]);
							
							BMvEff.ComboView_Set( { val=SS_ratio[0], type=1 } ); // 補正を乗算
						}
					}
				}
			}
		}
	}
	function HitInterrupt_Before() : (SS_DamageLockParams)
	{
		if( Battle_Std.CheckDamageTiming() && SS_DamageLockParams )
		{
			/*
			// デバッグ用処理
			if( Def_Dbg_LocalDebugMode )
			{
				local posst = BMvEff.GetPointStatus( { target=BMvCore.GetEnemyCharaData() } );
				local point = { x= posst.pos_x * BMvTbl.GetMuki(), y = posst.pos_y };
				// _dpn("ヒット時の相手座標:"+point.x/128+", "+point.y/128);
			}
			*/
			local frameID = BMvTbl.GetMvStatus().FrameID;
			if( frameID in SS_DamageLockParams && SS_DamageLockParams[frameID] )
			{
				Battle_Std.SetPosition_DamageHanteiRect( SS_DamageLockParams[frameID] );
			}
			else
			{
				Battle_Std.SetPosition_DamageHanteiRect( SS_DamageLockParams );
			}
		}
	}
	function LastUpdate_Before() : (SS_ratio) // SkillなのでBefore
	{
		BMvEff.PcAfterImage_Clear(); // 残像消去
		local is_mvchange = SS_ratio[3]; // Mv移行するかどうか
		if( !is_mvchange )
		{
			// Mv移行しない技なら追撃不能にする(移行する技は個別に対応)
			Battle_Std.NoCansel_NoAttackHit( { no_zurasi_hosei = 1 } ); //何かでキャンセルしなかった場合追撃不能にする
		}
		
		/*
		// デバッグ用処理
		if( Def_Dbg_LocalDebugMode )
		{
			local posst = BMvEff.GetPointStatus( { target=BMvCore.GetEnemyCharaData() } );
			local point = { x= posst.pos_x * BMvTbl.GetMuki(), y = posst.pos_y };
			_dpn("技後の相手との距離:"+point.x/128+", "+point.y/128);
		}
		*/
	}
}


local dashwait_frame = chrparam.Get( { type="ダッシュでかかり硬直Ｆ", chrnum=_ChrNo } );
local dashstop_frame = chrparam.Get( { type="ダッシュ停止不能Ｆ", chrnum=_ChrNo } );
local dashStopKanseiAr = chrparam.Get( { type="ダッシュ停止慣性", chrnum=_ChrNo } );
local dashStopKanseiParam = { val = dashStopKanseiAr[0], frame = dashStopKanseiAr[1], max_vec = dashStopKanseiAr[2], max_add = dashStopKanseiAr[3] };


//デバッグ用ダッシュのフレーム監視
Std_MoveTable.Mv_Null_DashFrameChecker <-
{
	function Init_Std() : (dashwait_frame)
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove  | _ObjFlags_NoRender|_ObjFlags_EraseParentPatChange } );
		BMvEff.SetExist( { level = _Exist_NoHantei } )

		//使ったので初期化
		//LP0 0:でかかり硬直　10:移動中（行動可能・ガード不能） 20:移動中（行動可能・ガード可能）
		BMvTbl.SetLP(0,0); //モード
		BMvTbl.SetLP(5,0); //でかかり硬直フレーム
		BMvTbl.SetLP(6,0); //ガード可能になるまでのフレーム
		BMvTbl.SetLP(7,0); //手動停止できるダッシュかどうか
	}
	function FrameUpdate_Std() : (dashstop_frame)
	{
		local player = BMvCore.GetPlayerCharaData();
		if( player.IsDone == 0 ) return; //有効でなかったらすぐ終わる
		
		local push_ok = 0;
		
		local s = BMvTbl.GetMvStatus();
		local skill;
		local rundush = 0;
		
		local mode = BMvTbl.GetLP(0);
		
		if( BMvCore.PushCharaData( player ) )
		{
			//行動不能→行動可能をチェック
			//LP0 0:でかかり硬直　10:移動中（行動可能・ガード不能） 20:移動中（行動可能・ガード可能）
			push_ok = 1;
			
			skill = BCMDTbl.CheckCancel( _SkillType_None );
			
			//FrameIDが100だと途中で停止できるタイプのダッシュなんだ
			local oyas = BMvTbl.GetMvStatus();
			if( oyas.FrameID == 100 ) rundush = 1;
		}
		BMvCore.PopCharaData();
		
		if( push_ok == 0 ) return; //pushできなかったらすぐ終わる
		
		// print( format("\n MvCount:%d mode:%d LP5:%d LP6:%d LP7:%d",s.MvCount, mode, BMvTbl.GetLP(5), BMvTbl.GetLP(6), BMvTbl.GetLP(7) ) );
		
		if( rundush == 1 ) BMvTbl.SetLP(7,1); //停止できるダッシュなのを記憶
			
		//print("\n mode:"+mode+" skill:"+skill);
		switch( mode )
		{
		case 0: //でかかり硬直
			if( skill==255 )
			{
				BMvTbl.SetLP(0,10); //行動可能になったので移動中にmode移行
				BMvTbl.SetLP(5,s.MvCount); //でかかり硬直フレームを記憶
			}
			break;
		case 10: //移動中
			local startup_frame = BMvTbl.GetLP(5); //でかかり硬直が入っているはず
			BMvTbl.SetLP(0,20); //もうガードできるフレームまできたね
			BMvTbl.SetLP(6,s.MvCount); //ガード可能になるまでのフレームを記憶

			if( skill!=255 )
			{
				_dem("【警告】ダッシュ移動中に行動不能");
				BMvTbl.SetLP(0,90); //行動不能になったよ。おかしいね。
			}
			break;
		case 20: //移動中（ガード可）
			BMvTbl.SetFinalize();
			break;
		case 90: //なんかまずそうなとき
			BMvTbl.SetFinalize();
			break;
		}
		
	}
	function Finalize_Std() : (dashstop_frame)
	{
		local startup = BMvTbl.GetLP(5);
		local noguard = BMvTbl.GetLP(6);
		local stop = dashstop_frame;
		local str = "";
		if( BMvTbl.GetLP(7)==1 )
		{
			str = format("\nダッシュ硬直:%2dF (停止まで+%2dF) \n出だしからガード可能まで:%2dF",startup,stop,noguard);
		}
		else
		{
			str = format("\nダッシュ硬直:%2dF\n出だしからガード可能まで:%2dF",startup,noguard);		
		}
		_dp1p( str ); //結果を出力

		BMvTbl.SetDeleteMoveTable();
	}
}

// 66ダッシュもしくはボタンダッシュで生成される
Std_MoveTable.Mv_Null_CheckDashStickHold <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		
		Battle_Std.GS_DelFlag( def_PP_GS_DashStickHoldEnd );
		
		BMvTbl.SetLP(0,0); // このMVが生まれてからの0606を検知する用　100:0606を検知した
		BMvTbl.SetLP(1,0); // コマンドの受付時間
	}
	function Update_Std()
	{
		if( Def_Sys_EasyDashAtkCommandAfterDash )
		{
			if( BMvTbl.GetLP(0)!=100 )
			{
				if( BMvTbl.GetLP(1)>0 )
				{
					BMvTbl.AddLP(1,-1);
				}
				else
				{
					BMvTbl.SetLP(0,0); // コマンド初期状態へ
					BMvTbl.SetLP(1,0); // 一応初期化
				}
			}
		}
	}
	function FrameUpdate_Std()
	{
		local dashCmdStatus = BMvTbl.GetLP(0); // 0606の検知用
		
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local mvcheck = Battle_Std.IsMatchMvNameArray( ["Mv_DashWait_F","Mv_Dash_F","Mv_DashStop_F"] );
			
			if( !BMvTbl.CheckStickHold( (1<<6) | (1<<3) ) )	// 6か3にはいっていなかったら
			{
				if( dashCmdStatus != 100 ) // もう0606検知っぽかったらやらない
				{
					Battle_Std.GS_AddFlag( def_PP_GS_DashStickHoldEnd );
				}
			}
			local stick = BMvTbl.GetStickHold();
			
			player.pop();
			
			
			if( Def_Sys_EasyDashAtkCommandAfterDash )
			{
				// ダッシュ後Nに入るとダッシュ攻撃が不可能になるが、0606っぽい操作を再度検知した場合はそのフラグを消す
				// ダッシュ>66Bみたいな操作をしたとき、内部的にはダッシュ後Nを入れてるのでダッシュ攻撃が出ない
				// CLRに寄せるためこういう処理を追加した
				switch( BMvTbl.GetLP(0) )
				{
				case 0:
					if( stick == 0 )
					{
						// _dpn("0");
						BMvTbl.SetLP(0,10);
						BMvTbl.SetLP(1,8); // コマンドの受付時間
					}
					break;
				case 10:
					if( stick == 6 )
					{
						// _dpn("06");
						BMvTbl.SetLP(0,20);
						BMvTbl.SetLP(1,8); // コマンドの受付時間
					}
					break;
				case 20:
					if( stick == 0 )
					{
						// 0606まで検知すると、0606+Bをビタでやったとき駄目なのでこうした
						// _dpn("060　…　もうダッシュ攻撃にする");
						BMvTbl.SetLP(0,100);
						Battle_Std.GS_DelFlag( def_PP_GS_DashStickHoldEnd ); // フラグを消す
					}
					break;
				case 100:
					break;
				}
			}
			
			if( !mvcheck ) BMvTbl.SetFinalize( 0 ); // 消える
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		Battle_Std.GS_DelFlag( def_PP_GS_DashStickHoldEnd );
	}
}

Std_MoveTable.Mv_DashWait_F <- // 前ダッシュでかかり硬直
{
	function Init_Std() // 
	{
		// _dp("\n Mv_DashWait_F Init()");
		Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Dash_F);
		BMvEff.CreateObject( { mvname="Mv_DashCountObject" } ); //ダッシュカウンタ管理
		BMvEff.CreateObject( { mvname="Mv_Null_CheckDashStickHold" } ); //ダッシュ中にレバーを前入れっぱなしにしているか
		
		local isBtnDash = ( BMvTbl.GetCmdNumber()==def_CN_Dash_F_Douji )? 1 : 0;
		BMvTbl.SetLP(9,isBtnDash); // 記憶
		if( isBtnDash )
		{
			_dp("\n ボタンダッシュでかかり");
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GenFlag ); // ボタンダッシュ
		}
		
		if( Def_Dbg_LocalDebugMode )
		{
			BMvEff.CreateObject( { mvname="Mv_Null_DashFrameChecker" } ); //ダッシュのフレームチェックオブジェクト
		}
		
		//ダッシュ風呼び
		local posy = -100; //風エフェクトのＹ座標
		local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		if( rc.sx != _Hantei_Error ) // 特殊判定があったらその高さから出す
		{
			posy = rc.sy;
		}
		BMvEff.CreateObject( { x=50, y=posy, mvname="Mv_Dash_F_KazeEff", datatype=1, flags=_Position_ToolShift } );
		
		//でかかり硬直は行動可能にする
		BMvTbl.SetMoveableFlag( { move=1, time=64, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		
		//ボイス再生
		Battle_Std.TypeSE_Play({ type="前ダッシュ" });
		
		// 停止ジャンプ先の絵を予約
		local stopframe = BMvEff.GetFrameIDNum( 256 );
		if( stopframe != -1 ) // FrameIDがあるかどうか
		{
			BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Dash_F, frame=stopframe, rest=4 } );
		}
		
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_DashKansei ); // ダッシュ慣性フラグをつける
	}
	function FrameUpdate_Std() : (dashwait_frame)
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount >= dashwait_frame ) BMvTbl.SetFinalize(0);
	}
	function LastUpdate_Std() : (dashStopKanseiParam)//ダッシュから抜けるときに呼ぶ
	{
		if( !BMvTbl.FromFinalize() )
		{
			// LastUpdateタイミングでベクトル与えるときはやられ中かチェックする
			// つかまれ時のBound_Captureだとベクトル初期化がされないので動きっぱなしになる
			if( Battle_Std.CheckPlayerisBound() ) return; // バウンド時はなし
		
			local xvec = 1500;
			BMvTbl.SetVector( { x=xvec, addx=-(xvec/dashStopKanseiParam.frame),flags=_Vector_DivKeep } ); // 収束でダッシュ慣性を登録
		}
	}	
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Dash_F" );
	}		
}

Std_MoveTable.Mv_Dash_F <- // 前ダッシュ移動部分
{
	function Init_Std() // 
	{
		// BMvEff.CreateObject( { mvname="Mv_DashCountObject" } ); //ダッシュカウンタ管理
		
		// BMvTbl.SetLP(9,0); // ボタンダッシュかどうか
		if( BMvTbl.GetLP(9)==1 )
		{
			// ボタンダッシュ
			_dp("\n ボタンダッシュ");
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GenFlag ); // ボタンダッシュ
		}

		Battle_Std.Call_FootStepSE(); // //足音再生監視オブジェクト
		
		Battle_Std.PassBeforeMoveCodeEx( 2, def_MC2_DashKansei ); // ダッシュ慣性フラグを引き継ぐ
	}
	function FrameUpdate_Std() : ( dashstop_frame)
	{
		Battle_Std.CallLoopEndCache_FrameID( def_PAT_Dash_F, 256, 10 ); // キャッシュ予約Pat, 予約FrameID, 何F毎に呼ぶか
		
		local mvs = BMvTbl.GetMvStatus();
		
		//FrameIDが100だと途中で停止できるタイプのダッシュ(ダッシュ停止不能Ｆが-1ならそも停止不可)
		if( dashstop_frame != -1 && mvs.FrameID == 100 && mvs.MvCount>dashstop_frame) // ホールド可
		{
			if( !BMvTbl.CheckStickHold( (1<<6) | (1<<3) ) )	// 6か3にはいっていなかったら
			{
				BMvTbl.SetFinalize(0);
			}
		}
		if( mvs.FrameID == 256 ) // 停止まできちゃった
		{
			BMvTbl.SetFinalize(0);
		}		
		
		//移動中行動可能にする（ダッシュの時間が分からないのでループにいれてる）
		BMvTbl.SetMoveableFlag( { move=1, time=2, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
	}
	function LastUpdate_Std() : (dashStopKanseiParam)//ダッシュから抜けるときに呼ぶ
	{
		// LastUpdateタイミングでベクトル与えるときはやられ中かチェックする
		// つかまれ時のBound_Captureだとベクトル初期化がされないので動きっぱなしになる
		if( Battle_Std.CheckPlayerisBound() ) return; // バウンド時はなし
	
		local vec = BMvTbl.GetVector(0); //vec に現在のベクトルを格納
		local use_vec_x = vec.x;
		if( dashStopKanseiParam.val != 100 )
		{
			use_vec_x = use_vec_x * dashStopKanseiParam.val / 100; // ダッシュ慣性調整
		}
		
		if( dashStopKanseiParam.max_vec != 0 )
		{
			local mvCount = (BMvTbl.GetMvStatus().MvCount-1);
			if( mvCount < 0 ) mvCount = 0;
			local maxXvec = dashStopKanseiParam.max_vec + (mvCount*dashStopKanseiParam.max_add);
			if( use_vec_x > maxXvec ) use_vec_x = maxXvec;
			
			_dpn("ダッシュ慣性:"+vec.x+" -> "+ use_vec_x+" 収束:"+dashStopKanseiParam.frame+" 制限("+mvCount+"F MAX:"+ maxXvec+")");
		}
		BMvTbl.SetVector( { x=use_vec_x, addx=-(use_vec_x/dashStopKanseiParam.frame),flags=_Vector_DivKeep } ); // 収束でダッシュ慣性を登録
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_DashStop_F" );
	}		
}

Std_MoveTable.Mv_DashStop_F <- // 前ダッシュ停止
{
	function Init_Std() // 
	{
		Battle_Std.JumpFrameIDEX(256, def_PAT_Dash_F, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
		//ダッシュ停止効果音の再生　29
		BSound.SE_Play( { type=_SeType_Normal, num=29 } ); //_SeType_Normal ---汎用 _SeType_Player ---キャラ
		
		//停止は行動可能
		BMvTbl.SetMoveableFlag( { move=1, time=64, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		
		Battle_Std.PassBeforeMoveCodeEx( 2, def_MC2_DashKansei ); // ダッシュ慣性フラグを引き継ぐ
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}		
}		


Std_MoveTable.Mv_DashCountObject <- //ダッシュカウンタを設定・初期化する
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender  } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		if( player.push() )
		{
			BMvEff.StdCall( { type=6, no=102  , param=[ 1,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); //ダッシュカウンタ
			
			player.pop();
		}
		
		BMvTbl.SetLP(0,0); // ダッシュじゃないMvになってから何フレーム経過したか
	}
	function FrameUpdate_Std() // 
	{
		//終了条件
		//ダッシュ以外で行動可能になる
		//ジャンプする
		// _dpn("チェック中");
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		local endflag = false;
		if( player.push())
		{
			local pmvs = BMvTbl.GetMvStatus();
			local isDashMv = Battle_Std.IsMatchMvNameArray( ["Mv_DashWait_F","Mv_Dash_F","Mv_DashStop_F"] );
			local isMovable = BCMDTbl.CheckCancel( _SkillType_None );
			local isAir = BMvTbl.CheckPosState( _PosState_Air );
			player.pop();
			
			//ジャンプしたら終了
			if( isAir ) endflag = true;
			
			//ダッシュ以外の行動になった
			if( !isDashMv )
			{
				//行動可能なら終了
				if( isMovable ) endflag = true;
				
				//ダッシュ以外の行動のまま少したっても終わる
				if( pmvs.CallCount==1 )//1Fに1回
				{
					BMvTbl.AddLP(0,1);//ダッシュ以外の行動時間加算
				}
				if( BMvTbl.GetLP(0)>16 )//16F
				{
					endflag = true;
				}
			}
			else
			{
				//ダッシュ中の行動
				BMvTbl.SetLP(0,0);//ダッシュじゃないMvの時間リセット
			}
		}
		
		if ( endflag )	
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		// _dpn("チェックおわり");
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得	
		if( player.push() )
		{
			BMvEff.StdCall( { type=6, no=103  , param=[ 1,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); //ダッシュカウンタ
			
			player.pop();
		}
		BMvTbl.SetDeleteMoveTable();
	}
}


local dageki_mutekiF = chrparam.Get( { type="バクステ打撃無敵Ｆ", chrnum=_ChrNo } );
local nage_mutekiF = chrparam.Get( { type="バクステ投げ無敵Ｆ", chrnum=_ChrNo } );

Std_MoveTable.Mv_Dash_B <- // バクステ
{
	function Init_Std() :(dageki_mutekiF,nage_mutekiF)
	{
		Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Dash_B);
		BMvEff.SetPlayerTimer( { muteki_nage=nage_mutekiF, muteki_dage=dageki_mutekiF } ); //バクステの無敵時間
		BMvEff.SetPlayerTimer( { muteki_nageX=nage_mutekiF, muteki_dageX=dageki_mutekiF } ); //バクステの無敵時間
		Battle_Std.TypeSE_Play({ type="後ろダッシュ" });
		
		local isReversal = Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		
		// バクステでのGRD減少処理
		if( !Battle_Std.CheckEnemyisDamage() ) // コンボ中はやらない
		{
			if( isReversal ) 
			{
				Battle_Std.GRD_AddValue({ val=def_GRD_ReversalBackDash, pressure=0, boundplus=1 }); // リバサバクステでの減少
			}
			else
			{
				Battle_Std.GRD_AddValue({ val=def_GRD_BackDash, pressure=0, boundplus=1 }); // 通常バクステでの減少
			}
		}
		
		local isBtnDash = ( BMvTbl.GetCmdNumber()==def_CN_Dash_B_Douji )? 1 : 0;
		if( isBtnDash )
		{
			_dp("\n ボタンダッシュ");
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GenFlag ); // ボタンダッシュ		
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}		
}

//シールド呼び出し共通関数
local Call_BarrierEff = function()
{
	local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 1 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
	if( rc.sx != _Hantei_Error ) // 存在するか
	{
		Battle_Std.CreateObjectEX({ x=rc.sx, y=rc.sy, mvname="Mv_BarrierEff", datatype=1, pat=73,
		flags=_Position_ToolShift,
		objectflags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange });
	}
}

//シールドエフェクトのＭｖ
Std_MoveTable.Mv_BarrierEff <-
{
	function Init_Std()
	{
		BMvTbl.SetLP(0,0); //状態。消滅フレームへ進んだかどうか。
	}
	function FrameUpdate_Std()
	{
		//操作親のFrameIDが10の間はループ
		//違ったら消滅フレームへ飛ぶ
		//それ以外にパターン変化とかでも勝手に消える
		local p = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		BMvCore.PushCharaData( p );
			local plmvst = BMvTbl.GetMvStatus();
		BMvCore.PopCharaData();
		if( plmvst.FrameID!=10 && BMvTbl.GetLP(0)==0 )
		{
			BMvTbl.SetLP(0,1); //もう消滅フレームへ進んだ
			BMvTbl.JumpFrameID(900); //消滅フレームへ
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//シールドの処理共通
local Func_Barrier = 
{
	Init = function(pat=def_PAT_Barrier_Std) : (Call_BarrierEff)
	{
		BMvEff.GuardSP_Set( { val=2 } ); //SPガード状態の設定
		
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(pat);
		
		Call_BarrierEff(); //バリアエフェクト呼び出し
		Battle_Std.TypeSE_Play({ type="シールド発動" });	
		
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_ChainShift, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		BMvTbl.SetWallCount(0); // 無敵バグ対策に壁バウンド回数をリセットする
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // 4+DDでCSが出せるようにする		
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
	},
	Update = function(cmd, grd, time)
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( !Battle_Std.CheckEnemyisDamage() && s.MvCount >= def_FL_Shield_GRDPlusStartFrame ) 
		{
			Battle_Std.GRD_AddValue({ val=Battle_Std.GetGRD_AddValue(grd), pressure=0 }); //相手がやられ以外なら増える	
		}
		
		if( BMvTbl.GetFrameID() == 10 ) // ホールド可
		{
			if( ( !BMvTbl.CheckCommandString( cmd ) && s.MvCount>=time ) || (s.MvCount>= def_FL_Shield_MaxTime) )
			{
				if (BMvTbl.JumpFrameID( 20 ) == -1)
				{
					_dem("【警告】飛び先のフレームIDが無い");
					BMvTbl.SetFinalize(0);
				}				
			}			
		}	
	},
	FrameUpdate = function(sp)
	{
		if( Def_Sys_Shield_SubExs )
		{
			Battle_Std.SetSpGauge_BarrierFU( {value=sp,} ); //バリアによるSPゲージ消費	
		}
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	},
	LastUpdate = function()
	{
		BMvEff.GuardSP_Set( { val=0 } ); //SPガード状態の解除
	}
}

//シールド
//レジストガード
Std_MoveTable.Mv_Barrier_Std <- 
{
	function Init_Std() : (Func_Barrier)
	{
		Func_Barrier.Init(def_PAT_Barrier_Std);
		Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
	}
	function Update_Std() : (Func_Barrier)
	{
		Func_Barrier.Update([ "@H,4D@" ], def_GRD_BarrierS_Frame, def_FL_Shield_StdTime);
	}
	function FrameUpdate_Std() : (Func_Barrier)
	{
		Func_Barrier.FrameUpdate(def_SP_BarrierS_Frame);
	}	
	function LastUpdate_Std() : (Func_Barrier)
	{
		Func_Barrier.LastUpdate();
	}
	function Finalize_Std() : (Func_Barrier)
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}			
}

Std_MoveTable.Mv_Barrier_Cro <- 
{
	function Init_Std() : (Func_Barrier)
	{
		Func_Barrier.Init(def_PAT_Barrier_Cro);
		Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
	}
	function Update_Std() : (Func_Barrier)
	{
		Func_Barrier.Update([ "@H,1D@" ], def_GRD_BarrierC_Frame, def_FL_Shield_CroTime);
	}
	function FrameUpdate_Std() : (Func_Barrier)
	{
		Func_Barrier.FrameUpdate(def_SP_BarrierC_Frame);
	}	
	function LastUpdate_Std() : (Func_Barrier)
	{
		Func_Barrier.LastUpdate();
	}
	function Finalize_Std() : (Func_Barrier)
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}			
}

// 空中で立つバグがある
Std_MoveTable.Mv_Barrier_Air <- 
{
	function Init_Std() : (Func_Barrier)
	{
		Func_Barrier.Init(def_PAT_Barrier_Air);
		//着地まで行動不能にする
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } );
	}
	function Update_Std() : (Func_Barrier)
	{
		Func_Barrier.Update([ "@H,471D@" ], def_GRD_BarrierA_Frame, def_FL_Shield_AirTime);
	}
	function FrameUpdate_Std() : (Func_Barrier)
	{
		Func_Barrier.FrameUpdate(def_SP_BarrierA_Frame);
	}	
	function LastUpdate_Std() : (Func_Barrier)
	{
		Func_Barrier.LastUpdate();
		
		//救済措置
		local vec = BMvTbl.GetVector();
		if( vec.y <= 0 && vec.addy <= 0 ) vec.addy = 190;//適当決め打ち
		BMvTbl.SetVector( { addy=vec.addy, flags=_Vector_Normal } );
	}
	function Finalize_Std() : (Func_Barrier)
	{
		Battle_Std.SwitchNextMoveTable("Mv_Barrier_Air_Fall", [256,"Mv_Barrier_Air_Land"] ); //デフォ,[code,mv]...
	}
	function GetFinalizeCode_Std()
	{
		return [ [0,"Mv_Barrier_Air_Fall"],[256,"Mv_Barrier_Air_Land"] ];
	}
}

//空中シールド着地硬直
Std_MoveTable.Mv_Barrier_Air_Land <- 
{
	function Init_Std() // 
	{
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		BMvTbl.SetMoveableFlag( { move=0, time=def_FL_BarrierAir_LandRecovery, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		Battle_Std.InitVector(); //ベクトル初期化
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

//空中シールド終了後の落下部分
Std_MoveTable.Mv_Barrier_Air_Fall <- 
{
	function Init_Std() // 
	{
		// Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // 行動可能に
		BMvTbl.SetPattern( 20 ); // 落下パターン指定
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Barrier_AirFall_Land"] ); //デフォ,[code,mv]...
	}	
}

Std_MoveTable.Mv_Barrier_AirFall_Land <- 
{
	function Init_Std() // 
	{
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		BMvTbl.SetMoveableFlag( { move=0, time=def_FL_BarrierAirFall_LandRecovery, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // 着地硬直
		Battle_Std.InitVector(); //ベクトル初期化
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}






local ground_Assault_AirAtkFrameAr = chrparam.Get( { type="地上アサルト硬直", chrnum=_ChrNo } );

//-1ならデフォ値に書き換える
if( ground_Assault_AirAtkFrameAr[0] == -1 ) ground_Assault_AirAtkFrameAr[0] = 10;
if( ground_Assault_AirAtkFrameAr[1] == -1 ) ground_Assault_AirAtkFrameAr[1] = 10;
if( ground_Assault_AirAtkFrameAr[2] == -1 ) ground_Assault_AirAtkFrameAr[2] = 10;

local air_Assault_AirAtkFrameAr = chrparam.Get( { type="空中アサルト硬直", chrnum=_ChrNo } );

//-1ならデフォ値に書き換える
if( air_Assault_AirAtkFrameAr[0] == -1 ) air_Assault_AirAtkFrameAr[0] = 9;
if( air_Assault_AirAtkFrameAr[1] == -1 ) air_Assault_AirAtkFrameAr[1] = 9;
if( air_Assault_AirAtkFrameAr[2] == -1 ) air_Assault_AirAtkFrameAr[2] = 9;

local all_AssaultStartupFrameAr = chrparam.Get( { type="アサルトでかかりタメ", chrnum=_ChrNo } );

local assault_AirAtkParam =
{
	ground = 
	{
		startup = all_AssaultStartupFrameAr[0],
		min = ground_Assault_AirAtkFrameAr[0],
		a = ground_Assault_AirAtkFrameAr[0],
		b = ground_Assault_AirAtkFrameAr[1],
		c = ground_Assault_AirAtkFrameAr[2],
	},
	air = 
	{
		startup = all_AssaultStartupFrameAr[1],
		min = air_Assault_AirAtkFrameAr[0],
		a = air_Assault_AirAtkFrameAr[0],
		b = air_Assault_AirAtkFrameAr[1],
		c = air_Assault_AirAtkFrameAr[2],
	},
}

//最小フレームを決める
if( assault_AirAtkParam.ground.min > assault_AirAtkParam.ground.b ) assault_AirAtkParam.ground.min = assault_AirAtkParam.ground.b
if( assault_AirAtkParam.ground.min > assault_AirAtkParam.ground.c ) assault_AirAtkParam.ground.min = assault_AirAtkParam.ground.c
if( assault_AirAtkParam.air.min > assault_AirAtkParam.air.b ) assault_AirAtkParam.air.min = assault_AirAtkParam.air.b
if( assault_AirAtkParam.air.min > assault_AirAtkParam.air.c ) assault_AirAtkParam.air.min = assault_AirAtkParam.air.c

//isAir: 0 地上 1:空中 2:ダッジ
//startup: でかかり硬直
//nomove: startup以降から動けるようになるまで
//最速F　startup+nomove+ジャンプ攻撃発生F

local Make_AssaultFU = function(type=0, default_startup=6, nomove=14) : (assault_AirAtkParam)
{
	local isGround = (type==0);
	local isAir = (type==1);
	//local isDudge = (type==2);

	local xvec = (isGround)? 3200 : 2800;
	local xmax = 3200;
	local yvec = (isGround)? -3000 : -2400;
	local yadd = 190;
	
	//LP0 ダッジになったかどうか
	//LP1 type  0:地上 1:空中
	
	local use_assult_param = (isGround)? assault_AirAtkParam.ground : assault_AirAtkParam.air;
	
	local func = function() : (type, default_startup, isGround, isAir, xvec, xmax, yvec, yadd, nomove, use_assult_param)
	{
		// local mvs = BMvTbl.GetMvStatus();
		// local pos = BMvTbl.GetPosition();
		// _dpn(mvs.MvCount+" : "+pos.y/128);
		
		// local startup = default_startup + BMvTbl.GetLP(4); // 低空アサルトのときに少し発生が遅くする遅延F
		local startup = use_assult_param.startup-1 + BMvTbl.GetLP(4); // 低空アサルトのときに少し発生が遅くする遅延F -1Fしているのは処理の都合上
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		switch( s.FrameID )
		{
		case 10: //地上の開始絵
		case 20: //空中の開始絵
			if( s.MvCount>startup )
			{
				BMvTbl.SetLP(1,type); //typeを記憶（ジャンプ攻撃のでかかりでチェック）//もういらないかも
				// if( isAir ) Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_AirAssult );//MvのInitで設定してるので不要
				BMvTbl.SetLP(3,2); // アサルトでとんだのを記憶
				
				BMvTbl.JumpFrameID(30); //飛んでみろ
				if( def_SP_Assault_Init )
				{
					BMvEff.SetSpGauge( {value=def_SP_Assault_Init,} ); //発動でのSP消費
				}
				
				BMvTbl.SetPrio( _CharaPrio_Near ); // アサルトによるプライオリティ手前
				
				//アサルト発動時のＧＲＤ増加
				if( Battle_Std.CheckEnemyisDamage() ) //相手がやられ中
				{
					//やられ中は増加しない
					//print("\n やられ中なので増加しない");
				}
				else
				{
					//それ以外では増加する
					//攻めているときだけ増やしたいので、反対方向にとぼうとしているときは増やさない
					
					if( !BMvTbl.CheckFurimuki() )
					{
						// _dpn("アサルト接近によるGRD増加");
						local addval = Battle_Std.GetGRD_AddValue(def_GRD_Assault_Init)/2;
						Battle_Std.GRD_AddValue({ val=addval, pressure=0, boundplus=0 });
					}
				}
				
				//飛ぶときは慣性を消そう
				Battle_Std.InitVector(); //ベクトル初期化
				
				//ボイス再生
				Battle_Std.TypeSE_Play({ type="アサルト" });

				local use_xvec = xvec;
				
				BMvTbl.SetLP(0,0); //ダッジモーションになったかどうか
				if( Def_Dbg_AssaultAutoVector && isGround )
				{
					//相手までの距離
					local enemy = BMvCore.GetNearEnemyCharaData(); // 相手情報取得
					if( enemy.IsDone ) // 有効かどうか一応チェック
					{
						local posst = BMvEff.GetPointStatus( { target=enemy } ); // 位置情報取得
						
						local muki = BMvTbl.GetMuki();
						// 0〜1.0　相手が右側にいる 1.0〜2.0 相手が左側にいる
						//print("\n muki:"+muki+" angle:"+posst.angle);
						//相手が後ろにいるかどうか
						local isBack = ( muki == 1 && posst.angle >= 1.0 ) || ( muki == -1 && posst.angle <= 1.0 );
						//print("\n isBack:"+isBack);

						use_xvec = posst.distance_x / 24;
						if( use_xvec  > xmax ) use_xvec = xmax;
						if( use_xvec  < 256 || isBack ) use_xvec = 256; //相手が後ろにいたら最小値にする
						
						//ベクトルが少ないときはアサルトだと変なのでダッジモーションを使おう
						if( use_xvec < 1600 )
						{
							BMvTbl.SetPattern(def_PAT_Mv_Assault_Dodge);
							BMvTbl.JumpFrameID(30); //飛んでみろ
							BMvTbl.SetLP(0,1); //ダッジモーションになった
						}
					}
				}
				//print("\nuse_xvec:"+use_xvec);
				
				BMvTbl.SetVector( { x=use_xvec, y=yvec, addx=0, addy=yadd, flags=_Vector_Normal } ); //移動開始
				//BMvTbl.SetVector( { x=2800, y=-3000, addx=0, addy=0, flags=_Vector_Normal } ); //移動開始
				
				local angle = Battle_Std.CCharaVector_GetToolAngle();	

				local eff = BMvEff.CreateObject( { x=0, y=-200, mvname="", datatype=1, start_pat=66, flags=_Position_ToolShift } );
				if( eff.IsDone )
				{
					BMvCore.PushCharaData( eff );
						BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll } );
						BMvTbl.SetAngle({ angle=angle });
					BMvCore.PopCharaData();
				}
				
				if( isGround ) //地上の時だけ
				{
					local use_pat = (BMvTbl.GetLP(0)==0 )? 65 : 64; //通常エフェクトorダッジエフェクト
					local eff = BMvEff.CreateObject( { x=-50, y=0, mvname="", datatype=1, start_pat=use_pat, flags=_Position_ToolShift } );
					if( eff.IsDone )
					{
						BMvCore.PushCharaData( eff );
							BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
						BMvCore.PopCharaData();
					}
				}
				
				BMvTbl.AddAirCount( def_AC_Assault, 1 ); // アサルトカウンタ加算して再度使えないように
				BMvTbl.AddAirJumpCount(1);  //ジャンプ回数を加算し二段ジャンプした扱いにする
				BMvTbl.SetHitCheckFlag( { type=0, val=Def_HitCheckFlag_LightLegs, time=255, flag=_ClearFlag_ChangeMv } ); // 小足無敵にスカる
				
				/*
				Battle_Std.CreateObjectEX( { x=0, y=-200, datatype=1, pat="Assault_Kaze", FrameID=[1,2], flags=_Position_ToolShift,
				objectflags=_ObjFlags_EraseParentPatChange|_ObjFlags_NoGround,
				initfunc = function()
				{
					local angle = 9000;
					BMvTbl.SetAngle({ angle=angle });
					local speed = (-1500-(BMvEff.Random_Limit(2000)))*2.0;
					local v = BMvEff.GetVector_FromAngle( { angle = ((angle+7500)/5000.0), speed = speed } );
					BMvTbl.SetVector( { x=v.x, y=v.y, flags=_Vector_Normal } );
				}
				} );
				*/
			}
			break;
		case 30: //とんでるところループ１
		case 35: //とんでるところループ２　※pat67はループしてない
			if( s.MvCount>(startup+6) ) BMvTbl.JumpFrameID(40);
//			if( s.MvCount>(5+5) && !BMvTbl.CheckButtonHold( (1<<3) ) ) BMvTbl.JumpFrameID(40);
			break;
		case 40:
			//BMvTbl.SetVector( { addy=190, flags=_Vector_Normal } ); //移動開始
		case 45: //この絵から行動可能になる
			if( s.MvCount>(startup+nomove)  )
			{
				BMvTbl.JumpFrameID(100);
				local vec = BMvTbl.GetVector(0);
				
				//print("\n 整数:"+vec.x*70/100);
				//print("\n 小数:"+vec.x*0.7);
				
				vec.x = vec.x * 70 / 100; //整数化:0.7
				if( vec.x>2000 ) vec.x = 2000;
				BMvTbl.SetVector( { x=vec.x, addx=0, addy=190, flags=_Vector_Normal } ); //減速して行動可能に
				BMvTbl.SetCommandLongDelay(1); //受付時間増加（先行入力用）
				BMvTbl.SetLP(3,1); //減速処理やった
			}
			break;
		case 100:
			break;
		}
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地

		// アサルト硬直にキャラ差を付ける処理
		{
			local mvcount = s.MvCount;
			
			// _dp("\n use_assult_param:"+use_assult_param.min+", "+use_assult_param.a+", "+use_assult_param.b+", "+use_assult_param.c );
			//assault_AirAtkParam : JA, JB, JC
			if( mvcount > startup+use_assult_param.min )
			{
				BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
				BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=254, flag=_ClearFlag_ChangeMv } ); // 行動可能だけどガード不能にする
				BMvTbl.SetCommandLongDelay(1); //受付時間増加（先行入力用）
			}
			
			if( mvcount > startup+use_assult_param.a )
			{
				// _dp("\n a");
				Battle_Std.LP_AddFlag(2,1);
			}
			if( mvcount > startup+use_assult_param.b )
			{
				// _dp("\n b");
				Battle_Std.LP_AddFlag(2,2);
			}
			if( mvcount > startup+use_assult_param.c )
			{
				// _dp("\n c:"+mvcount);
				Battle_Std.LP_AddFlag(2,4);
			}
		}
	}
	
	return func; //
}

//アサルトをBaseDataで作り直し
Std_MoveTable.Mv_Assault_Std <-
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);		
		BMvTbl.SetPattern(def_PAT_Mv_Assault_Std);
		BMvTbl.JumpFrameID(10); //地上の開始へ
		Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
		//BMvEff.SetSpGauge( {value=def_SP_Assault_Init,} ); //発動でのSP消費		
		//BMvTbl.SetVector( { x=256, y=-128, addx=0, addy=0, flags=_Vector_Normal } ); //ダッシュ開始ふんばり
		//Battle_Std.TypeSE_Play({ type="アサルト" });
		
		// 6DDでCSできるようにCS可フラグだけ立てる
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_ChainShift, time=6, flag=_ClearFlag_ChangeFrame } );

		BMvTbl.SetLP(0,0); //先行入力チェック用

		BMvTbl.SetLP(2,0); //行動可能フラグ用
		BMvTbl.SetLP(3,0); //減速処理やったかどうか
		
		BMvTbl.SetLP(4,0); // 低空アサルトの発生遅延F
		
		BMvEff.AddSkillCount( _SkillCount_Assult ); // 履歴カウンタを加算
		BMvTbl.SetPrio( _CharaPrio_Near ); // アサルトによるプライオリティ手前
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // ツールでCS可なら空振りCS可能
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
		
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_StdAssult );
		
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_LightLegsMuteki );//小足属性へ空振り予定のMV
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Assault_Land"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		if( Battle_Std.CheckPlayerisBound() ) return; // バウンド時はなし
		
		//アサルトで飛んだ後(LP3==2)にやる
		//ジャンプ攻撃がXベクトル減速を受けないで出てしまうとアレなので、
		//LP3==2でまだ減速していなかったらやる
		if( BMvTbl.FromFinalize()==0 )
		{
			// 減速処理まだやってなくて動こうとしたらやる
			if( BMvTbl.GetLP(3) == 2 )
			{
				// _dpn("減速処理");
				local vec = BMvTbl.GetVector(0);
				
				//print("\n 整数:"+vec.x*70/100);
				//print("\n 小数:"+vec.x*0.7);
				
				vec.x = vec.x * 70 / 100; //整数化:0.7
				if( vec.x>2000 ) vec.x = 2000;
				BMvTbl.SetVector( { x=vec.x, addx=0, addy=190, flags=_Vector_Normal } ); //減速して行動可能に
			}
		}
		local mvs = BMvTbl.GetMvStatus();
		// _dpn("カウント:"+mvs.MvCount);
	}
}

Std_MoveTable.Mv_Assault_Std.FrameUpdate_Std <- Make_AssaultFU(0, 4, 10 );

//アサルト共通着地Mv
Std_MoveTable.Mv_Assault_Land <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=0, time=def_FL_Assault_LandRecovery, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		Battle_Std.InitVector(); //ベクトル初期化
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}	

Std_MoveTable.Mv_Assault_Air <-
{
	function Init_Std() // 
	{
		//現在のベクトルを保存する
		local nowvec = BMvTbl.GetVector(0); // 現在のベクトルを得る（パターン変更後だと初期化されてるかも）
		BMvTbl.SetVector( { x=nowvec.x, addx=nowvec.addx, y=nowvec.y, addy=nowvec.addy, flags=_Vector_Keep } ); //保存
		
		Battle_Std.InitCharaVector(); // 初期化
		
		BMvTbl.SetPattern(def_PAT_Mv_Assault_Air);
		BMvTbl.JumpFrameID(20); //空中の開始へ
		
		//BMvEff.SetSpGauge( {value=def_SP_Assault_Init,} ); //発動でのSP消費
		//Battle_Std.TypeSE_Play({ type="アサルト" });
		
		// 6DDでCSできるようにCS可フラグだけ立てる
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_ChainShift, time=6, flag=_ClearFlag_ChangeFrame } );

		BMvTbl.SetLP(0,0); //先行入力チェック用
		
		BMvTbl.SetLP(2,0); //行動可能フラグ用
		BMvTbl.SetLP(3,0); //減速処理やったかどうか		

		BMvTbl.SetLP(4,0); // 低空アサルトの発生遅延F
		
		if( Def_Sys_EasierLaunchAirAssult )
		{
			local pos = BMvTbl.GetPosition();
			if( pos.y > -def_POS_AirDashLimitHeight )
			{
				// 目標の高さとしては従来のベクトルを基準にしないと、CLRと性能が変わってしまうので調整
				
				local delay_f = 0;
				local jumpF = ( Battle_Std.ChangeMoveCodeEx_CheckFlag( 3, def_MC3_EnableJumpFramePP ) )? BMvTbl.GetPP(def_PP_JumpFrame) : 0;
				if( jumpF != 0 ) delay_f = -1; // 0F経由のズレ対策(この仕様なんなのかよく覚えてないが、多分CLRと揃えている)
				
				/*
				local mvs = BMvTbl.GetMvStatus();
				_dpn("mvs:"+mvs.FrameCallCount+" jumpF:"+jumpF);
				if( mvs.FrameCallCount > 0 )
				{
					delay_f = 1; // 0F経由でのズレ対策
				}
				*/
				
				local target_ypos = pos.y;
				{
					local tmp_vec_y = nowvec.y;
					for( local i=0; i<4; i++ ) // 1F多くしないと計算あわないっぽい
					{
						delay_f++;
						// _dpn("i:"+i+" tmp_vec_y:"+tmp_vec_y+" delay_f:"+delay_f);
						target_ypos += tmp_vec_y;
						tmp_vec_y += nowvec.addy;
						if( target_ypos < -def_POS_AirDashLimitHeight )
						{
							// _dpn("ここまできてたら、本来cmdのチェック通って出せていた高さ＝CLRの高さ");
							break;
						}
					}
				}
				BMvTbl.SetLP(4,delay_f); // 遅延F

				if( target_ypos > -def_POS_AirDashLimitHeight )
				{
					// _dpn("最低保証");
					target_ypos = -def_POS_AirDashLimitHeight;
				}

				// Battle_Std.SetDivKeepVector_AirDashMinHeight(def_POS_AirDashLimitHeight,0); // safeじゃなくしてlastupdate処理に入るように
				Battle_Std.SetDivKeepVector_AirDashMinHeight(-target_ypos,0); // safeじゃなくしてlastupdate処理に入るように
			}
		}
		
		{
			local vec = { x=256, y=-128 };
			local delay_f = BMvTbl.GetLP(4);
			local add_par = 5 * 100 / (5 + delay_f);
			if( add_par < 100 )
			{
				vec.x = vec.x * add_par / 100;
				vec.y = vec.y * add_par / 100;

				// _dpn("add_par:"+add_par+" delay_f:"+delay_f+" vec:"+vec.x+", "+vec.y);
				
			}
			
			BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=0, addy=0, flags=_Vector_Normal } ); //ダッシュ開始ふんばり
		}
		
		BMvEff.AddSkillCount( _SkillCount_Assult ); // 履歴カウンタを加算		
		BMvTbl.SetPrio( _CharaPrio_Near ); // アサルトによるプライオリティ手前
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // ツールでCS可なら空振りCS可能
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
		
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_AirAssult );
		
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_LightLegsMuteki );//小足属性へ空振り予定のMV
		BMvTbl.SetHitCheckFlag( { type=0, val=Def_HitCheckFlag_LightLegs, time=255, flag=_ClearFlag_ChangeMv } ); // 小足無敵にスカる(空中は1Fから)
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Assault_Land"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		// LastUpdateタイミングでベクトル与えるときはやられ中かチェックする
		// つかまれ時のBound_Captureだとベクトル初期化がされないので動きっぱなしになる
		if( Battle_Std.CheckPlayerisBound() ) return; // バウンド時はなし
		
		//アサルトで飛んだ後(LP3==2)にやる
		//ジャンプ攻撃がXベクトル減速を受けないで出てしまうとアレなので、
		//LP3==2でまだ減速していなかったらやる
		if( BMvTbl.FromFinalize()==0 )
		{
			// 減速処理まだやってなくて動こうとしたらやる
			if( BMvTbl.GetLP(3) == 2 )
			{
				// _dpn("減速処理");
				local vec = BMvTbl.GetVector(0);
				
				//print("\n 整数:"+vec.x*70/100);
				//print("\n 小数:"+vec.x*0.7);
				
				vec.x = vec.x * 70 / 100; //整数化:0.7
				if( vec.x>2000 ) vec.x = 2000;
				BMvTbl.SetVector( { x=vec.x, addx=0, addy=190, flags=_Vector_Normal } ); //減速して行動可能に
			}
		}
		
		//でかかり数フレーム目で抜けると上昇してっちまう
		//・自分が空中
		//・addy<=0
		//だったらあがってっちゃうから保存したベクトルで上書きする
		//低空アサルト時のベクトルは考慮しない（DivKeepなので入らないはず）
		local nowvec = BMvTbl.GetVector(0);
		local isAir = ( BMvTbl.CheckPosState(_PosState_Air)!=0 );

		// _dpn("addy:"+nowvec.addy+" isAir:"+isAir);
		if( nowvec.addy <= 0 && isAir )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_Keep } ); //保存してあったのを開く
			if( vec.y <= 0 && vec.addy <= 0 ) vec.addy = 250; //無いはずだけど万が一これだとういてっちまうので救済
			BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=vec.addx, addy=vec.addy, flags=_Vector_Normal } );
			
			if( BMvTbl.GetLP(4) > 0 )
			{
				// _dpn("低空で浮く処理を消す");
				BMvTbl.SetVector( {  y=0, addy=0, flags=_Vector_DivKeep } ); // 低空のを消す
			}
		}
		BMvTbl.SetVector( { x=0, addx=0, y=0, addy=0, flags=_Vector_Keep } ); //一応消しておく
	}
}

Std_MoveTable.Mv_Assault_Air.FrameUpdate_Std <- Make_AssaultFU(1, 4, 9);


const DBGM_ForwardShift = 1; // デバッグ用に性能を表示する処理

Std_MoveTable.Mv_ForwardShift <-
{
	function Init_Std() // 
	{
		Battle_Std.InitVector(); //ベクトル初期化
		BMvTbl.SetPattern(def_PAT_ForwardShift);
		BMvTbl.SetMuki(_Direction_Auto);
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // ツールでCS可なら空振りCS可能

		Battle_Std.Sousai.Init_NoHitFlag( 2 ); // 相殺
		
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		
		BMvTbl.SetLPEx(1,1,0); // 攻撃を受け止めた回数　※別MVからも参照あり
		BMvTbl.SetLPEx(1,2,0); // コストを消費したか
		BMvTbl.SetLPEx(1,3,0); // 硬直まで進んだ
		BMvTbl.SetLPEx(1,4,0); // 減らす硬直フレーム 0〜4
		BMvTbl.SetLPEx(1,5,BMvTbl.GetMuki()); // 開始時の向き

		if( DBGM_ForwardShift )
		{
			local pos = BMvTbl.GetPosition();
			BMvTbl.SetLP(0,pos.x);//開始座標
			BMvTbl.SetLP(1,0);//無敵F
			BMvTbl.SetLP(2,0);
			BMvTbl.SetLP(3,0);//重なり出現F
			BMvTbl.SetLP(4,0);//重なり出現座標
		}
		
		// Def_Sys_EnemyAntenStopNoCancel のときこのフラグは被暗転で消えます
		// CSやEX技見てからCSを不可にするため
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_ChainShift, time=8, flag=_ClearFlag_ChangeMv } );
		
		//3Dで1F当身なのでズラし押しできると強すぎる
		//でも3D>Aで投げを入れてしまうことも多々あってストレスがやばい
		//3DDのCSを可能にするなら、これもテクニックとして残していいだろって気がする（当身成立から投げが出なければいい）
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
		
		//投げに弱くしたいので投げ無敵は削除する（リバサ時の無敵を消す用）
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_nageX=0 } ); // 起き上がりなどの投げ無敵を消す
	}
	function UseCost()
	{
		local cs_flag = BCMDTbl.CheckCancel( _SkillType_ChainShift ); // CS可能な状態？
		if( BMvTbl.GetLPEx(1,1) == 0 && !cs_flag ) // 攻撃を受け止めていない＝失敗　＆　CS可能な間はコスト消費しない
		{
			if( BMvTbl.GetLPEx(1,2) == 0 ) // コストを消費したか
			{
				BMvTbl.SetLPEx(1,2,1); // コストを消費したか
				BMvEff.GRD_UseStock( { val=2 } );
				// _dpn("コスト消費");
			}
		}
	}
	function Start_Std()
	{
		// 回避のエフェクトを呼ぶ
		// ズラし押しなどもあるしタイミングは少し遅らせる
		// 1F目に光るの前提の作りはロールバック的にもNG
		local eff = BMvEff.CreateObject( { datatype=1, start_pat="dodge_move" } );
		if( eff.push() )
		{
			BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv } );
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll } );
			eff.pop();
		}
		BMvEff.SetCharaFlash( { color = 0x4444FF, type = 0, time = 10 } );
		Battle_Std.PcAfterImage_DoudgeInit(); //残像セット
		Battle_Std.TypeSE_Play({ type="前方回避" });//ボイス再生
	}
	function Update_Std()
	{
		// 性能を全キャラで揃える
		// 移動量と重なりの消すタイミングを統一(旧ハイドなどと同じ性能)
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount==11 )
		{
			BMvTbl.SetVector( { x=700, addx=400, flags=_Vector_Normal } );

			BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Add } ); //重なり判定無し
		}
		if( mvs.MvCount==15 )
		{
			BMvTbl.SetVector( { x=5800, addx=-400, flags=_Vector_Normal } );
			BMvTbl.SetVector_MaxX( 1500 );
		}
		if( mvs.MvCount==21 )
		{
			BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); //重なり判定戻し
		}
		if( mvs.MvCount==26 )
		{
			Battle_Std.InitCharaVector();

			// 以下の処理を入れないと途中で向きが変わるキャラでベクトル収束時のMaxXがうまく動かない
			local muki = BMvTbl.GetMuki();
			local start_muki = BMvTbl.GetLPEx(1,5); // 開始時の向き
			local muki_change = (muki!=start_muki)? -1 : 1;
			
			BMvTbl.SetVector( { x=1500*muki_change, flags=_Vector_Normal } );
			BMvTbl.SetVector_MaxX(0);
		}
		if( mvs.MvCount==31 )
		{
			Battle_Std.InitCharaVector();
		}
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		local mvcount = mvs.MvCount;
		// _dpn("mvcount:"+mvcount);
		
		//  1〜20F 相殺（相殺判定は1〜28Fにツール上付いている）
		//  1〜 8F 弱い相殺
		// 29〜40F 硬直(相殺で回避していたらガード可能)

		// 浮くタイプは相殺に成功していても空中ガード不能技を重ねられて被弾する
		// 地上タイプは相殺に成功していても投げ技を重ねられて被弾する
		// 浮くタイプの方が基本的には弱い
		
		// 相殺に成功すると、相殺判定があるフレーム中は打撃無敵が入る
		// 1〜20F
		// XXX:弾相殺させてCS＞殴りにいくときの違和感がある
		// 17Fまでにすると感覚としては緩和はされそうではある
		
		local sousai_hantei_frame = 0;
		local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 2 ], flags=0 } );
		if( rc.sx != _Hantei_Error )
		{
			sousai_hantei_frame = 1; // 相殺判定がある時間
			if( mvs.MvCount >= 20 )
			{
				//1〜20Fぐらいにしておかないと、移動先に技をおいても相殺されてよくない感じ
				sousai_hantei_frame = 0; // 長すぎ
			}
		}
		local sousai_count = BMvTbl.GetLPEx(1,1); // 攻撃を受け止めた回数
		
		if( sousai_hantei_frame )
		{
			if( sousai_count > 0 )
			{
				BMvEff.SetPlayerTimer( { muteki_dage=2, muteki_dageX=2 } );
			}
			else
			{
				Battle_Std.Sousai.FrameUpdate_NoHitFlag( 2 );
			}
		}
		else if( BMvTbl.GetLPEx(1,3)==0 )
		{
			BMvTbl.SetLPEx(1,3,1); // 硬直まで進んだ
			
			// sousai_hantei_frameが20Fぐらいなので、あと20Fある
			// 停止の絵は10Fぐらい
			
			
			BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } );
			Battle_Std.Sousai.Erase();

			UseCost(); // コスト消費
			
			// これを消すと3D中はずっと被カウンターになる
			// 金投げコマ投げなんかも確定するようになる
			BMvTbl.SetCounterHitFlag( { val=0, time=32, flag=_ClearFlag_ChangeMv } );//被カウンターを消す
			
			//特殊判定がないところは硬直のはず
			//当身に成功してたら、硬直だけどガードは可能にしてみたい
			if( sousai_count > 0 )
			{
				BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=64, flag=_ClearFlag_ChangeMv } );
				
				Battle_Std.MoveCodeEx.DelFlag( 4, def_MC4_EnablePanishAnnounce ); //ガードできるのでパニッシュが出る行動なのを解除
				

				_dpn("減速...");
				BMvTbl.SetVector( { x=-640, addx=64, flags=_Vector_DivKeep } ); // 減速
			}
			else
			{
				_dpn("加速!");
				BMvTbl.SetVector( { x=1280, addx=-128, flags=_Vector_DivKeep } ); // 加速
			}
		}
		
		if( DBGM_ForwardShift )
		{
			//重なりが出現する位置をチェック
			local kasanari_rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Kasanari, 0 ], flags=0 } );
			if( kasanari_rc.sx == _Hantei_Error )
			{
				local mvs = BMvTbl.GetMvStatus();
				local pos = BMvTbl.GetPosition();
				local start_pos_x = BMvTbl.GetLP(0);
				
				local move_len = abs(pos.x - start_pos_x);
				
				BMvTbl.SetLP(3,mvs.MvCount);//重なりがない間更新
				BMvTbl.SetLP(4,move_len);//重なりがない間更新
			}
		}
	}
	function HitInterrupt_Std()
	{
		local mvhs = Battle_Std.Sousai.HitInterrupt( { hitstop = 0, noeffect=0, nosound=1, noquake=1, nocommanddelay=1 } );
		if( mvhs )
		{
			local mvs = BMvTbl.GetMvStatus();
			local mvcount = mvs.MvCount;//1F〜
			local pow_atemi = (mvcount >= 8)? 1 : 0; // 強いバージョンかどうか　1:8F以降に取った場合　2:無敵技やジャンプ攻撃を取った時
			
			// mvcount : 0〜19のはず
			//  0〜 8:弱い
			//  9〜12:普通
			// 13〜19:強い
			
			local minus_frame = mvcount - 13;
			_dpn("mvcount:"+mvcount+" minus_frame:"+minus_frame);
			if( minus_frame <  0 ) minus_frame =  0;
			if( minus_frame >  4 ) minus_frame =  4;
			_dp(" -> "+minus_frame );
			BMvTbl.SetLPEx(1,4,minus_frame); // 減らす硬直フレーム 0〜4
			
			// 相手が無敵技のときは常に強いバージョンとなるようにする
			// 相手がジャンプ攻撃のときも強くする
			if(1)
			{
				// 打撃と弾が同Fにヒットすると打撃判定になる
				// そのため弾無敵がつかない問題があるが、そんなに起きるわけではないのでOKとする
				local atk_core = BMvCore.GetLastHitCharaData(0); // 0:そのままの相手を取得 1:殴られた相手の一番親を取得
				if( atk_core.push() )
				{
					local is_muteki_atk = 0;
					local isJumpAtk = 0;
					local is_about_fireball_atk = ( BMvTbl.GetHitCheckFlag(1)&_HitCheckFlag_FireBall );
					
					if( atk_core.isPlayer() )
					{
						if( Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_Muteki ) )
						{
							is_muteki_atk = 1;
						}
						if( Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_AtkJump ) )
						{
							isJumpAtk = 1;
						}
					}
					else
					{
						if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) != 0 )
						{
							local e_player = BMvCore.GetPlayerCharaData();
							if( e_player.push() )
							{
								// _dm("親を見る");
								if( Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_Muteki ) )
								{
									is_muteki_atk = 1;
								}
								if( Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_AtkJump ) )
								{
									isJumpAtk = 1;
								}
								e_player.pop();
							}
						}
					}
					
					Battle_Std.SetShieldSuccessCancelEffect(); // シールド成功によるキャンセル制限処理
				
					atk_core.pop();
					
					if( is_muteki_atk )
					{
						_dpn("無敵技を取ったので強いバージョンに変化");
						pow_atemi = 2; // 強いバージョンにする
					}
					if( isJumpAtk )
					{
						_dpn("ジャンプ攻撃を取ったので強いバージョンに変化");
						pow_atemi = 2; // 強いバージョンにする
						BMvEff.SetStopTime( { time=6, bounderase=1 } );
					}
					if( is_about_fireball_atk )
					{
						// 3D自体を弾無敵にするのもありだが、回避先に弾でガード確を取りたいときにやや困る
						_dpn("弾っぽいものを取ったので行動終了まで弾無敵");
						BMvTbl.SetHitCheckFlag( { type=0, val=_HitCheckFlag_FireBall, time=254, flag=_ClearFlag_ChangeMv } ); // 弾無敵
					}
				}
			}
			
			// 当身成功時にCSなど不可にする
			{
				//3Dで相殺して、さらにCSするのは強すぎるのでCS不可にする
				BMvTbl.SetAsFlag( { as_flags=_AsFlag_ChainShift, time=0, flag=_ClearFlag_ChangeMv } );
				
				// 同様に相殺から投げとかやばすぎるので同時押しのズラしは不可に
				Battle_Std.MoveCodeEx.DelFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
				
				BMvTbl.SetCounterHitFlag( { val=0, time=254, flag=_ClearFlag_ChangeMv } );//行動中のカウンターを消去
			}
			
			
			{
				local add_frame = 4; // 自分に加算するヒットストップ
				if( !pow_atemi )
				{
					
					// 相手との距離が遠い場合、addframeを減らして性能ダウンを軽減
					local kyori = Battle_Std.GetEnemyDistance();
					
					//3Dが480ドットぐらい進む(当身成功時は400ドット)
					//当身成功で400ドットだとして、投げとかAが確定しそうな間合いで硬直が減らないようにしてる
					local min_kyori = (400+150)*128; // 今の間合いがこれくらいまでなら強くして良い
					local max_kyori = min_kyori + 150*128;

					_dpn("kyori:"+kyori/128);
					
					if( kyori > min_kyori )
					{
						if( kyori > max_kyori ) kyori = max_kyori;
						local par = 100 - ( (kyori-min_kyori) * 100 / (max_kyori-min_kyori) );
						add_frame = add_frame * par / 100;
						
						_dpn("par:"+par+" add_frame:"+add_frame+" min:"+min_kyori/128+" max:"+max_kyori/128);
					}
					
					if( add_frame > 0 )
					{
						BMvTbl.SetHitStop( add_frame, _ValAdd ); // 自分のヒットストップだけ伸ばす
						//伸ばしたフレームだけ無敵にしないと多段系が相殺とれないので無敵に変更
						BMvEff.SetPlayerTimer( { muteki_dage=add_frame } );
						
					}
					
				}
				
				//少し暗転してスロー感を出す
				//add_frameが大きいほど自分が弱い＝時間停止が短く見えたほうが自然なのでこうしている
				BMvEff.CutInProc_Set({ time=[0,10-add_frame,10], cutin_mv="",erasetype=2, bgtype=1 });

				
				// 入力が漏れてストレスも結構あるので、時間停止とかスローが欲しい
				// 最初はスロー弱め・途中強め・もとに戻るみたいな挙動が一番自然になりそうだが
				// BMvEff.Slowmotion_Set( { time=60, power=6666, power_minus=10000/60 } );
				// 操作のタイミングにズレがおきてお互いが反撃とかし辛いのもよくない
				// 回避→攻撃というところでスピード感も欲しい
			}
			
			local sousai_count = BMvTbl.AddLPEx(1,1,1); // 攻撃を受け止めた回数
			if( sousai_count == 1 )
			{
				BMvEff.AttackInfoString_Set({ word=def_AISW_SPGuard,} ); // シールドではないけど近い効果が出てるのでアナウンスを出す
				
				Battle_Std.SetShieldSuccessGRDEffect(1); // GRD増加・相手のGRDを減らす・TSを進める
			}
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
	function LastUpdate_Std()
	{
		BMvEff.PcAfterImage_Clear(); //残像の消去
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } );
		
		// BMvEff.SetCharaFlash( { time = 0 } ); // これを呼ぶと被カウンターのときキャラが光らない
		
		BMvEff.SetExist( { level = _Exist_NoKasanariHantei, mode=_ExistMode_Erase } );

		UseCost(); // コスト消費（何度も入るが1回のみ処理）
		
		if( DBGM_ForwardShift )
		{
			local mvs = BMvTbl.GetMvStatus();
			local pos = BMvTbl.GetPosition();
			local start_pos_x = BMvTbl.GetLP(0);
			
			local kasanari_frame = BMvTbl.GetLP(3);
			local kasanari_len = BMvTbl.GetLP(4);
			
			local move_len = abs(pos.x - start_pos_x);
			local total_frame = mvs.MvCount; // 全体F
			_dpn("全体:"+total_frame+" 移動距離:"+move_len/128+" 重なり:"+kasanari_frame+"F "+kasanari_len/128); // ドットに変換
		}
	}
}
	
//投げ
Std_MoveTable.Mv_Throw_F <-
{
	function CheckForwardShiftCatch()
	{
		// 3Dの移動中でつかんで良い瞬間は1
		// 当身に成功してるときは無理やりつかむことがないようにする
		local emv = BMvTbl.GetMvName();
		if( emv == "Mv_ForwardShift" )
		{
			local nage_muteki = BMvEff.GetPlayerMuteki( 1 ); // 投げ無敵
			local sousai_count = BMvTbl.GetLPEx(1,1); // 攻撃を受け止めた回数
			
			if( !nage_muteki && sousai_count==0 )
			{
				//_dpn("つかんで良い");
				return 1;
			}
			else
			{
				//_dpn("当身成功");
				return 0;
			}
		}
		//_dpn("そもそも別行動");
		return 0;
	}
	function Init_Std() // 
	{
		// _dp("\n Mv_Throw_F_Init()");
		
		Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
		//Battle_Std.InitVector(); // ベクトル初期化
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Throw_F);
		BMvTbl.ClearHitStatus(); // ヒット情報のクリア
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_EnableTech );//投げ抜け可能な行動
		Battle_Std.ThrowTech.SetThrowMvFlag(); //投げ属性Mvを設定
		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.MoveCode.AddFlag( def_MC_GRDBreak_FatalDmgHosei ); // 行動コード(GRDブレイクで攻撃力アップ)を設定
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
		// Battle_Std.SetNoMovableMove(); // 動けないMV　※フリーモーションがあるキャラが多いので廃止
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_InActive );
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		// Battle_Std.InitAtkSkillMv(); // 通常技や必殺技の共通初期化　※入れるべき？（パニッシュフラグもあり）
		
//		Battle_Std.DelPSFlag( def_PP_PS_isThrowMv ); //投げ属性モーションを削除
		//BMvTbl.SetLP(0,0); //カウンタ初期化
		BMvTbl.SetLP(1,0); //投げスカまで進んだ＆音声再生済み
		BMvTbl.SetLPEx(1,0,0); //3Dへの強引投げか　1:強引投げ　10:さらにカウンターで掴んだか
		
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Throw_F_TechWait, frame=0, rest=2 } ); // 投げつかみ分岐先予約		
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Throw_F_Hit, frame=0, rest=6 } ); // 投げ成立先予約
		
		if( BMvTbl.GetCmdNumber()==def_CN_Throw_F && Battle_Std.GS_CheckFlag( def_PP_GS_SlideDashThrow ) ) // スライド投げ
		{
			_dp("\n ★★スライドダッシュ投げ★★");
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GenFlag ); // Mv_Throw_F + def_MC1_GenFlag == スライド投げ
		}
		
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_TechCheck );//投げ抜けされる技
		
		Battle_Std.CharaBattleActivity_Increment(110,"地上投げ使用");
	}
	function HitInterrupt_Std()
	{
		//この時点で相手はダメージ状態…ではない（つかみ命令入ってない）
		//のけぞりは当然入ってくる
		local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
		
		local isBoundOrMutekiCapture = false;//金投げ
		local enemyIsGuardShield = false; // ガードシールド
		
		if( enemy.push() )
		{
			local bs = BtlMvStd.GetBoundStatus();
			isBoundOrMutekiCapture = ((bs.isCapture&(1<<1))!=0); //Bound or Muteki Capture
			if( Def_Sys_GuardShieldThrow_NoGouinNageHosei && isBoundOrMutekiCapture && BMvEff.GuardSP_Get() )
			{
				// 金投げ判定になったとき、相手がシールド状態であるならガードシールド判定として補正をかけない
				enemyIsGuardShield = true;
			}
			//print("\nhs.isCapture"+bs.isCapture+" isBoundOrMutekiCapture:"+isBoundOrMutekiCapture);
			enemy.pop();
		}
		if( isBoundOrMutekiCapture && !enemyIsGuardShield ) //BM掴み（金投げ）かどうか
		{
			// _dm("Boundか投げ無敵中をつかんだので補正をかけます");

			// Battle_Std.DrawDebugAttackInfo("! Gouin Nage");	
			local ret = Battle_Std.SetThrowHitFinalize(512); // ヒット分岐ファイナライズ
			if( ret )
			{
				_dpn("金投げの補正");
				//コンボ補正あり
				BMvEff.ComboView_Set( { val=def_HOSEI_BoundMutekiCapture, type=1 } ); // 乗算
				// BMvEff.StdCall( { type=6, no=112, param=[ def_HOSEI_BoundMutekiCapture,1,0,0,0, 0,0,0,0,0, 0,0 ]} );
			}
		}
		else
		{
			Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ
		}
	}
	function FrameUpdate_Std()//
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//local mvcnt = BMvTbl.GetLP(0); //カウンタ取得
		//BMvTbl.AddLP(0,1); //1F進める
		
		if( s.MvCount>=4+2 && (BMvTbl.GetLP(1)==0) ) //投げ失敗確定後＆フラグがたっていない
		{
			_dpn("投げスカり");
			BMvTbl.SetLP(1,1); //再生済み
			Battle_Std.TypeSE_Play({ type="投げスカり" });
			Battle_Std.MoveCodeEx.DelFlag( 7, def_MC7_EnableTech );//投げ抜け可能な行動
			Battle_Std.ThrowTech.DelThrowMvFlag_NextFrame(); //1F後に投げ属性モーションを1F後に削除
			
			//投げスカりのGRD減少
			// これは相手がやられ中でも減らす。なんとなく。
			Battle_Std.GRD_AddValue({ val=def_GRD_ThrowMiss, pressure=0, boundplus=0,target=0 });
		}
		
		// 相手が3Dで移動中で近い位置にいたら無理やりつかむ
		// つかむタイミングは攻撃判定が出ているとき
		// この仕様を入れる場合、完全なワープタイプはやめて内部データはベクトル移動にする必要がある
		// DamageImpactとかに入らないので注意
		if( Def_Sys_ThrowCounterToForwordShift )
		{
			if( Battle_Std.CheckHanteiAttackExist() && BMvTbl.GetLP(1)==0 && BMvTbl.GetFinalizeCode()==0 ) // 投げスカに進んでない
			{
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					// 金投げかどうかは取得不可能
					// local bs = BtlMvStd.GetBoundStatus();
					// local isBoundOrMutekiCapture = ((bs.isCapture&(1<<1)) != 0); //Bound or Muteki Capture
					
					local enemy_catch_ok = CheckForwardShiftCatch();
					
					local counter = BMvTbl.GetCounterHitFlag(); // 掴む直前の相手の被カウンターフラグを見る
					// _dpn("counter:"+counter);

					enemy.pop();
					
					if( enemy_catch_ok )
					{
						// 距離が近かったら無理やりつかむ
						// 地上とか空中とか関係ないし、相手が後ろにいても関係ない
						local posst = BMvEff.GetPointStatus( { target=enemy } );
						local kyori = posst.pos_x*BMvTbl.GetMuki();
						
						// _dpn("距離:"+kyori/128 );
						
						if( kyori > -120*128 && kyori < 170*128 )
						{
							local cap = BMvEff.CapturePlayer( { target=enemy } );
							if( cap )
							{
								_dpn("強引つかみ");
								BMvTbl.SetFinalize(256);
								BMvTbl.SetLPEx(1,0,1); //3Dへの強引投げで掴んだ
								
								if( counter )
								{
									// _dpn("カウンターなのを記憶");
									BMvTbl.SetLPEx(1,0,10); //3Dへの強引投げでカウンターで掴んだ
								}
							}
						}
					}
				}
			}
		}
		
	}
	function Finalize_Std() // 
	{
		//BMvTbl.SetLP(0,0); //カウンタ初期化
		BMvTbl.SetLP(1,0); //カウンタ初期化
		
		local fin_code = BMvTbl.GetFinalizeCode();
		if( fin_code == 256 || fin_code == 512 )
		{
			// 掴み時に相手の行動をみて分岐
			// 3D移動をつかんでたらブレイクさせる
			// 通常投げで3Dを掴んだとき、強引投げでないときはブレイクしないのでブレイクさせないと駄目
			local forward_catch_status = BMvTbl.GetLPEx(1,0); //3Dへの強引投げで掴んだか 1:通常　10:カウンター
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				local enemy_catch_ok = CheckForwardShiftCatch();
				local mvs = BMvTbl.GetMvStatus();
				
				enemy.pop();
				
				local counterhit = 0;
				if( forward_catch_status == 0 )
				{
					if( mvs.flags&_MvStFlag_CounterDef )
					{
						_dpn("通常掴みなので普通にカウンター処理がされる");
						counterhit = 1;
					}
				}
				else
				{
					counterhit = (forward_catch_status==10)? 1 : 0;
				}
				
				
				if( enemy_catch_ok )
				{
					// 仕様
					// 通常投げで3Dを掴んだら割れるけど、打撃では割れない
					
					// カウンターかどうかちゃんと見ないと駄目
					// 3D中を掴んだら強引にカウンターにしたくても、通常の掴みでパニッシュフラグが入ってしまうので駄目
					// if( counterhit )
					if( enemy_catch_ok ) // これをやるときはpunishフラグが入らないようにする
					{
						BMvEff.SetCounterAnnounce(); // カウンターアナウンス表示
						Battle_Std.GRDBreak_Attack( { Nage=1, NoHosei=1 } );
						Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_EnemyTechImpossible );//投げ抜け不可にする
						
						if( enemy.push() )
						{
							Battle_Std.SetCharaFlash_Counter(); //カウンターによる発光

							if( forward_catch_status == 0 )
							{
								Battle_Std.PP_AddFlag(def_PP_ImpactAnnounce,def_PP_IA_Counter); // 例外的に処理・パニッシュを出さないように
							}
							else
							{
								// Impact入らないので処理を入れる
								Battle_Std.EnemyCharaBattleActivity_Increment(50,"カウンターヒット");
								Battle_Std.CharaBattleActivity_Increment(51,"被カウンターヒット");
							}
							
							Battle_Std.GRDBreak_Damage( { Nage=1 } );
							enemy.pop();
						}
					}
					/*
					// こっちも一応処理を活かしておく。counterhit時のみブレイクにするなら入れること
					else
					{
						BMvEff.SetPunishAnnounce(); // パニッシュアナウンス表示
						Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_EnemyTechImpossible );//投げ抜け不可にする
					}
					*/
				}
			}
		}
		
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Throw_F_TechWait"], [512,"Mv_Throw_F_TechWait2"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		Battle_Std.ThrowTech.DelThrowMvFlag_NextFrame(); //1F後に投げ属性モーションを1F後に削除
	}
}


Std_MoveTable.Mv_Throw_F_TechWait <- //つかんでから投げ抜けを待つまで〜分岐
{	
	function Init_Std()
	{
		Battle_Std.InitVector(); // ベクトル初期化(一応)
		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.ThrowTech.SetMuteki(); //つかみ中は自分も相手も無敵にする	
		Battle_Std.PlayerSE_StopLastPlaySound( 1 ); //直前に再生した音声を停止
		Battle_Std.SetNoMovableMove(); // 動けないMV
		
		//前の行動のつかみ時の状況をチェック
		Battle_Std.PassBeforeMoveCodeEx( 7, def_MC7_EnemyTechImpossible );
		if( Battle_Std.ThrowTech.CheckTechMissFrame() || Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_EnemyTechImpossible ) )
		{
			Battle_Std.ThrowTech.CheckTechImpossible(); // 硬直中だったら色々設定
			BMvTbl.SetFinalize(512); //投げ抜けできないフレーム中なので終わろう
		}
		else //投げぬけ失敗フレームではない投げ
		{
			Battle_Std.EnemyCharaBattleActivity_Increment(121,"投げでつかまれた回数");
			
			//掴んだ相手側に投げられ回数を加算
			local enemy = BMvCore.GetCaptureCharaData();
			if( enemy.push() )
			{
				BMvEff.AddSkillCount( _SkillCount_Throw ); // 履歴カウンタを加算
				
				enemy.pop();
			}
			BMvEff.ThrowChara_SetCamera( 1 ); //投げているキャラをカメラ処理に含める
		}
		
		Battle_Std.ThrowTech.SetPos(); //つかむ前の自分と相手の座標を記憶する
		
		BMvTbl.SetPattern(def_PAT_Throw_F_TechWait); //投げ抜け待機パターンに変更(ここで相手はのけぞる)
		
		Battle_Std.ThrowTech.SetThrowParam(); //エフェクト座標に相手をやられ絵でセット
		
		//相手のけぞってからの処理
		Battle_Std.ThrowTech.ShiftOverGamenHajiX(); //相手が画面外にいたら自分の座標ごと補正をかける	
		Battle_Std.ThrowTech.DrawThrowEffect(0); //ヒット座標につかみエフェクト表示 1:金投げ
		
		// まだ投げ抜け可能なので特殊なやられ状態にする
		local enemy = BMvCore.GetCaptureCharaData();
		if( enemy.push() )
		{
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_DamageEx, time=255, flag=_ClearFlag_ChangeMv } ); // 特殊やられにしてGetBoundFlagで検知可能に
			
			enemy.pop();
		}
		
		Battle_Std.PassHitMoveCodes(); // ヒット分岐でのMvCode引継ぎ
	}
	function Update_Std() //投げぬけ猶予中
	{

		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//print("\nTh1:Frame:"+s.FrameID);
		if( s.MvCount>def_FL_Tech )
		{
			BMvTbl.SetFinalize(0); //投げ抜け猶予が終わったので終わる
			return;
		}
		
		if ( Battle_Std.ThrowTech.CheckTechCommand() ) //相手が投げ抜けコマンドを入れた
		{
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
			if( enemy.push() )
			{
				local delay = def_FL_Tech - s.MvCount;
				// Battle_Std.DrawDebugAttackInfo("TechSafe: "+delay+"F" );
				
				enemy.pop();
			}
			
			Battle_Std.ThrowTech.DrawTechEffect(); //投げ抜け演出を表示
			Battle_Std.ThrowTech.TechRelease( { release_kyori=Def_Sys_FixPosAfterThrowTech } ); //投げ抜けされた時の開放処理
			BMvTbl.SetFinalize(256);
		}
	}
	function Finalize_Std() // 
	{
		local fin_code = BMvTbl.GetFinalizeCode();
		if( fin_code != 256 )
		{
			Battle_Std.CharaBattleActivity_Increment(111,"地上投げ成功");
			//投げ成功回数/(投げ成功回数+投げ失敗回数)
			Battle_Std.CharaBattleActivity_Calc( {
				title="地上投げ成功確率", 
				molecule=Battle_Std.CharaBattleActivity_Count("地上投げ成功"), denominator=(Battle_Std.CharaBattleActivity_Count("地上投げ成功")+Battle_Std.CharaBattleActivity_Count("地上投げ失敗"))
			} );
		}
		Battle_Std.SwitchNextMoveTable("Mv_Throw_F_Hit", [256,"Mv_Teched"],[512,"Mv_Throw_F_TechMissWait"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );	
		BMvEff.ThrowChara_SetCamera( 0 ); //投げているキャラをカメラ処理に含めない
	}
}


Std_MoveTable.Mv_Throw_F_TechWait2 <- //（金投げ）つかんでから投げ抜けを待つまで〜分岐
{	
	function Init_Std()
	{
		Battle_Std.InitVector(); // ベクトル初期化(一応)
		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.ThrowTech.SetMuteki(); //つかみ中は自分も相手も無敵にする
		Battle_Std.PlayerSE_StopLastPlaySound( 1 ); //直前に再生した音声を停止
		Battle_Std.SetNoMovableMove(); // 動けないMV

		//前の行動のつかみ時の状況をチェック
		Battle_Std.PassBeforeMoveCodeEx( 7, def_MC7_EnemyTechImpossible );
		if( Battle_Std.ThrowTech.CheckTechMissFrame() || Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_EnemyTechImpossible ) )
		{
			Battle_Std.ThrowTech.CheckTechImpossible(); // 硬直中だったら色々設定
			BMvTbl.SetFinalize(512); //投げ抜けできないフレーム中なので終わろう
		}
		else //投げぬけ失敗フレームではない投げ
		{
			Battle_Std.EnemyCharaBattleActivity_Increment(121,"投げでつかまれた回数");
			
			//掴んだ相手側に投げられ回数を加算
			local enemy = BMvCore.GetCaptureCharaData();
			if( enemy.push() )
			{
				BMvEff.AddSkillCount( _SkillCount_Throw ); // 履歴カウンタを加算
				
				enemy.pop();
			}
			BMvEff.ThrowChara_SetCamera( 1 ); //投げているキャラをカメラ処理に含める
		}
		
		Battle_Std.ThrowTech.SetPos(); //つかむ前の自分と相手の座標を記憶する
		
		BMvTbl.SetPattern(def_PAT_Throw_F_TechWait); //投げ抜け待機パターンに変更(ここで相手はのけぞる)
		
		Battle_Std.ThrowTech.SetThrowParam(); //エフェクト座標に相手をやられ絵でセット
		
		//相手のけぞってからの処理
		Battle_Std.ThrowTech.ShiftOverGamenHajiX(); //相手が画面外にいたら自分の座標ごと補正をかける	
		Battle_Std.ThrowTech.DrawThrowEffect(1); //ヒット座標につかみエフェクト表示 1:金投げ
		
		// まだ投げ抜け可能なので特殊なやられ状態にする
		local enemy = BMvCore.GetCaptureCharaData();
		if( enemy.push() )
		{
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_DamageEx, time=255, flag=_ClearFlag_ChangeMv } ); // 特殊やられにしてGetBoundFlagで検知可能に
			
			enemy.pop();
		}
		
		Battle_Std.PassHitMoveCodes(); // ヒット分岐でのMvCode引継ぎ
	}
	function Update_Std() //投げぬけ猶予中
	{

		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//print("\nTh2:Frame:"+s.FrameID);
		
		if( s.MvCount>def_FL_BoundTech )
		{
			BMvTbl.SetFinalize(0); //投げ抜け猶予が終わったので終わる
			return;
		}
		
		if ( Battle_Std.ThrowTech.CheckTechCommand() ) //相手が投げ抜けコマンドを入れた
		{
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
			if( enemy.push() )
			{
				local delay = def_FL_BoundTech - s.MvCount;
				// Battle_Std.DrawDebugAttackInfo("TechSafe: "+delay+"F" );
				
				enemy.pop();
			}
			
			Battle_Std.ThrowTech.DrawTechEffect(); //投げ抜け演出を表示
			Battle_Std.ThrowTech.TechRelease( { release_kyori=Def_Sys_FixPosAfterThrowTech } ); //投げ抜けされた時の開放処理
			BMvTbl.SetFinalize(256);
		}
	}
	function Finalize_Std() // 
	{
		local fin_code = BMvTbl.GetFinalizeCode();
		if( fin_code != 256 )
		{
			Battle_Std.CharaBattleActivity_Increment(111,"地上投げ成功");
			//投げ成功回数/(投げ成功回数+投げ失敗回数)
			Battle_Std.CharaBattleActivity_Calc( {
				title="地上投げ成功確率", 
				molecule=Battle_Std.CharaBattleActivity_Count("地上投げ成功"), denominator=(Battle_Std.CharaBattleActivity_Count("地上投げ成功")+Battle_Std.CharaBattleActivity_Count("地上投げ失敗"))
			} );
		}
		Battle_Std.SwitchNextMoveTable("Mv_Throw_F_Hit", [256,"Mv_Teched"],[512,"Mv_Throw_F_TechMissWait"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );	
		BMvEff.ThrowChara_SetCamera( 0 ); //投げているキャラをカメラ処理に含めない
	}
}


Std_MoveTable.Mv_Throw_F_TechWaitTraining <- //トレモ用
{	
	function Init_Std()
	{
		// ヒットせずにくるので描画を手前にする
		BMvTbl.SetPrio( _CharaPrio_Near );
		
		// 無理やり相手をつかむ
		local enemy = BMvCore.GetEnemyCharaData();
		local cap = BMvEff.CapturePlayer( { target=enemy } );

		// 以降は投げの処理とだいたい同じ
		Battle_Std.InitVector(); // ベクトル初期化(一応)
		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.ThrowTech.SetMuteki(); //つかみ中は自分も相手も無敵にする
		Battle_Std.PlayerSE_StopLastPlaySound( 1 ); //直前に再生した音声を停止
		Battle_Std.SetNoMovableMove(); // 動けないMV

		BMvEff.ThrowChara_SetCamera( 1 ); //投げているキャラをカメラ処理に含める
		
		Battle_Std.ThrowTech.SetPos(); //つかむ前の自分と相手の座標を記憶する
		
		BMvTbl.SetPattern(def_PAT_Throw_F_TechWait); //投げ抜け待機パターンに変更(ここで相手はのけぞる)
		
		Battle_Std.ThrowTech.SetThrowParam(); //エフェクト座標に相手をやられ絵でセット
		
		//相手のけぞってからの処理
		Battle_Std.ThrowTech.ShiftOverGamenHajiX(); //相手が画面外にいたら自分の座標ごと補正をかける	
		Battle_Std.ThrowTech.DrawThrowEffect(1); //ヒット座標につかみエフェクト表示 1:金投げ
		
		// まだ投げ抜け可能なので特殊なやられ状態にする
		local enemy = BMvCore.GetCaptureCharaData();
		if( enemy.push() )
		{
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_DamageEx, time=255, flag=_ClearFlag_ChangeMv } ); // 特殊やられにしてGetBoundFlagで検知可能に
			
			enemy.pop();
		}
		
		Battle_Std.PassHitMoveCodes(); // ヒット分岐でのMvCode引継ぎ
	}
	function Update_Std() //投げぬけ猶予中
	{

		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//print("\nTh2:Frame:"+s.FrameID);
		
		/*
		// if( s.MvCount>def_FL_BoundTech )
		if( s.MvCount>120 )
		{
			BMvTbl.SetFinalize(0); //投げ抜け猶予が終わったので終わる
			return;
		}
		*/
		
		/*
		if ( Battle_Std.ThrowTech.CheckTechCommand() ) //相手が投げ抜けコマンドを入れた
		{
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
			if( enemy.push() )
			{
				local delay = def_FL_BoundTech - s.MvCount;
				// Battle_Std.DrawDebugAttackInfo("TechSafe: "+delay+"F" );
				
				enemy.pop();
			}
			
			Battle_Std.ThrowTech.DrawTechEffect(); //投げ抜け演出を表示
			Battle_Std.ThrowTech.TechRelease( { release_kyori=Def_Sys_FixPosAfterThrowTech } ); //投げ抜けされた時の開放処理
			BMvTbl.SetFinalize(256);
		}
		*/
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Throw_F_Hit", [256,"Mv_Teched"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );	
		BMvEff.ThrowChara_SetCamera( 0 ); //投げているキャラをカメラ処理に含めない
	}
}


// 投げ抜け不能フレームの時　と　行動不能を単純に掴んだ時 がある
Std_MoveTable.Mv_Throw_F_TechMissWait <- //投げ抜けされないつかみの時
{	
	function Init_Std()
	{
		Battle_Std.TypeSE_Play({ type="投げ抜けされないつかみ成功" });
		
		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.SetNoMovableMove(); // 動けないMV

		local enemy = BMvCore.GetNearEnemyCharaData();
		if( enemy.push() )
		{
			Battle_Std.TypeSE_Play({ type="ガード失敗" });
			Battle_Std.SoundStatus_AddFlag( def_PP_SS_NoBoundVoiceOnce ); // 次のやられ音声を再生しない

			enemy.pop();
		}
		
		Battle_Std.ThrowTech.SetMuteki(); //つかみ中は自分も相手も無敵にする	
		
		Battle_Std.PassHitMoveCodes(); // ヒット分岐でのMvCode引継ぎ
	}
	function FrameUpdate_Std()
	{
		// なぜかGRDブレイクしたときに相手に無敵が入っていなかったのでここで修正
		// なにかしらの判定で無敵が消えているっぽい
		Battle_Std.SetThrowEnemyMuteki( 1 ); // 投げ中の相手に無敵時間を設定
	}
	function Update_Std() //投げぬけ猶予中
	{
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		if( Def_Sys_ThrowCounterTechMissWaitType )
		{
			// 通常投げとカウンター投げなどで演出時間が変わることで、コンボの入りやすさに差が出てしまう問題がある
			// UNI2は投げの比重が高いので、今作はカウンターやリジェクトミスを掴んだときの演出時間は通常と同じにする
			// ハイド、カグヤ、バティスタ（タメ分割がズレてしまう）
			if( mvs.MvCount>def_FL_Tech ) BMvTbl.SetFinalize(0); //　投げ抜け猶予だけ待って進む
		}
		else
		{
			// すぐ投げるとわかりにくいのでdef_FL_BoundTech分まつ
			if( mvs.MvCount>def_FL_BoundTech ) BMvTbl.SetFinalize(0); //投げ抜け猶予が終わったので終わる
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Throw_F_Hit", [256,"Mv_Teched"] ); //デフォ,[code,mv]...
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
	}	
}

Std_MoveTable.Mv_Throw_F_Hit <- //投げ成立（以降は投げ抜け不可）
{
	function Init_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );

		// ハイドの投げとかワーグナーの強化投げとかもあるので一旦この設定はなしにする
		// Battle_Std.SetNoMovableMove(); // 動けないMV

		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		BMvTbl.SetMvAction( def_MVA_Throw );
		
		//相手の無敵は解除
		local enemy = BMvCore.GetCaptureCharaData();
		if( enemy.push() )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );
			
			enemy.pop();
		}
	
		//まず相手のGRDを減らす
		Battle_Std.GRD_AddValue({ val=def_GRD_ThrowHit, pressure=0, boundplus=1,target=1 });
		Battle_Std.TypeSE_Play({ type="投げつかみ成功" });
		
		//パターンが最後まできてれば次に進む。まだならUpdate中もチェックするからそこで。
		//local s = BMvTbl.GetMvStatus(); // ステータス取得					
		//if( s.DataPattern==def_PAT_Throw_F_TechWait && s.FrameID==0 )

		//逆投げだったらここで反転
		if( BMvTbl.GetPP(def_PP_TechReverse) == 1 )
		{
			// _dp("\n 後ろ投げ");
			BMvTbl.SetMuki(_Direction_Reverse);	//逆投げなんで反転
			Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_ReverseThrow );
		}
		
		Battle_Std.ThrowTech.SetThrowParam(); //エフェクト座標に相手をやられ絵でセット

		//パターンを変更
		BMvTbl.SetPattern(def_PAT_Throw_F_Hit);
		
		Battle_Std.Create_TechDelayCheckObject(); //相手の投げコマンドチェックオブジェクト生成
		
		Battle_Std.PassHitMoveCodes(); // ヒット分岐でのMvCode引継ぎ
		local isSidou = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_SidouHitSkill );
		local isGRDBreakAttack = Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_GRDBreakAttack ); // 割った技

		if( enemy.push() )
		{
			// print("\n 状態クリア:"+_AsFlag_DamageEx);
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_DamageEx, time=0, flag=0 } ); // 特殊やられを消す
			
			BMvTbl.SetCaptureHitFlag( { val=_CaptureHitFlag_Parent, time=255, flag=_ClearFlag_ChangeMv } ); // 掴んだ相手以外の攻撃がヒットしない
			
			// 割れているときに投げを受けたら、ブレイク時間が少し回復する仕様
			// 割った技で相手のブレイク時間が減るのはおかしいので、割った技のあとの始動の投げのときだけ
			if( !isGRDBreakAttack && Def_Sys_ThrowF_BreakTimePar && BMvEff.GRD_GetBreak( 0 )!=0 ) //ブレイク時
			{
				BMvEff.GRD_CorrectBreakTime( 0, Def_Sys_ThrowF_BreakTimePar ); //割合減少
			}
			enemy.pop();
		}
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="投げ成功" });	
	}
	function Finalize_Std() // 
	{
		// ユズリハで分岐ありなので余計なことはしないこと
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
	function LastUpdate_Std() // 
	{
		// ユズリハで分岐ありなので余計なことはしないこと
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
		
		//通常投げ始動は最低保証に制限をかける
		Battle_Std.SetSpHosyoHosei( { type="Throw" } );
		// Battle_Std.SetHosyoHosei_Multi( def_HosyoHosei_NormalThrow );
		// Battle_Std.SetHosyoHosei( def_HosyoHosei_NormalThrow );
	}
}

//相手側に生成される
Std_MoveTable.Mv_Obj_CheckTechDelay <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender  } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );	
	}
	function Update_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		local flags = false;
		//print("\nFrame:"+s.MvCount);

		local p = BMvCore.GetPlayerCharaData(); // 情報を得る
		
		if( p.IsDone ) // 有効かどうか一応チェック
		{
			BMvCore.PushCharaData( p ); // 
				if( BMvTbl.CheckCommandString( { command=["A+D"], lastdelay=1 } ) ) flags = true;
			BMvCore.PopCharaData();
		}
		
		if( flags )
		{
			local frame = (s.MvCount+1);
			// Battle_Std.DrawDebugAttackInfo("TECH LATE: "+frame+"FRAME" );
			// _dm("投げ抜け:"+frame+"F遅い");
			BMvTbl.SetFinalize(0);
		}
		if( s.MvCount>60 ) BMvTbl.SetFinalize(0); //とりあえず遅すぎるのは終わる
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//投げ抜けする側はBoundです
Std_MoveTable.Mv_Teched <- //投げ抜けられ（ガード絵でプルプル）
{
	function Init_Std() // 
	{
		BMvTbl.SetPattern(def_PAT_GuardS); //立ちガードの見た目でプルプルする
		//BMvTbl.SetMuki(_Direction_Auto); //相手の方を向く
		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定 (バーストされない)
		
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );		
		BMvEff.SetExist( { level=_Exist_NoCamera, mode=_ExistMode_Add } ); //カメラから切り離す
		
		BMvTbl.SetLP(0,0); //カウンタ初期化
		BMvTbl.SetLP(1,0); //状態変数初期化

		Battle_Std.CharaBattleActivity_Increment(115,"地上投げ失敗");
	}	
	function FrameUpdate_Std()
	{
		BMvTbl.SetMuki(_Direction_Auto); //相手の方を向く

		local s = BMvTbl.GetMvStatus(); // ステータス取得
		
		//バグ対策
		if( s.MvCount > 60 )
		{
			BMvTbl.SetFinalize(0);
		}
		
		// ここからの処理なんか変な気がする
		// 座標が元から変化しないように書いてあるだけかも？なので触らないでおく
		
		if( s.MvCount%4==0 && BMvTbl.GetLP(1)==0 ) //プルプルさせる
		{
			BMvTbl.SetLP(1,1); //状態変更
			BMvTbl.SetPosition( { x=6, y=0, flags=_Position_ChangeMuki|_Position_Add|_Position_CaptureShift } );
			BMvTbl.Frame_Proc( 0, _ValSet ); //１枚目の絵にする
		}
		else if( (s.MvCount+2)%4==0 && BMvTbl.GetLP(1)==1 )
		{
			BMvTbl.SetLP(1,0); //状態変更
			BMvTbl.SetPosition( { x=-6, y=0, flags=_Position_ChangeMuki|_Position_Add|_Position_CaptureShift } );
			BMvTbl.Frame_Proc( 1, _ValSet ); //２枚目の絵にする
		}
		
		//アニメパターンのループ処理
		if( s.MvCount%6==0 )
		{
			local frame = BMvTbl.Frame_Proc( 0, _ValAdd );
			BMvTbl.Frame_Proc( 1-frame, _ValSet ); //１枚目と２枚目でループ
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
		BMvEff.SetExist( { level=_Exist_NoCamera, mode=_ExistMode_Erase } ); //カメラに含める
	}	
}

//投げ抜け押し返し攻撃
Std_MoveTable.Mv_Bound_0023 <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit();
		//print("\n投げ抜け攻撃！");
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		BMvTbl.SetLP(0,0); //投げ抜けフラグ初期化
		Battle_Std.TypeSE_Play({ type="投げ抜け" });
		BMvTbl.SetPrio( _CharaPrio_Near ); //一番手前にする
		
		BMvEff.AddSkillCount( _SkillCount_ThrowRecover ); // 履歴カウンタを加算
		Battle_Std.MoveCode.AddFlag( def_MC_NoBurst ); // 行動コード(バーストできない)を設定 
		
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_DamageEx, time=255, flag=_ClearFlag_ChangeMv } ); // 特殊やられ
		
		Battle_Std.CharaBattleActivity_Increment(122,"地上投げ抜け成功");
		//投げ抜け成功回数/投げでつかまれた回数
		Battle_Std.CharaBattleActivity_Calc( {
			title="地上投げ抜け成功確率", 
			molecule=Battle_Std.CharaBattleActivity_Count("地上投げ抜け成功"), denominator=(Battle_Std.CharaBattleActivity_Count("投げでつかまれた回数"))
		} );
	}
	function Update_Std()
	{
		//地上状態では符号が反転しないようにする
		if( BMvTbl.CheckPosState( _PosState_Ground  ) )
		{
			//今プラスのベクトルで、次のフレームがマイナスベクトルか？
			local vec = BMvTbl.GetVector( { flags=_Vector_Bound });
			//print(format("\n x:%d addx:%d",vec.x, vec.addx));
			if( (( vec.x<0 ) && ( (vec.x + vec.addx)>=0 )) || (( vec.x>0 ) && ( (vec.x + vec.addx)<=0 )) )
			{
				BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_Bound } );
			}
		}
		local s = BMvTbl.GetMvStatus(); // ステータス取得					
		
		if( s.MvCount>=16 && (BMvTbl.GetLP(0)==0) )
		{
			//相手を押し返すポイント
			BMvTbl.SetLP(0,1); //投げ抜けフラグ
			
			//自分のＧＲＤにボーナス
			Battle_Std.GRD_AddValue( { val=def_GRD_ThrowTech_Success, boundplus=1 } );					
			
			//相手のＧＲＤを減らす
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
			if( enemy.push() )
			{
				BMvEff.GRD_AddValue( { val=def_GRD_ThrowTech_Success_Enemy, pressure=0, boundplus=1 } );
				
				enemy.pop();
			}
			
			//ここで相手を強引に掴んでMv_Bound_0024で開放する？
			//print("\nここ？");
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				local epos = BMvTbl.GetPosition(); // 位置取得
				
				enemy.pop();

				epos = Battle_Std.GamePos2ShiftPos( epos ); //オフセット座標に変換
				
				epos.x /= 128; //ツール座標に
				
				//epos.x += 50; //少し離す

				local ret = BMvEff.CapturePlayer( { target = enemy } );
				if( ret == 1 )
				{
					BMvEff.ThrowParam( { x=epos.x });
					BMvEff.ThrowRelease( { type=24 } );
				}
				
			}
		}
	}
	function FrameUpdate_Std()
	{
		local useval = (BMvEff.GRD_GetJudgeResult()>0)? ( (BMvEff.GRD_CheckStock( { val=-1 } )>=6)? def_GRD_BoundFU_GRD6Vorpal : def_GRD_BoundFU_Vorpal) : def_GRD_BoundFU;
		Battle_Std.GRD_AddValue({ val=useval, pressure=0, boundplus=1 });
	}
	function Finalize_Std() // 
	{
		BtlMvStd.SetBoundFinalize();
	}
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
		BtlMvStd.ClearBound(); // 状態解除
	}
}

//投げ抜けられガードポーズ
Std_MoveTable.Mv_Bound_0024 <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit();
		//print("\n投げ抜けられガード！");
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_nageX=254 } );
		
		Battle_Std.CreateObjectEX({ x=0, y=-250, flags=_Position_ToolShift,
		datatype=1, pat="Eff_TechHit",
		objectflags=_ObjFlags_MoveTimeStopAll
		});
		
		//ヒットストップと揺らしを発生
		BMvEff.SetCamera_Quake( { time=12, type=1, } ); //横ゆれ
		BMvEff.SetStopTime( { time=12, stopme=2 } ); // 自分も停止する＆自分の停止が発生していたらそれの消去もする
		
		BMvTbl.SetPrio( _CharaPrio_Far  ); //一番後ろにする		
		
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_DamageEx, time=255, flag=_ClearFlag_ChangeMv } ); // 特殊やられ
	}
	function Update_Std()
	{
		//地上状態では符号が反転しないようにする
		if( BMvTbl.CheckPosState( _PosState_Ground  ) )
		{
			//今プラスのベクトルで、次のフレームがマイナスベクトルか？
			local vec = BMvTbl.GetVector( { flags=_Vector_Bound });
			//print(format("\n x:%d addx:%d",vec.x, vec.addx));
			if( (( vec.x<0 ) && ( (vec.x + vec.addx)>=0 )) || (( vec.x>0 ) && ( (vec.x + vec.addx)<=0 )) )
			{
				BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_Bound } );
			}
		}
	}
	function FrameUpdate_Std()
	{
		local useval = (BMvEff.GRD_GetJudgeResult()>0)? ( (BMvEff.GRD_CheckStock( { val=-1 } )>=6)? def_GRD_BoundFU_GRD6Vorpal : def_GRD_BoundFU_Vorpal) : def_GRD_BoundFU;
		Battle_Std.GRD_AddValue({ val=useval, pressure=0, boundplus=1 });
	}
	function Finalize_Std() // 
	{
		BtlMvStd.SetBoundFinalize();
	}
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_nageX=0 } );		
		BtlMvStd.ClearBound(); // 状態解除
	}
}

//投げ抜けする側はBoundです
//コマ投げとか用の投げ抜けられ演出
Std_MoveTable.Mv_SkillTeched <- //投げ抜けられ（つかんだ絵でプルプル）
{
	function Init_Std() // 
	{
		//BMvTbl.SetMuki(_Direction_Auto); //振り向きを入れると座標変更前なので逆向いたりするよ
		//BMvTbl.SetPattern(410); //つかみポーズでプルプルする
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );		
	}	
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
	}	
}

//投げ抜けする側はBoundです
//コマ投げとか用の投げ抜けられ演出2(最初からガードポーズに変化している版)
Std_MoveTable.Mv_SkillTechedPatChange <- //投げ抜けられ（つかんだ絵でプルプル）
{
	function Init_Std() // 
	{
		//BMvTbl.SetMuki(_Direction_Auto); //振り向きを入れると座標変更前なので逆向いたりするよ
		BMvTbl.SetPattern(17); //ガードポーズを取る
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );		
	}	
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
	}	
}

//
Std_MoveTable.Mv_SkillTechedRecover <- //投げ抜けられ２（復帰でよけるタイプ）
{
	function Init_Std() // 
	{
		//BMvTbl.SetMuki(_Direction_Auto); //振り向きを入れると座標変更前なので逆向いたりするよ
		//BMvTbl.SetPattern(410); //つかみポーズでプルプルする
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
	}	
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
	}	
}


//イベントとか
//登場タイミングで呼ばれて
// 行動文字列を返す、行動が存在しないまたは""が返されると Mv_Neutral が呼ばれる
// ラウンド頭でスキップした場合もここにとんできて、なんとround=1として扱われる
Std_MoveTable.GetEntranceMvName <- function()
//function Std_MoveTable::GetEntranceMvName()
{
	// print("\n --------- GetEntranceMvName");
	
	local pside = BMvTbl.GetPlayerSide();//0:1Pサイド 1:2Pサイド
	local tagStatus = BMvCore.GetTagStatus();//-1:通常 1:タッグのメイン 0:タッグのパートナー
	local roundst = BMvTbl.GetMvRoundStatus(); // これで判別

	BMvEff.Chara_ClearMessageAll();//トレモとかでの勝利字幕の初期化
	//BSound.BGM_SetFade( { val=100, time=60 } );//BGMの戻し
	
	if( roundst.Round < 0 ) return "Mv_Startup"; // トレーニング -1？0未満だと
	
	if( BMvTbl.TalkScript_IsDone() ) return "Mv_Startup"; // 会話があったらトレーニングと同じ開始状態にする
	
	if( roundst.Round == 0 ) // ラウンド１
	{
		BMvEff.SetCamera_Focus( { time=[0,0,0] } );//カメラ初期化（ラウンドコール時のカメラ処理をリセット）
		BMvEff.ResetCamera();//カメラを中央にする

		local pside = BMvTbl.GetPlayerSide();
		
		//1Pから順番にセリフを言うので待機
		if( pside == 0 ) // 1Por3PならStandby 2Por4PならStandbyWait
		{
			BMvTbl.SetPP( def_PP_StandbyType, def_PP_ST_Standby );
			// print(" -> def_PP_ST_Standby");
		}
		else if( pside == 1 )
		{
			BMvTbl.SetPP( def_PP_StandbyType, def_PP_ST_StandbyWait );
			// print(" -> def_PP_ST_StandbyWait");
		}
	}
	else if( roundst.Round >= 0 ) // ラウンド２以降（もしくはスキップ時）
	{
		BMvEff.SetCamera_Focus( { time=[0,0,0] } );//カメラ初期化（ラウンドコール時のカメラ処理をリセット）
		BMvTbl.SetPP( def_PP_StandbyType, def_PP_ST_Neutral ); // 開幕MV指定
		BMvEff.ResetCamera();//カメラを中央にする
	}
	return "Mv_Startup";

	return "";
}


Std_MoveTable.Mv_Startup <- //開幕かませ・絶対通るようになった
{
	function Init_Std()
	{
		BMvEff.CreateObject( { mvname="Mv_AuraKanriObject", datatype=0 } );
		BMvTbl.SetMoveableFlag( { move=0, time=600, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		
		if( Def_Dbg_LocalDebugScriptPath )
		{
			Battle_Std.DebugFunc.CallStartupDebugScript();
		}
		
		{
			switch( BMvTbl.GetPP( def_PP_StandbyType ) )
			{
			case def_PP_ST_Neutral:
				BMvTbl.SetFinalize(0);
				break;
			case def_PP_ST_Standby:
			case def_PP_ST_StandbyWait:
				BMvTbl.SetFinalize(10);
				break;
			default:
				BMvTbl.SetFinalize(0);
				break;
			}
		}
	}
	function Finalize_Std()
	{
		Battle_Std.SwitchNextMoveTable("Mv_StandbyNoMotionPass", [10,"Mv_Standby"] ); //デフォ,[code,mv]...
	}
}


local setTrainingDummyResetChara = function()
{
	local player = BMvCore.GetPlayerCharaData();
	local enemy = BMvCore.GetEnemyCharaData();
	if( player.push() )
	{
		BMvEff.ThrowRelease( { type="特殊練習開放", x=0, y=0 } );
		BMvTbl.SetNextMoveTable("Mv_TrainingDummyNeutral");
		BMvTbl.SetPosition( { x=-100*128*BMvTbl.GetMuki(), y=0, flags=0 } );
		
		player.pop();
	}
	if( enemy.push() )
	{
		BMvEff.ThrowRelease( { type="特殊練習開放", x=0, y=0 } );
		BMvTbl.SetNextMoveTable("Mv_TrainingDummyNeutral");
		BMvTbl.SetPosition( { x=-100*128*BMvTbl.GetMuki(), y=0, flags=0 } );
		
		enemy.pop();
	}
}

Std_MoveTable.Mv_CharaRestart <-
{
	function Init_Std() : (setTrainingDummyResetChara)
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		
		BMvTbl.SetPattern(990);

		//画面一瞬暗くして位置関係を調整
		BMvEff.FadeProc_Set({type=0, time=[0,2,15] color=0x000000}); //黒くしてから開始
		
		// 処理としてはどうかと思うが、メルカヴァなどは２回呼ばないとうまくいかない
		setTrainingDummyResetChara();
		setTrainingDummyResetChara();

		BMvTbl.SetFinalize();
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
		
		BMvEff.SetCamera_Focus( { time=[0,0,0] } );//カメラ初期化（ラウンドコール時のカメラ処理をリセット）
		BMvEff.ResetCamera();//カメラを中央にする
	}
}



// 特殊なトレーニングをするための監視オブジェクト
// プレイヤー側から生成され、1Pも2Pもプレイヤーだったときは1P側のみ生成される（２つは生成されない）
Std_MoveTable.Mv_TrainingDummyMngInit <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		
		BMvTbl.SetPattern(990);
		
		BMvTbl.SetLP(9,0); // 0:1P 1:2P
		
		BMvTbl.SetFinalize();
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable("Mv_TrainingDummyMng");
	}
}

local TR_CommandType = [
	[
		{ command="A+D", view=["A","+","D"] },
	],
	[
		{ command="A", view=["A"] },
		{ command="B", view=["B"] },
		{ command="C", view=["C"] },
		{ command="D", view=["D"] },
	],
	[
		{ command=Def_CMD_623A, view=["6","2","3","+","A"] },
		{ command=Def_CMD_623B, view=["6","2","3","+","B"] },
		{ command=Def_CMD_623C, view=["6","2","3","+","C"] },
		{ command=Def_CMD_236A, view=["2","3","6","+","A"] },
		{ command=Def_CMD_236B, view=["2","3","6","+","B"] },
		{ command=Def_CMD_236C, view=["2","3","6","+","C"] },
		{ command=Def_CMD_421A, view=["4","2","1","+","A"] },
		{ command=Def_CMD_421B, view=["4","2","1","+","B"] },
		{ command=Def_CMD_421C, view=["4","2","1","+","C"] },
		{ command=Def_CMD_214A, view=["2","1","4","+","A"] },
		{ command=Def_CMD_214B, view=["2","1","4","+","B"] },
		{ command=Def_CMD_214C, view=["2","1","4","+","C"] },
		{ command=Def_CMD_22A, view=["2","2","+","A"] },
		{ command=Def_CMD_22B, view=["2","2","+","B"] },
		{ command=Def_CMD_22C, view=["2","2","+","C"] },
	],
	[
		{ command=Def_CMD_623A, view=["6","2","3","+","A"] },
		{ command=Def_CMD_623B, view=["6","2","3","+","B"] },
		{ command=Def_CMD_623C, view=["6","2","3","+","C"] },
		{ command=Def_CMD_236A, view=["2","3","6","+","A"] },
		{ command=Def_CMD_236B, view=["2","3","6","+","B"] },
		{ command=Def_CMD_236C, view=["2","3","6","+","C"] },
		{ command=Def_CMD_421A, view=["4","2","1","+","A"] },
		{ command=Def_CMD_421B, view=["4","2","1","+","B"] },
		{ command=Def_CMD_421C, view=["4","2","1","+","C"] },
		{ command=Def_CMD_214A, view=["2","1","4","+","A"] },
		{ command=Def_CMD_214B, view=["2","1","4","+","B"] },
		{ command=Def_CMD_214C, view=["2","1","4","+","C"] },
		{ command=Def_CMD_22A, view=["2","2","+","A"] },
		{ command=Def_CMD_22B, view=["2","2","+","B"] },
		{ command=Def_CMD_22C, view=["2","2","+","C"] },
	],
]





// 特殊な練習
Std_MoveTable.Mv_TrainingDummyMng <-
{
	function CheckInit() : (TR_CommandType)
	{
		// これを入れると、ダミー操作ボタンを押したときの挙動がちょっと違和感あり
		// BMvEff.SetObjectRender( { type=2 } );
		// BMvEff.Cockpit_SetView( { mode=2 } ); // ゲージ類非表示
		
		Battle_Std.GS_AddFlag( def_PP_GS_ExtraTrainingMode ); // キャラ操作不能フラグ
		
		BMvTbl.SetLP(0,-30); // チェック終了＆ディレイ　＝反応フレーム

		// 課題がいつでるか
		local rnd = 60 + 30 + BMvEff.Random_Limit(240);
		BMvTbl.SetLP(1,rnd);

		BMvTbl.SetLP(2,0); // ステータス　0:チェック前　1:チェック中　10:チェック終了待機 　11:チェック終了待機(失敗)　15:早すぎて失敗　20:KOがおきたのでエラー回避
		
		local extra_training = Battle_Std.CheckExtraTraining();
		local extra_mode = extra_training-1;
		if( extra_mode < 0 ) extra_mode = 0;
		if( extra_mode > 4 ) extra_mode = 4;
		BMvTbl.SetLP(4,extra_mode); // TR_CommandTypeの種類 0:投げ抜け　1:AorBorCorD　2:必殺技コマンド　4:必殺技コマンド（サドゥン）

		local rnd = BMvEff.Random_Limit(TR_CommandType[extra_mode].len());
		BMvTbl.SetLP(3,rnd); // TR_CommandType
		// _dpn("チェック:"+rnd+" CMD:"+TR_CommandType[rnd].command );
		
		// BMvTbl.SetLP(9,0); // 0:1P 1:2P
		
		BMvEff.CreateObject( { mvname="Mv_CharaRestart", datatype=1 } );
		
		local cores = GetCores();
		if( cores[0].push() )
		{
			local eff = BMvEff.CreateObject( { datatype=1, start_pat="sys_you", mvname="Mv_SystemHereYouAreTraining" } );
			
			cores[0].pop();
		}
		
		local eff = BMvEff.CreateObject( { datatype=1, start_pat="TR_TimingMark", mvname="Mv_TrainingFrameMark" } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera } );
			BMvTbl.SetPosition( { x=0*128, y=-480*128 } );
			eff.pop();
		}
	}
	function GetCores()
	{
		local cores = [BMvCore.GetPlayerCharaData(), BMvCore.GetEnemyCharaData()];
		local side = BMvTbl.GetLP(9);
		
		local ret_cores = [ cores[side] , cores[1-side] ];
		
		return ret_cores;
	}
	function Init_Std()
	{
		// BMvTbl.SetLP(5,0); // 何回目の課題か
		// BMvTbl.SetLP(6,0); // 今までの合計（平均値を出す用）

		CheckInit();
	}
	function FrameUpdate_Std() : (TR_CommandType)
	{
		local input_key = 0; // 0:何も入れていない 1:成功 -1:違うの入れた
		
		local cores = GetCores();
		local cmd_type = BMvTbl.GetLP(3); // TR_CommandType
		local cmd_mode = BMvTbl.GetLP(4); // TR_CommandType
		
		if( (!Battle_Std.CheckExtraTraining() ) && BMvTbl.GetLP(2) != 25 )
		{
			BMvTbl.SetLP(2,25); // 操作不能へ
			
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				BMvTbl.SetNextMoveTable("Mv_StandbyNoMotion");
				BMvTbl.SetRoundEnd(); //戦闘終了状態にする

				player.pop();
			}
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				BMvTbl.SetNextMoveTable("Mv_StandbyNoMotion");
				BMvTbl.SetRoundEnd(); //戦闘終了状態にする

				enemy.pop();
			}
			BMvEff.FadeProc_Set({type=0, time=[0,2,15] color=0x000000}); //黒くしてから開始
			BMvTbl.SetFinalize(0);
		}
		
		if( Battle_Std.RoundisEnd() && BMvTbl.GetLP(2) != 20 )
		{
			BMvTbl.SetLP(2,20); // 操作不能へ
			
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				BMvTbl.SetRoundEnd(); //戦闘終了状態にする

				player.pop();
			}
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				BMvTbl.SetRoundEnd(); //戦闘終了状態にする

				enemy.pop();
			}
		}
			
		
		
		local player = cores[0];
		local enemy = cores[1];
		if( player.push() )
		{
			// input_key = BMvTbl.CheckCommandString( { command=[ "A+D" ], lastdelay=1, } )
			local check_cmd_table = [];
			local cmd_list = TR_CommandType[cmd_mode];
			for( local i=0; i<cmd_list.len(); i++ )
			{
				check_cmd_table.append( cmd_list[i].command );
			}
			
			// input_key = BMvTbl.CheckCommandString( { command=TR_CommandType[cmd_mode][cmd_type].command, lastdelay=1, } )
			local checkl_cmd = BMvTbl.CheckCommandString( { command=check_cmd_table, lastdelay=1, } )
			if( checkl_cmd == (cmd_type+1) )
			{
				input_key = 1;
			}
			else if( checkl_cmd )
			{
				input_key = -1;
			}
			// _dpn("checkl_cmd:"+checkl_cmd+" input_key:"+input_key);

			// ゲージ系のアニメをすべて止める
			BMvEff.GRD_TS_AddValue( { val=-10 } );
			BMvEff.GRD_UseStock( { val=12 } );

			player.pop();
			
			if( enemy.push() )
			{
				// ゲージ系のアニメをすべて止める
				BMvEff.GRD_TS_AddValue( { val=-10 } );
				BMvEff.GRD_UseStock( { val=12 } );
				
				enemy.pop();
			}
			
			
			local mvs = BMvTbl.GetMvStatus();
			if( mvs.CallCount != 0 ) return; // 1Fに1回の処理
			
			// if( BMvTbl.IsCpu()==0 )
			{
				//LP0:リザルトに使う反応フレーム
				//LP1:次のタイミングまでのフレーム
				//LP2:チェック開始したら1
				local result_frame = BMvTbl.GetLP(0)-1; // 格ゲー的に揃える
				local next_timing_frame = BMvTbl.GetLP(1);
				local check_status = BMvTbl.GetLP(2);
				local check_side = BMvTbl.GetLP(9);
				
				// _dpn(check_side+" : "+mvs.MvCount+" next_timing_frame:"+next_timing_frame+" result_frame:"+result_frame);
				

				// ボタンをおしたとき
				if( input_key )
				{
					local set_status = 0;
					if( check_status==1 ) // チェック開始済み
					{
						if( input_key == 1 )
						{
							if( enemy.push() )
							{
								Battle_Std.ThrowTech.TechRelease( { release_kyori=Def_Sys_FixPosAfterThrowTech } ); //投げ抜けされた時の開放処理
								BMvTbl.SetNextMoveTable("Mv_Teched");
								enemy.pop();
							}
							set_status = 10; // 10:成功 11:コマンドミス 15:早すぎ
							
							// 平均を出す
							local kadai_count = BMvTbl.AddLP(5,1); // 何回目の課題か
							local total_frame = BMvTbl.AddLP(6,result_frame); // 今までの合計
							local average_frame = total_frame * 100 / kadai_count;
							_dpn(kadai_count+": "+result_frame+"F AVE:"+average_frame);
							
							local result_str = format("%.2fF (%d/10)",average_frame/100.0,kadai_count);
							_dpn("result_str:"+result_str);
							
							// local word = format("SUCCESS! %2d/%2d",kadai_count,10);
							// _dpn(word);
							
							if( player.push() )
							{
								BMvEff.AttackInfoString_Set({ word=result_str } );
								BMvEff.AttackInfoString_Set({ word="AVERAGE" } );
								player.pop();
							}
							
							// 終わり
							if( kadai_count >= 10 )
							{
								BMvTbl.SetLP(5,0); // 何回目の課題か
								BMvTbl.SetLP(6,0); // 今までの合計（平均値を出す用）
							}
						}
						else
						{
							if( player.push() )
							{
								local word = "Failed...";
								_dpn(word);
								BMvEff.AttackInfoString_Set({ word=word } );
								player.pop();
							}
						
							if( enemy.push() )
							{
								BMvTbl.SetNextMoveTable("Mv_Throw_F_Hit");
								enemy.pop();
							}
							set_status = 11; // 10:成功 11:コマンドミス 15:早すぎ
						}
					}
					else if( check_status==0 ) // まだチェック開始してない
					{
						if( player.push() )
						{
							local word = "Failed... ";//+result_frame+" F";
							_dpn(word);
							BMvEff.AttackInfoString_Set({ word=word } );
							
							BMvTbl.SetPattern(def_PAT_TimeupLose); // 絵だけそれっぽいものにする
							player.pop();
						}
						set_status = 15; // 10:成功 11:コマンドミス 15:早すぎ
					}
					
					if( set_status )
					{
						BMvTbl.SetLP(2,set_status);//Finalizeまで何度も処理しないように
						BMvTbl.SetLP(1,90);//次に進む時間
						return;
					}
				}
				
				if( next_timing_frame > 0 )
				{
					BMvTbl.AddLP(1,-1);
				}
				else
				{
					if( check_status==0 )
					{
						BMvTbl.SetLP(2,1);

						//課題表示タイミング
						// _dpn("CheckStart()");
						BMvTbl.SetLP(0,0); // チェック開始
						// BMvTbl.SetPattern(300);//捕まれ
						
						if( enemy.push() )
						{
							BMvTbl.SetNextMoveTable("Mv_Throw_F_TechWaitTraining");
							enemy.pop();
						}
					}
					else if( check_status==1 )
					{
						// BMvTbl.SetPattern(300);//捕まれ
					}
					else if( check_status>=10 && check_status<20 )
					{
						BMvTbl.SetFinalize(100);
					}
					//毎フレームやること
					BMvTbl.AddLP(0,1);//リザルトのフレームを加算していく
				}
			}
		}
	}
	function Finalize_Std()
	{
		Battle_Std.SwitchNextMoveTable("...",[100,"Mv_TrainingDummyMng"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_TrainingDummyNeutral <-
{
	function Init_Std()
	{
		Battle_Std.InitVector();
		BMvTbl.SetPattern(0);
		BMvTbl.SetMoveableFlag( { move=0, time=1024, flag=_ClearFlag_ChangeMv } ); // Mv中行動不能にする
		BMvTbl.SetPosition( { y=0 } );
		BMvEff.GRD_ClearVorpal( 0 ); // ヴォーパルを解除する

		BMvTbl.SetAngle( { angle=0 } ); // 投げ中に角度を変更しているキャラ対策
	}
}

Std_MoveTable.Mv_TrainingFrameMark <-
{
	function DrawKadaiCommand() : (TR_CommandType)
	{
		local oya = BMvCore.GetParentCharaData();
		if( oya.push() )
		{
			local cmd_type = BMvTbl.GetLP(3); // TR_CommandType
			local cmd_mode = BMvTbl.GetLP(4); // TR_CommandType
			oya.pop();
			
			local cmd_str = TR_CommandType[cmd_mode][cmd_type].view;
			DrawCommandStrings(cmd_str);
		}
	}
	function DrawCommandStrings( _str )
	{
		local cmd_muki_reverse = 0; // 0:通常 1:コマンドが反転
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local muki = BMvTbl.GetMuki();
			// _dpn("muki:"+muki);
			player.pop();
			
			if( muki == -1 ) cmd_muki_reverse = 1;
		}
		// _str = ["A","+","D"]
		local param = {
			["A"] = { pat="TR_Btn", id=0 },
			["B"] = { pat="TR_Btn", id=1 },
			["C"] = { pat="TR_Btn", id=2 },
			["D"] = { pat="TR_Btn", id=3 },
			["+"] = { pat="TR_Plus", id=0 },
			["1"] = { pat="TR_Stick", id=1, r_id=3 },
			["2"] = { pat="TR_Stick", id=2, r_id=2 },
			["3"] = { pat="TR_Stick", id=3, r_id=1 },
			["4"] = { pat="TR_Stick", id=4, r_id=6 },
			["6"] = { pat="TR_Stick", id=6, r_id=4 },
			["7"] = { pat="TR_Stick", id=7, r_id=9 },
			["8"] = { pat="TR_Stick", id=8, r_id=8 },
			["9"] = { pat="TR_Stick", id=9, r_id=7 },
		}
		
		local x_pos = -((_str.len()-1) * (32/2) * 128 );
		
		local window_id = 0;
		local word_len = _str.len();
		// _dpn("word_len:"+word_len);
		if( word_len <= 3 )
		{
			window_id = 0;
		}
		else if( word_len <= 5 )
		{
			window_id = 1;
		}
		else if( word_len <= 6 )
		{
			window_id = 2;
		}
		else if( word_len <= 7 )
		{
			window_id = 3;
		}
		else
		{
			window_id = 4;
		}
		// _dpn("word_len:"+word_len+" window_id:"+window_id)
		
		local eff = BMvEff.CreateObject( { datatype=1, start_pat="TR_Window", x= 0*128, y=80*128 } );
		if( eff.push() )
		{
			BMvTbl.JumpFrameID(window_id);
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_EraseParentPatChange } );
			BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete } );
			BMvTbl.SetPrio(_CharaPrio_Parent_P1 ); // 親+1
			
			
			for( local i=0; i<_str.len(); i++ )
			{
				if( _str[i] in param )
				{
					local use_param = param[_str[i]];
					local eff = BMvEff.CreateObject( { datatype=1, start_pat=use_param.pat, x=x_pos } );
					if( eff.push() )
					{
						local jump_id = (cmd_muki_reverse && "r_id" in use_param)? use_param.r_id : use_param.id;
						BMvTbl.JumpFrameID(jump_id);
						BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_EraseParentPatChange } );
						BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete } );
						BMvTbl.SetPrio(_CharaPrio_Parent_P1 ); // 親+1
						eff.pop();
					}
					x_pos += (32 * 128);
				}
			}
			eff.pop();
		}
	}
	function Init_Std()
	{
		BMvTbl.SetMuki(_Direction_Right); // 右向き固定
		
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete } );
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPrio( _CharaPrio_Near ); //リザルトはかなり手前にする
		
		BMvTbl.SetLP(2,-1); // ステータス

		BMvTbl.JumpFrameID(900); // 最初は非表示から開始する
	}
	function FrameUpdate_Std() : (TR_CommandType)
	{
		local status = BMvTbl.GetLP(2);
		local oya = BMvCore.GetParentCharaData();
		if( oya.push() )
		{
			local frame = BMvTbl.GetLP(0); // 
			local oya_status = BMvTbl.GetLP(2); // 0:チェック前　1:チェック中　10:チェック終了待機
			local cmd_type = BMvTbl.GetLP(3); // TR_CommandType
			local cmd_mode = BMvTbl.GetLP(4); // TR_CommandType
			
			local kadai_count = BMvTbl.GetLP(5); // 何回目の課題か
			local total_frame = BMvTbl.GetLP(6); // 今までの合計
			
			/*
			// 平均を出し終わったので初期化
			// 面倒なので一旦アナウンス命令で入れるだけにする
			local draw_result = 0;
			local average_frame = 0;
			if( kadai_count >= 2 )
			{
				draw_result = 1;
				average_frame = total_frame * 100 / kadai_count;
				// BMvTbl.SetLP(5,0);
				// BMvTbl.SetLP(6,0);
			}
			*/
			
			oya.pop();
			
			if( status != oya_status )
			{
				BMvTbl.SetLP(2,oya_status);
				
				// _dpn("oya_status:"+oya_status);
				
				if( oya_status == 0 ) // 待機開始 ※入ってこないはず
				{
					// _dpn("課題1");
					BMvTbl.SetPattern("TR_TimingMark");
					BMvTbl.JumpFrameID(900);
					
					if( cmd_mode == 1 || cmd_mode == 3 )
					{
						// サドゥンなので表示しない
					}
					else
					{
						DrawKadaiCommand();
					}
				}
				else if( oya_status == 1 ) // 計測開始
				{
					// _dpn("課題2");
					BMvTbl.SetPattern("TR_TimingMark");
					BMvTbl.JumpFrameID(100);
					
					DrawKadaiCommand();
				}
				else if( oya_status == 10 ) // リザルトへ
				{
					// _dpn("課題3");
					BMvTbl.SetPattern("TR_TimingMark");
					BMvTbl.JumpFrameID(900);
					
					frame = frame - 1; // 格ゲー的に揃える
					
					if( frame > 99 ) frame = 99;
					if( frame <  0 ) frame =  0;
					
					local use_count_01 =  frame%10; // 1桁目
					local use_count_10 = (frame/10)%10; // 2桁目
					
					DrawKadaiCommand();
					
					/*
					if( draw_result )
					{
						_dpn("平均:"+average_frame);
					}
					*/
					
					// _dpn("use_count:"+use_count_10+"_"+use_count_01);
					
					local eff = BMvEff.CreateObject( { datatype=1, start_pat="TR_NumShadow", x= 0*128 } );
					if( eff.push() )
					{
						BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_EraseParentPatChange } );
						BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete } );
						BMvTbl.SetPrio(_CharaPrio_Parent_M1 ); // 親-1
						
						local eff = BMvEff.CreateObject( { datatype=1, start_pat="TR_ResultFlash", x= 0*128 } );
						if( eff.push() )
						{
							BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_EraseParentPatChange } );
							BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete } );
							BMvTbl.SetPrio(_CharaPrio_Parent_P1 ); // 親+1
							eff.pop();
						}

						local eff = BMvEff.CreateObject( { datatype=1, start_pat="TR_Num", x= 0*128 } );
						if( eff.push() )
						{
							BMvTbl.JumpFrameID(use_count_01);
							BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_EraseParentPatChange } );
							BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete } );
							BMvTbl.SetPrio(_CharaPrio_Parent_P1 ); // 親+1
							eff.pop();
						}
						local eff = BMvEff.CreateObject( { datatype=1, start_pat="TR_Num", x=-32*128 } );
						if( eff.push() )
						{
							BMvTbl.JumpFrameID(use_count_10);
							BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_EraseParentPatChange } );
							BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete } );
							BMvTbl.SetPrio(_CharaPrio_Parent_P1 ); // 親+1
							eff.pop();
						}
						local eff = BMvEff.CreateObject( { datatype=1, start_pat="TR_F", x= 32*128 } );
						if( eff.push() )
						{
							BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_EraseParentPatChange } );
							BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete } );
							BMvTbl.SetPrio(_CharaPrio_Parent_P1 ); // 親+1
							eff.pop();
						}
						eff.pop();
					}
				}
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}
/*
Std_MoveTable.Mv_TrainingFrameCount1 <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPrio( _CharaPrio_Near ); //リザルトはかなり手前にする
	}
	function FrameUpdate_Std()
	{
		_dpn("処理中...");
		local oya = BMvCore.GetParentCharaData();
		if( oya.push() )
		{
			local frame = BMvTbl.GetLP(0); // 
			oya.pop();
			
			if( frame > 99 ) frame = 99;
			if( frame <  0 ) frame =  0;
			
			local use_count_01 =  frame%10; // 1桁目
			local use_count_10 = (frame/10)%10; // 2桁目
			
			_dpn("use_count:"+use_count_10+"_"+use_count_01);
			
			BMvTbl.JumpFrameID(use_count_01);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_TrainingFrameCount2 <- Std_MoveTable.Mv_TrainingFrameCount1;
*/

/*

■登場Mvメモ
1P
Mv_StandbyCommon1P
(Mv_Neutral)

2P
Mv_StandbyCommon2P
(Mv_Neutral)

↓（画面暗転）

1P
Mv_StandbyNoMotionPass
Mv_StandbyNoMotion
Mv_Neutral

2P
Mv_StandbyNoMotionPass
Mv_StandbyNoMotion
Mv_Neutral
*/


//Pass系
//ボイスを決めてパターンを指定して次に備える
//スタートボタンでスキップした場合もここに入るのでパターンは変えないとダメ
Std_MoveTable.Mv_StandbyNoMotionPass <- //登場演出
{
	function Init_Std()
	{
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		BMvTbl.SetPattern(def_PAT_Neutral);
		
		//ボタンスキップが発生しないように即命令を呼ぶ
		//ボタンスキップが起きるとフリーズする
		BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
		
		// 演出で変な位置に移動していることがある
		// X座標はプログラムで更新されるので大丈夫っぽい
		Battle_Std.InitVector();
		BMvTbl.SetPosition( { y=0 } );
		
		if( Battle_Std.CheckExtraTraining() )
		{
			BMvEff.FadeProc_Set({type=0, time=[0,2,15] color=0x000000}); //位置変更を隠す
		}
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		// 10Fだとトレモでリスタートして即行動すると、CVPにならないバグがある（あった）
		// 9Fだとトレモリスタート時直後の1F操作が記録されない
		if( mvs.MvCount >= 8 )
		{
			BMvTbl.SetFinalize(0);
		}
		else
		{
			BMvTbl.Frame_Proc( 0, _ValSet );//今のパターンの頭に移動
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_StandbyNoMotion" );
	}
	function LastUpdate_Std()
	{
		// トレーニング系のときは開幕のピローンみたいなVP演出系を入れないために一定時間フラグをたてる
		if( Def_Sys_NoPlayTrainingRestartUpsetEffect )
		{
			local isTraining = BMvTbl.GetMvStageStatus().IsTrainingBattle(); // トレーニング系かどうか
			if( isTraining )
			{
				BMvEff.CreateObject( { mvname="Mv_Null_ImmediatelyAfterRestart", datatype=1 } );
			}
		}
	}
}

Std_MoveTable.Mv_StandbyNoMotion <-
{
	function Init_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		
		Battle_Std.InitVector();
		BMvTbl.SetFinalize(0);
		
		//負けラウンドなら覚醒？
		//UNIにあっても良さそうな気はするが…そのまんますぎる
		local isTraining = BMvTbl.GetMvStageStatus().IsTrainingBattle(); // トレーニング系かどうか
		if( !isTraining )
		{
			local rs = BMvTbl.GetMvRoundStatus(); //ラウンドステータス取得
			// _dpn("rs.isLoseRound:"+rs.isLoseRound+" rs.isFirstLoseRound:"+rs.isFirstLoseRound );

			if( rs.isLoseRound && rs.isFirstLoseRound )//負けラウンドかつ初回のみ
			{
				// 覚醒
			}
		}
		
		local extra_training = Battle_Std.CheckExtraTraining();
		if( extra_training )
		{
			// _dpn("投げ抜けテストあり");
			//自分がプレイヤーで相手がCPUなら生成
			//お互いプレイヤーだったりしたらそもそも処理をしない
			local p_iscpu = 0;
			local e_iscpu = 0;
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				p_iscpu = BMvTbl.IsCpu();
				player.pop();
			}
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				e_iscpu = BMvTbl.IsCpu();
				enemy.pop();
			}
		
			if( !p_iscpu && e_iscpu )
			{
				// 自分側
				local eff = BMvEff.CreateObject( { mvname="Mv_TrainingDummyMngInit", datatype=1 } );
				Battle_Std.GS_AddFlag( def_PP_GS_ExtraTrainingMode ); // キャラ操作不能にする
				BMvTbl.SetFinalize(100);
			}
			else if( p_iscpu && !e_iscpu )
			{
				// 相手側
				Battle_Std.GS_AddFlag( def_PP_GS_ExtraTrainingMode ); // キャラ操作不能にする
				BMvTbl.SetFinalize(100);
			}
		}
	}
	function LastUpdate_Std() //
	{
		BMvTbl.SetRoundStart(); //念の為戦闘開始可能状態にする
	}	
	function Finalize_Std()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_TrainingDummyNeutral"] ); //デフォ,[code,mv]...
	}
}

// リスタート直後だけ生成されて、ヴォーパルの演出をかき消すためにフラグをたてる
// トレモ系でのみ有効
Std_MoveTable.Mv_Null_ImmediatelyAfterRestart <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		
		BMvTbl.SetPattern(990);
		Battle_Std.GS_AddFlag( def_PP_GS_ImmediatelyAfterRestart );
		BMvTbl.SetLP(0,0);
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		local rs = BMvTbl.GetMvRoundStatus();
		if( BMvTbl.GetLP(0)==0 && rs.CharaMoveMode == _CharaMoveMode_Enable )
		{
			BMvTbl.SetLP(0,mvs.MvCount);
		}

		local moveable_mvcount = BMvTbl.GetLP(0);
		local time = mvs.MvCount - moveable_mvcount;
		// _dpn("time:"+time);
		if( mvs.MvCount >= 5 || time >= 3 ) // time == 2で十分だが念のため3
		{
			BMvTbl.SetFinalize();
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		Battle_Std.GS_DelFlag( def_PP_GS_ImmediatelyAfterRestart );
	}
}

Std_MoveTable.Mv_Null_StandbyCamera <-
{
	function Init_Std()
	{
		// _dpn("Mv_Null_StandbyCamera");

		// BMvTbl.SetLP(0,0);// だいたいの音声のフレームが入っているのでカメラの移動フレームに使う
		local voice_frame = BMvTbl.GetLP(0);
		local shift_x = 64*128;
		
		//1Pか2Pかで開始座標は決まる
		local pos_x = ( BMvTbl.GetPlayerSide() == 0 )? -320*128 : 320*128;
		
		// BMvEff.SetCamera_Focus( { num=0, x=pos.x+shift_x*BMvTbl.GetMuki(), y=0, zoom=1.0, time=[10,999,0], type_in=1 } );
		// BMvEff.SetCamera_Focus( { num=1, x=pos.x, y=0, zoom=1.0, time=[voice_frame,255,10], type_in=1 } );

		BMvEff.SetCamera_Focus( { num=0, x=0, y=0, zoom=1.0, time=[0,999,0], type_in=1 } );
		BMvEff.SetCamera_Focus( { num=1, x=pos_x+shift_x*BMvTbl.GetMuki(), y=0, zoom=1.0, time=[10,255,10], type_in=1 } );

		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		
		BMvTbl.SetPattern(990);

		// _dpn("開始 voice_frame:"+voice_frame);
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount == 10 )
		{
			local voice_frame = BMvTbl.GetLP(0);
			local shift_x = 64*128;
		
			//1Pか2Pかで開始座標は決まる
			local pos_x = ( BMvTbl.GetPlayerSide() == 0 )? -320*128 : 320*128;

			BMvEff.SetCamera_Focus( { num=0, x=pos_x+shift_x*BMvTbl.GetMuki(), y=0, zoom=1.0, time=[0,999,0], type_in=1 } );
			BMvEff.SetCamera_Focus( { num=1, x=pos_x, y=0, zoom=1.0, time=[voice_frame,255,10], type_in=1 } );
			
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

// アイコンは時間でも勝手に消えるが、スクリプトでも挙動を操作している
Std_MoveTable.Mv_SystemHereYouAre <-
{
	function Init_Std()
	{
		BMvTbl.SetMuki( _Direction_Right );//文字なので右向き固定
		BMvTbl.SetPosition( { y=-435*128, } );
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera } );
		
		BMvTbl.SetLP(0,0);//消滅開始したら1
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount>600 )//保険処理
		{
			BMvTbl.SetFinalize(0);
			return;
		}
		if( Battle_Std.GetUpdateFrameID( mvs ) == 900 )
		{
			BMvTbl.SetLP(0,1); // 勝手に消滅まで進んだ
		}
		
		if( BMvTbl.GetLP(0)==0 )
		{
			local rs = BMvTbl.GetMvRoundStatus();
			if( rs.CharaMoveMode == _CharaMoveMode_Enable )
			{
				// キャラが動けるようになったら消す
				BMvTbl.JumpFrameID(900);
				BMvTbl.SetLP(0,1); // 消滅開始に飛んだので1
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

// トレモの特殊練習用
Std_MoveTable.Mv_SystemHereYouAreTraining <-
{
	function Init_Std()
	{
		BMvTbl.SetMuki( _Direction_Right );//文字なので右向き固定
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_ParentMove } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete } );
		BMvTbl.SetPosition( { x=0, y=-444*128, } );
		
		BMvTbl.SetLP(0,0);//消滅開始したら1
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount>600 )//保険処理
		{
			BMvTbl.SetFinalize(0);
			return;
		}
		if( Battle_Std.GetUpdateFrameID( mvs ) == 900 )
		{
			BMvTbl.SetLP(0,1); // 勝手に消滅まで進んだ
		}
		
		if( BMvTbl.GetLP(0)==0 )
		{
			local rs = BMvTbl.GetMvRoundStatus();
			if( mvs.MvCount >= 60 )
			{
				// キャラが動けるようになったら消す
				BMvTbl.JumpFrameID(900);
				BMvTbl.SetLP(0,1); // 消滅開始に飛んだので1
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//汎用登場
Std_MoveTable.Mv_Standby <- //登場演出1P
{
	function CheckEnemyisEnd()
	{
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			local emv = BMvTbl.GetMvName();
			enemy.pop();
			
			if( emv == "Mv_Neutral" )
			{
				return 1;
			}
		}
		return 0;
	}
	function Init_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=0, time=900, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に

		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(0);
		
		Battle_Std.CallSystemHereYouAre();

		BMvTbl.SetLPEx(1,0,0); // PATでFinalizeした
		BMvTbl.SetLPEx(1,1,0); // 管理から終了予約
		
		//2Pから管理オブジェクトを呼び出す
		if( BMvTbl.GetPlayerSide() == 1 )
		{
			local eff = BMvEff.CreateObject( { mvname="Mv_Null_StandbyCommonManager" } );
			if( eff.push() )
			{
				BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
				
				eff.pop();
			}
		}
	}
	function Update_Std()
	{
		// 保険処理で15秒で抜ける
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount == 900 )
		{
			BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
		}
		
		if( BMvTbl.GetLPEx(1,0)==1 && BMvTbl.GetLPEx(1,1)==1 ) // 終了予約
		{
			BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
			BMvTbl.SetFinalize(100);
		}
	}
	function LastUpdate_Std() //
	{
		BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
	}
	function Finalize_Std() // 
	{
		if( BMvTbl.GetFinalizeCode()==0 )
		{
			// PAT0に行った後再度別PATに行くケースも想定してLPチェックはしない
			{
				local pside = BMvTbl.GetPlayerSide();
				_dpn((pside+1)+"P終わりでPAT0へ");
				BMvTbl.SetLPEx(1,0,1); // PATでFinalizeした
				//ループ
				BMvTbl.SetPattern(0);//立ちポーズへ移動だけする
				// BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
				
				if( CheckEnemyisEnd() )
				{
					BMvEff.Chara_ClearMessageAll();
				}
			}
		}
		else
		{
			_dpn("Finalizeでニュートラルへ");
			BMvTbl.SetNextMoveTable( "Mv_Neutral" );
			
			if( CheckEnemyisEnd() )
			{
				BMvEff.Chara_ClearMessageAll();
			}
		}
	}
}
Std_MoveTable.Mv_Null_StandbyCommonManager <- //登場演出管理マネージャ 2P側から呼ばれる
{
	function GetTimeline( player, timeline_type ) : (CommonStandbyParams)
	{
		local player_no = BMvTbl.GetLP(7+player);
		local num = BMvTbl.GetLP(0+player);
		
		if( player_no in CommonStandbyParams &&
		num in CommonStandbyParams[player_no] &&
		timeline_type in CommonStandbyParams[player_no][num]
		)
		{
			return CommonStandbyParams[player_no][num][timeline_type];
		}
		return 0;
	}
	function Init_Std() : (CommonStandbyParams)
	{
		_dpn("■Mv_Null_StandbyCommonManager----");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_FromParentStop } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		
		//開始時にカメラを画面中央で固定する
		//キャラの開始オフセットが異なることがあり、開始カメラが傾くのを防ぐ
		BMvEff.SetCamera_Focus( { x=0, y=0, zoom=1.0, time=[0,999,0] } );
		
		//参照先テーブルの抽選TL番号
		BMvTbl.SetLP(0,-1); //1Pが抽選したTL番号
		BMvTbl.SetLP(1,-1); //2Pが抽選したTL番号
		
		BMvTbl.SetLP(2,0); //ステップ数
		BMvTbl.SetLP(3,0); // ステップを進ませない残り待機時間）
		BMvTbl.SetLP(4,0); // 参照するのがduetか、さらには反転して参照する必要があるか 1:duet参照 2:反転duet参照
		
		//参照先テーブル
		BMvTbl.SetLP(5,-1); // -1:汎用 0〜:相手キャラ指定(=キャラ番号)
		BMvTbl.SetLP(6,-1); // -1:汎用 0〜:相手キャラ指定(=キャラ番号)
		BMvTbl.SetLP(7,-1); //1Pのキャラ番号
		BMvTbl.SetLP(8,-1); //2Pのキャラ番号
		BMvTbl.SetLP(9,0); //1Pのセリフ中:0 2Pのセリフ中:1
		
		// このオブジェクトが2P側から呼ばれるのでcoreは逆になる
		local cores = [ BMvCore.GetEnemyCharaData(), BMvCore.GetPlayerCharaData() ];
		local chrnos = [0,0];//1Pと2Pのキャラ番号
		
		//1Pと2Pのキャラ番号を取得する
		for( local i=0; i<2; i++ )
		{
			if( cores[i].push() )
			{
				// chrnos[i] = BMvTbl.GetMvStatus().CharaNo;
				chrnos[i] = BMvCore.GetCharaNo();
				cores[i].pop();
			}
			BMvTbl.SetLP(7+i, chrnos[i]);
		}
		
		//0: common / enemy / twin_enemy / duet
		//1:          enemy / twin_enemy / duet
		//2:                  twin_enemy / duet
		//3:                               duet
		local common_pick_ar = [ [], [] ]; // 通常
		local twin_pick_ar  = [ [], [] ]; // お互いに相手を指定
		local duet_pick_ar   = [ [], [] ]; // 掛け合い
		local enemy_pick_ar  = [ [], [] ]; // 相手指定
		
		local duet_pick = 0;
		local enemy_pick = [0,0];
		local array_find = function( tbl, name, enemy_no )
		{
			if( name in tbl && tbl[name].len() > 0 )
			{
				foreach( slot, val in tbl[name] )
				{
					if( val == enemy_no ) // 発見
					{
						return 1;
						break;
					}
				}
				return 0;
			}
			else
			{
				return -1;
			}
		}
		//まずはピックアップ処理を行う
		for( local i=0; i<2; i++ )
		{
			local player_no = chrnos[i];
			local enemy_no = chrnos[1-i];
			
			_dpn((1+i)+"P側("+player_no+") 検索開始...");
			if( player_no in CommonStandbyParams && typeof CommonStandbyParams[player_no] == "array" )
			{
				local tbl = CommonStandbyParams[player_no];
				for( local j=0; j<tbl.len(); j++ )
				{
					//-1:未定義なので成功 0:定義してあってない 1:定義してあって発見
					local pick = ( array_find( tbl[j], "Enemy", enemy_no ) );
					
					if( pick != 0 )
					{
						if( array_find( tbl[j], "ExcludeEnemy", enemy_no ) == 1 )
						{
							pick = 0;//除外が定義してあって見つかったら
						}
						else if( "checkfunc" in tbl[j] )
						{
							// _dpn(j+":checkfunc:"+pick);
							local check_result = 1;//1なら入れる
							if( cores[i].push() )
							{
								check_result = tbl[j].checkfunc();//弾く条件があれば0になる
								cores[i].pop();
							}
							if( check_result == 0 )
							{
								pick = 0;//不採用
							}
						}
						
						if( pick != 0 )
						{
							//確定
							if( "duet_timeline" in tbl[j] )
							{
								_dpn(" -> "+j+" duet");
								duet_pick = 1;//duetあり
								duet_pick_ar[i].append( { pl=i, num=j, type=2, param=tbl[j] } );//抽選に追加
								twin_pick_ar[i].append( { pl=i, num=j, type=2, param=tbl[j] } );//抽選に追加
							}
							else if( pick == 1 )//Enemyが定義してあって成功なら
							{
								_dpn(" -> "+j+" enemy");
								enemy_pick[i] = 1;//有効
								enemy_pick_ar[i].append( { pl=i, num=j, type=1, param=tbl[j] } );//抽選に追加
								twin_pick_ar[i].append( { pl=i, num=j, type=1, param=tbl[j] } );//抽選に追加
							}
							else
							{
								_dpn(" -> "+j);
								common_pick_ar[i].append( { pl=i, num=j, type=0, param=tbl[j] } );//抽選に追加
							}
						}
					}
				}
			}
		}
		
		//どれを使うかレベルを決める
		//twin_pick_arは条件が合えば一番良いpick
		
		local target_pick_ar = [0,0];
		local choice_mode = 0; // 0:通常　1:相手指定　2:duet　3:お互いにenemy指定あり
		if( enemy_pick[0] == 1 && enemy_pick[1] == 1 )
		{
			choice_mode = 3;
			target_pick_ar = twin_pick_ar;
		}
		else if( duet_pick )
		{
			choice_mode = 2;
			target_pick_ar = duet_pick_ar;
		}
		else if( enemy_pick[0] == 1 && enemy_pick[1] == 0 )
		{
			choice_mode = 1;
			target_pick_ar[0] = enemy_pick_ar[0];
			target_pick_ar[1] = common_pick_ar[1];
		}
		else if( enemy_pick[0] == 0 && enemy_pick[1] == 1 )
		{
			choice_mode = 1;
			target_pick_ar[0] = common_pick_ar[0];
			target_pick_ar[1] = enemy_pick_ar[1];
		}
		else
		{
			choice_mode = 0;
			target_pick_ar = common_pick_ar;
		}
		
		//デバッグ用に抽選したメッセージを書き出す
		if( Def_Dbg_LocalDebugMode )
		{
			_dpn("抽選するレベル:"+choice_mode );
			for( local i=0; i<2; i++ )
			{
				local player_no = chrnos[i];
				local enemy_no = chrnos[1-i];
			
				
				for( local j=0; j<target_pick_ar[i].len(); j++ )
				{
					local tmp = target_pick_ar[i][j];
					local target_line = ( "duet_timeline" in tmp.param )? tmp.param.duet_timeline : ( "timeline" in tmp.param )? tmp.param.timeline : 0;
					if( target_line )
					{
						local se = -1;
						for( local k=0; k<target_line.len(); k++ )
						{
							local tmp2 = target_line[k];
							if( "SE" in tmp2 )
							{
								if( "PL" in tmp2 )
								{
									if( tmp2.PL == 0 ) se = tmp2.SE;
								}
								else
								{
									se = tmp2.SE;
								}
							}
						}
						local tag = format("battlevoice_chr%03d_%03d",player_no, se );
						local string = sqfunc.GetExStringText( tag );
						_dpn( format("%dP %d [%3d] %s : %s",(1+i), tmp.type, tmp.num, tag, string ) );
					}
				}
				_dpn("");
			}
		}
		
		//抽選して準備開始
		for( local i=0; i<2; i++ )
		{
			local player_no = chrnos[i];
			local enemy_no = chrnos[1-i];
			
			if( target_pick_ar[i].len() > 0 )
			{
				local use_param_no = BMvEff.Random_Limit( target_pick_ar[i].len() );
				local pick_table = target_pick_ar[i][use_param_no];//pick_arからランダムで１つを抽選する
				if( "duet_timeline" in pick_table.param )
				{
					BMvTbl.SetLP(4,1+i); // 参照するのがduetか、さらには反転して参照する必要があるか 1:duet参照 2:反転duet参照
					BMvTbl.SetLP(0+i, pick_table.num );
					
					if( typeof pick_table.param.WaitPAT[0] == "array" )
					{
						if( cores[i].push() )
						{
							BMvTbl.SetPattern( pick_table.param.WaitPAT[0][0] );
							cores[i].pop();
						}
					}
					else
					{
						if( cores[i].push() )
						{
							BMvTbl.SetPattern( pick_table.param.WaitPAT[0] );
							cores[i].pop();
						}
					}
					
					if( typeof pick_table.param.WaitPAT[1] == "array" )
					{
						if( cores[1-i].push() )
						{
							BMvTbl.SetPattern( pick_table.param.WaitPAT[1][0] );
							cores[1-i].pop();
						}
					}
					else
					{
						if( cores[1-i].push() )
						{
							BMvTbl.SetPattern( pick_table.param.WaitPAT[1] );
							cores[1-i].pop();
						}
					}
					break;//duetやったら抜ける
				}
				else
				{
					if( cores[i].push() )
					{
						if( typeof pick_table.param.WaitPAT == "array" )
						{
							BMvTbl.SetPattern( pick_table.param.WaitPAT[0] );
						}
						else
						{
							BMvTbl.SetPattern( pick_table.param.WaitPAT );
						}
						
						if( "OffsetPosition" in pick_table.param )
						{
							local pos = pick_table.param.OffsetPosition;
							if( typeof pos == "array" )
							{
								BMvTbl.SetPosition( { x=pos[0].x, y=pos[0].y, flags=_Position_CaptureShift|_Position_Add|_Position_ChangeMuki } );
							}
							else
							{
								BMvTbl.SetPosition( { x=pos.x, y=pos.y, flags=_Position_CaptureShift|_Position_Add|_Position_ChangeMuki } );
							}
						}
						cores[i].pop();
			
						BMvTbl.SetLP(0+i, pick_table.num );
					}
				}
			}
		}
		// _dpn("1P:"+BMvTbl.GetLP(7)+" 種:"+BMvTbl.GetLP(5)+" TL:"+BMvTbl.GetLP(0)+" 2P:"+BMvTbl.GetLP(8)+" 種:"+BMvTbl.GetLP(6)+" TL:"+BMvTbl.GetLP(1)+" Duet:"+BMvTbl.GetLP(4) );
		
		// 多分ここでテーブルとかは確定しているはずなので、このデータをもとに1Pと2Pを別に動かす管理オブジェクトを生成するようにしたい
		BMvTbl.SetLPEx(1,1,0); // ノーマル1P step
		BMvTbl.SetLPEx(1,2,0); // ノーマル2P step

		BMvTbl.SetLPEx(1,3,0); // ノーマル1P delay
		BMvTbl.SetLPEx(1,4,0); // ノーマル2P delay
	}
	function UpdateNormalTimeline( use_timeline, now_pl_side )
	{
		// now_pl_side : 1Pのセリフ中:0 2Pのセリフ中:1
		// local step = BMvTbl.GetLP(2);
		local step = BMvTbl.GetLPEx(1,1+now_pl_side);
		local timeline_type = BMvTbl.GetLP(4);// 参照するタイムラインの種類　0:common 1:duet 2:反転duet
		// _dpn("UpdateNormalTimeline:"+now_pl_side+" step:"+step+" delay:"+BMvTbl.GetLPEx(1,3+now_pl_side) );

		if( !use_timeline || step >= use_timeline.len() )
		{
			// もうないので終了予約を入れる
			// _dpn((1+now_pl_side)+"P step over");
			return 0;
		}
		else
		{
			local target_core = 0;
			{
				target_core = (now_pl_side == 1 )? BMvCore.GetPlayerCharaData() : BMvCore.GetEnemyCharaData();
				local tmp_core = (now_pl_side == 1 )? BMvCore.GetPlayerCharaData() : BMvCore.GetEnemyCharaData();
			}
			
			if( BMvTbl.GetLPEx(1,3+now_pl_side) == 0 ) // ステップ停止フレーム中でない
			{
				//Init的タイミング
				local delay = ("delay" in use_timeline[step])? use_timeline[step].delay : 0;
				_dpn("↓Init----:"+step+" delay:"+delay );
				foreach( slot, val in use_timeline[step] )
				{
					_dpn(slot+" : "+val);
				}
				_dpn("↑----Init:"+step);
				
				if( target_core.push() )
				{
					if( "PAT" in use_timeline[step] )
					{
						_dpn("PAT指定あり");
						local mvname = BMvTbl.GetMvName();
						if( mvname == "Mv_Standby" || mvname == "Mv_StandbyCommon1P" || ( Def_Dbg_LocalDebugMode && (mvname == "Mv_Neutral")) )
						{
							_dp("\n"+(now_pl_side+1)+"Pのパターン変更 step:"+step );
							BMvTbl.SetPattern( use_timeline[step].PAT ); // 指定のパターンに変更
						}
						else
						{
							_dp("\n ※もう準備できてるので何もしません");
						}
					}
					else
					{
						_dpn("PAT指定なし");
					}
					if( "SE" in use_timeline[step] )
					{
						_dp("\n"+(now_pl_side+1)+"Pのボイス再生 step:"+step );
						
						local voice_time = ("time" in use_timeline[step])? use_timeline[step].time : delay;
						local camera_time = ("camera_time" in use_timeline[step])? use_timeline[step].camera_time : voice_time;

						local se_flags = ("flags" in use_timeline[step])? use_timeline[step].flags : 0;
						//_dpn("camera_time:"+camera_time);
						
						// 字幕はつけない
						if(1)
						{
							local use_timeline_type = timeline_type;
							if( se_flags&(1<<0) )
							{
								use_timeline_type = 0;
							}
							Battle_Std.Play_SubtitleVoice( use_timeline[step].SE, voice_time, use_timeline_type );
						}
						else
						{
							BSound.SE_Play( { type=_SeType_Player, num=use_timeline[step].SE } );
						}
						
						//カメラ呼び出し処理
						//順番に話すときはあっても良さそうだが、UNIではテンポ重視で基本オフにしておく
						local camera = ("camera" in use_timeline[step])? use_timeline[step].camera : 0;
						if( camera )
						{
							local use_voice_time = camera_time;//voice_time;
							local eff = BMvEff.CreateObject( { mvname="Mv_Null_StandbyCamera", datatype=1 } );
							if( eff.push() )
							{
								if( use_voice_time <= 90 ) use_voice_time = 90;//0div回避と保証フレームということに
								BMvTbl.SetLP(0,use_voice_time);
								
								eff.pop();
							}
						}
					}			
					
					//次のPATのhint予約をする
					local next_step = step+1;
					// _dpn(" use_timeline.len():"+(use_timeline.len()) +" step:"+step+" -> "+next_step );
					if( use_timeline.len()-1 >= next_step )
					{
						if( "PAT" in use_timeline[next_step] )
						{
							//XXX:次のステップのcoreをチェックできていないので、相手キャラの予約を入れていることがある…から怖いのでコメントアウト
							// _dpn("-> hint予約:"+use_timeline[next_step].PAT+" "+delay+"F後");
							// BMvCore.CallEntryBCCachePreTransfer( { pat=use_timeline[next_step].PAT, frame=0, rest=delay } );
						}
					}
					
					target_core.pop();
				}
				
				// ディレイを設定
				if( delay > 0 ) // 停止時間の定義があった
				{
					BMvTbl.SetLPEx(1, 3+now_pl_side, delay ); // ステップを進ませない時間をセット
				}
				else // 定義がないので進める
				{
					step++;
					_dp(" -> ステップ進める");
				}
			}
			else // 停止フレームの定義があったあと
			{
				//Update的タイミング
				local stopframe = BMvTbl.AddLPEx(1,3+now_pl_side,-1); // 残り時間を減らす
				
				if( stopframe <= 0 )
				{
					BMvTbl.SetLPEx(1,3+now_pl_side, 0 ); // delay初期化
					step++;
					_dp(" -> ステップ進める");
				}
			}
		}
		BMvTbl.SetLPEx(1,1+now_pl_side,step); // 進めた分を記憶
		return 1;
	}
	function UpdateDuetTimeline( use_timeline )
	{
		local step = BMvTbl.GetLP(2);
		local timeline_type = BMvTbl.GetLP(4);// 参照するタイムラインの種類　0:common 1:duet 2:反転duet
		local now_pl_side = BMvTbl.GetLP(9); //common用　1Pのセリフ中:0 2Pのセリフ中:1

		if( !use_timeline || step >= use_timeline.len() )
		{
			// _dpn("step over");
			return 0;
		}
		else
		{
			local target_core = 0;
			{
				//duet・反転duet
				target_core = (use_timeline[step].PL == 1-( (timeline_type == 2)? 1 : 0 ) )? BMvCore.GetPlayerCharaData() : BMvCore.GetEnemyCharaData();
				local tmp_core = (use_timeline[step].PL == 1-( (timeline_type == 2)? 1 : 0 ) )? BMvCore.GetPlayerCharaData() : BMvCore.GetEnemyCharaData();
			}
			
			if( BMvTbl.GetLP(3) == 0 ) // ステップ停止フレーム中でない
			{
				//Init的タイミング
				local delay = ("delay" in use_timeline[step])? use_timeline[step].delay : 0;
				_dpn("↓Init----:"+step+" delay:"+delay );
				foreach( slot, val in use_timeline[step] )
				{
					_dpn(slot+" : "+val);
				}
				_dpn("↑----Init:"+step);
				
				if( target_core.push() )
				{
					if( "PAT" in use_timeline[step] )
					{
						_dpn("PAT指定あり");
						local mvname = BMvTbl.GetMvName();
						if( mvname == "Mv_Standby" || mvname == "Mv_StandbyCommon1P" || ( Def_Dbg_LocalDebugMode && (mvname == "Mv_Neutral")) )
						{
							_dp("\n"+(now_pl_side+1)+"Pのパターン変更 step:"+step );
							BMvTbl.SetPattern( use_timeline[step].PAT ); // 指定のパターンに変更
						}
						else
						{
							_dp("\n ※もう準備できてるので何もしません");
						}
					}
					else
					{
						_dpn("PAT指定なし");
					}
					if( "SE" in use_timeline[step] )
					{
						_dp("\n"+(now_pl_side+1)+"Pのボイス再生 step:"+step );
						
						local voice_time = ("time" in use_timeline[step])? use_timeline[step].time : delay;
						local camera_time = ("camera_time" in use_timeline[step])? use_timeline[step].camera_time : voice_time;
						local se_flags = ("flags" in use_timeline[step])? use_timeline[step].flags : 0;
						//_dpn("camera_time:"+camera_time);
						
						// 字幕はつけない
						if(1)
						{
							local use_timeline_type = timeline_type;
							if( se_flags&(1<<0) )
							{
								use_timeline_type = 0;
							}
							Battle_Std.Play_SubtitleVoice( use_timeline[step].SE, voice_time, use_timeline_type );
						}
						else
						{
							BSound.SE_Play( { type=_SeType_Player, num=use_timeline[step].SE } );
						}
						
						//カメラ呼び出し処理
						//順番に話すときはあっても良さそうだが、UNIではテンポ重視で基本オフにしておく
						local camera = ("camera" in use_timeline[step])? use_timeline[step].camera : 0;
						if( camera )
						{
							local use_voice_time = camera_time;//voice_time;
							local eff = BMvEff.CreateObject( { mvname="Mv_Null_StandbyCamera", datatype=1 } );
							if( eff.push() )
							{
								if( use_voice_time <= 90 ) use_voice_time = 90;//0div回避と保証フレームということに
								BMvTbl.SetLP(0,use_voice_time);
								
								eff.pop();
							}
						}
					}			
					
					//次のPATのhint予約をする
					local next_step = step+1;
					// _dpn(" use_timeline.len():"+(use_timeline.len()) +" step:"+step+" -> "+next_step );
					if( use_timeline.len()-1 >= next_step )
					{
						if( "PAT" in use_timeline[next_step] )
						{
							//XXX:次のステップのcoreをチェックできていないので、相手キャラの予約を入れていることがある…から怖いのでコメントアウト
							// _dpn("-> hint予約:"+use_timeline[next_step].PAT+" "+delay+"F後");
							// BMvCore.CallEntryBCCachePreTransfer( { pat=use_timeline[next_step].PAT, frame=0, rest=delay } );
						}
					}
					
					target_core.pop();
				}
				
				// ディレイを設定
				if( delay > 0 ) // 停止時間の定義があった
				{
					BMvTbl.SetLP(3, delay ); // ステップを進ませない時間をセット
				}
				else // 定義がないので進める
				{
					step++;
					_dp(" -> ステップ進める");
				}
			}
			else // 停止フレームの定義があったあと
			{
				//Update的タイミング
				local stopframe = BMvTbl.AddLP(3,-1); // 残り時間を減らす
				
				if( stopframe <= 0 )
				{
					BMvTbl.SetLP(3, 0 ); // delay初期化
					step++;
					_dp(" -> ステップ進める");
				}
			}
		}
		BMvTbl.SetLP(2,step); // 進めた分を記憶
		return 1;
	}

	function Update_Std()
	{
		//デバッグ情報表示
		if( _DevWindows && Def_Dbg_LocalDebugMode )
		{
			local pos = { x=250, y=150 };
			pos.ret <- function() { y+=20 };
			// debugfont.setcolor(color);
			debugfontL.draw(pos.x,pos.y,format("抽選したＴＬ番号 1P:%d 2P:%d",BMvTbl.GetLP(0), BMvTbl.GetLP(1)));
			pos.ret();
			debugfontL.draw(pos.x,pos.y,format("DUETステップ:%d 待機:%3d Duetか?:%d",BMvTbl.GetLP(2), BMvTbl.GetLP(3), BMvTbl.GetLP(4) ));
			pos.ret();
			debugfontL.draw(pos.x,pos.y,format("参照先 1P:%d %d 2P:%d %d どっちのセリフ？:%d",BMvTbl.GetLP(5), BMvTbl.GetLP(7), BMvTbl.GetLP(6), BMvTbl.GetLP(8), BMvTbl.GetLP(9) ));
			pos.ret();
			debugfontL.draw(pos.x,pos.y,format("通常ステップ 1P:%d %3d 2P:%d %3d",BMvTbl.GetLPEx(1,1), BMvTbl.GetLPEx(1,3), BMvTbl.GetLPEx(1,2), BMvTbl.GetLPEx(1,4) ));
			pos.ret();
			
			// まだ進行中なのにゲームが始まるとまずい(スキップ時に字幕だけ残る。PATにEff6-254があると入ってしまう)
			/*
			local rs = BMvTbl.GetMvRoundStatus();
			if( rs.CharaMoveMode != _CharaMoveMode_Disable )
			{
				debugfontL.draw_message( "メッセージに対してPATが終わるのが早すぎる" );
				_dpn("メッセージに対してPATが終わるのが早すぎる:"+rs.CharaMoveMode);
				// BMvTbl.SetFinalize();
				// return;
			}
			*/
		}
		
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount <= 10 )
		{
			return;
		}
		
		local timeline_type = BMvTbl.GetLP(4);// 参照するタイムラインの種類　0:common 1:duet 2:反転duet
		// 汎用かduetか反転duetかで使うタイムラインを選ぶ
		switch( timeline_type )
		{
		case 0://common
			// _dpn("common");
			// 1Pと2Pを同時に進める
			local use_timeline = GetTimeline( 0, "timeline" );
			local update_1p_tl = UpdateNormalTimeline( use_timeline, 0 );

			local use_timeline = GetTimeline( 1, "timeline" );
			local update_2p_tl = UpdateNormalTimeline( use_timeline, 1 );
			
			// もうどっちも更新していない
			if( !update_1p_tl && !update_2p_tl )
			{
				// 終了
				BMvTbl.SetFinalize();
				return;
			}
			break;
		case 1://duet
			// _dpn("duet");
			local use_timeline = GetTimeline( 0, "duet_timeline" );
			local update_duet_tl = UpdateDuetTimeline( use_timeline );
			if( !update_duet_tl )
			{
				BMvTbl.SetFinalize();
			}
			break;
		case 2://反転duet
			// _dpn("rev duet");
			local use_timeline = GetTimeline( 1, "duet_timeline" );
			local update_duet_tl = UpdateDuetTimeline( use_timeline );
			if( !update_duet_tl )
			{
				BMvTbl.SetFinalize();
			}
			break;
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		_dp("\n 最後にフェードつきで戦闘開始可能状態へ移行");
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			BMvTbl.SetLPEx(1,1,1); // 管理から終了予約
			player.pop();
		}
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			BMvTbl.SetLPEx(1,1,1); // 管理から終了予約
			enemy.pop();
		}
		BMvEff.SetCamera_Focus( { time=[0,0,0] } );//カメラ固定をリセット
		BMvEff.Chara_ClearMessageAll();//トレモとかでの勝利字幕の初期化
	}
}
// どんな勝利なのかを取得
// ２回取得するからもしかしたらズレることもあるかもしれない
local get_wintype = function()
{
	local ret_wintype="ラウンド勝利";
	local rs = BMvTbl.GetMvRoundStatus();
	
	local is_ko = Battle_Std.GS_CheckFlag( def_PP_GS_KoAtk ); // 何かしらでKOした？
	if( !is_ko && rs.isWinRound )
	{
		// 決着タイムアップ勝利
		ret_wintype = "決着勝利_タイムアップ"; // タイムアップ決着
	}
	else if( rs.isWinRound )
	{
		// 決着勝利
		ret_wintype = "決着勝利"; // 決着
	}
	else if( !is_ko )
	{
		// タイムアップラウンド勝利
		ret_wintype = "ラウンド勝利_タイムアップ";
	}
	else
	{
		// ラウンド勝利
		ret_wintype = "ラウンド勝利";
	}
	// _dpn("ret_wintype:"+ret_wintype+" is_ko:"+is_ko);
	
	return ret_wintype;
}
local pic_winlife = function()
{
	local ret_winlife = "通常";
	
	local hp_ratio = BCMDTbl.GetHPRatio();
	local rand = BMvEff.Random_Limit(100);
	
	//HPが100%なら圧勝ボイス、0%（1%）なら辛勝ボイスに必ずなる
	//HPが70%以上なら圧勝ボイス、30%以下なら辛勝ボイスにするが、ランダムで通常ボイスにもなる
	
	if( hp_ratio>=100 )
	{
		ret_winlife = "圧勝";
	}
	else if( hp_ratio<=0 )
	{
		ret_winlife = "辛勝";
	}
	else if( hp_ratio>=70 && rand>=50 )
	{
		ret_winlife = "圧勝";
	}
	else if( hp_ratio<=30 && rand>=50 )
	{
		ret_winlife = "辛勝";
	}
	else
	{
		ret_winlife = "通常";
	}	
	
	// _dpn("hp_ratio:"+hp_ratio+" rand:"+rand+" -> "+ret_winlife );
	return ret_winlife;
}
Std_MoveTable.Mv_Win <- //勝利分岐
{
	function Init_Std() : (get_wintype)
	{
		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		
		BMvEff.CreateObject( { x=0, y=0, mvname="Mv_WinCamera" } ); //演出開始
		local wintype = get_wintype(); // 勝利情報取得
		
		switch( wintype )
		{
		case "決着勝利_タイムアップ":
			BMvTbl.SetFinalize(100);
			Battle_Std.Achievement_Unlock(29);//【トロフィー】タイムアップで勝利した
			break;
		case "決着勝利":
			BMvTbl.SetFinalize(200);
			break;
		case "ラウンド勝利":
			BMvTbl.SetFinalize(100);
			break;
		case "ラウンド勝利_タイムアップ":
			BMvTbl.SetFinalize(100);
			Battle_Std.Achievement_Unlock(29);//【トロフィー】タイムアップで勝利した
			break;
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_WinPattern", [100,"Mv_RoundWinPattern"], [200,"Mv_WinPattern"] ); //デフォ,[code,mv]...
	}
}

//勝利時のカメラ注目
Std_MoveTable.Mv_WinCamera <-
{
	function Init_Std()
	{
		//開始位置は画面中央？
		local pos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_DispCamera } );
		BMvTbl.SetPosition(pos);
		
		//このオブジェクトに注目する
		BMvEff.SetCamera_Focus( { charapos=1, zoom=1.0, time=[45,999,60], type_in=3 } );
		
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_NoRender } ); //_ObjFlags_NoRender
		BMvEff.SetExist( { level = _Exist_NoHantei } );
	}
	function FrameUpdate_Std()
	{
		BMvEff.SetCamera_FocusKeep( 999 ); // チュートリアルで長いこと放置されるので無限ループにする
		
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		local maxlen = def_POS_GamenHajiX - (512*128);
		//操作親をホーミングしてカメラの目標にする
		local p = BMvCore.GetPlayerCharaData(); // 情報を得る
		
		if( p.IsDone ) // 有効かどうか一応チェック
		{
			BMvCore.PushCharaData( p ); // 
				local pos = BMvTbl.GetPosition( 0 );
			BMvCore.PopCharaData();
			local posst;
			local tpos = BMvTbl.CCharaPosition(); // 位置情報型の生成
			tpos.y = 0;
			if( pos.x <= -maxlen )
			{
				tpos.x = -maxlen;
				posst = BMvEff.GetPointStatus( { position=tpos } ); // 位置情報取得
				Battle_Std.SetMuki_CCharaPosition( tpos );
			}
			else if(pos.x >= maxlen)
			{
				tpos.x = maxlen;				
				posst = BMvEff.GetPointStatus( { position=tpos } ); // 位置情報取得
				Battle_Std.SetMuki_CCharaPosition( tpos );
			}
			else
			{
				posst = BMvEff.GetPointStatus( { target=p } ); // 位置情報取得
				//常に親の方を向き続ける
				Battle_Std.SetMuki_PlayerPosition();				
			}
			
			if( posst.distance_x>=512 )
			{
				BMvTbl.SetVector( { x=posst.distance_x/20,} );
			}
			else
			{
				Battle_Std.InitVector();
			}
		}
		else
		{
			Battle_Std.InitVector();		
			//print("x");
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.InitVector();
		BMvTbl.SetNextMoveTable( "..." );
	}
} 
Std_MoveTable.Mv_WinPattern <- //決着勝利アニメ
{
	function Init_Std() : (pic_winlife)
	{
		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Win);
		
		local win_life = pic_winlife();
		
		BMvTbl.SetPP(def_PP_TMP0,0); // どの音声を再生したか 0:通常 1:圧勝　2:辛勝
	
		if( Def_Dbg_RoundStatus ) _dp1p("\nけっちゃこ勝利");
		if( Battle_Std.TypeSE_Play({ type="決着勝利", flags=(1<<1) }) == 0 ) //何も再生されなかった
		{
			//残り体力を見て分岐
			switch( win_life )
			{
			case "圧勝":
				Battle_Std.TypeSE_Play({ type="決着勝利_圧勝", flags=(1<<1) });
				BMvTbl.SetPP(def_PP_TMP0,1); // どの音声を再生したか 0:通常 1:圧勝　2:辛勝
				break;
			case "辛勝":
				Battle_Std.TypeSE_Play({ type="決着勝利_辛勝", flags=(1<<1) });
				BMvTbl.SetPP(def_PP_TMP0,2); // どの音声を再生したか 0:通常 1:圧勝　2:辛勝
				break;
			case "通常":
				Battle_Std.TypeSE_Play({ type="決着勝利_通常", flags=(1<<1) });
				BMvTbl.SetPP(def_PP_TMP0,0); // どの音声を再生したか 0:通常 1:圧勝　2:辛勝
				break;
			}
		}		
	}
	function LastUpdate_Std() //
	{
		//念のため
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
	}	
	function Finalize_Std() // 
	{
		//次のラウンドへの処理？
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする？
		BMvTbl.SetNextMoveTable( "Mv_WinPatternEnd" );
	}
}
Std_MoveTable.Mv_WinPatternEnd <-
{
	function Init_Std() // 
	{
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
		
		// 存在すればループアニメに移行（適当）
		BMvTbl.JumpFrameID( 999 );
	}
	function Update_Std()
	{
		if( BMvTbl.GetMvStatus().MvCount == 600 )
		{
			BMvEff.Chara_ClearMessageAll();
		}
	}
	function Finalize_Std() // 
	{
		// どこにもいかないでここで留まる		
	}
}

Std_MoveTable.Mv_RoundWinPattern <- //決着勝利アニメ
{
	function Init_Std() : (get_wintype,pic_winlife)
	{
		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_RoundWin);
		
		local wintype = get_wintype(); // 勝利情報取得
		local win_life = pic_winlife();
		
		if( wintype == "決着勝利_タイムアップ" )
		{
			if( Def_Dbg_RoundStatus ) _dpn("決着勝利_タイムアップ");
			Battle_Std.TypeSE_Play({ type="決着勝利_タイムアップ", flags=(1<<1) });
		}
		else
		{
			if( Def_Dbg_RoundStatus ) _dp1p("\nラウンド取得");
			
			if( wintype == "ラウンド勝利_タイムアップ" && Battle_Std.TypeSE_Play({ type="ラウンド勝利_タイムアップ", flags=(1<<1) }) )
			{
				// _dpn("タイムアップでかつタイムアップの音声が定義されていたので再生");
			}
			else if( Battle_Std.TypeSE_Play({ type="ラウンド勝利", flags=(1<<1) }) )
			{
				// _dpn("タイムアップかどうかはわからないが、ラウンド勝利の音声が定義されていたので再生");
			}
			else
			{
				// _dpn("何も再生されなかったのできっと細かく定義されているはずなので、残り体力を見て分岐して再生");
				switch( win_life )
				{
				case "圧勝":
					Battle_Std.TypeSE_Play({ type="ラウンド勝利_圧勝", flags=(1<<1) });
					break;
				case "辛勝":
					Battle_Std.TypeSE_Play({ type="ラウンド勝利_辛勝", flags=(1<<1) });
					break;
				case "通常":
					Battle_Std.TypeSE_Play({ type="ラウンド勝利_通常", flags=(1<<1) });
					break;
				}
			}
		}		
	}
	function LastUpdate_Std() //
	{
		//念のため
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
	}	
	function Finalize_Std() // 
	{
		//次のラウンドへの処理？
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする？
		BMvTbl.SetNextMoveTable( "Mv_RoundWinPatternEnd" );
	}
}
Std_MoveTable.Mv_RoundWinPatternEnd <-
{
	function Init_Std() // 
	{
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
		
		// 存在すればループアニメに移行（適当）
		BMvTbl.JumpFrameID( 999 );
	}
	function Update_Std()
	{
		if( BMvTbl.GetMvStatus().MvCount == 600 )
		{
			BMvEff.Chara_ClearMessageAll();
		}
	}
	function Finalize_Std() // 
	{
		// どこにもいかないでここで留まる
	}
}

Std_MoveTable.Mv_TimeupLose <- //時間切れ負け
{
	function Init_Std() // 
	{
		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_TimeupLose);
		
		Battle_Std.TypeSE_Play({ type="タイムアップ敗北" });
	}
	function LastUpdate_Std() //
	{
		//念のため
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
	}	
	function Finalize_Std() // 
	{
		//次のラウンドへの処理？
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする？
		BMvTbl.SetNextMoveTable( "Mv_TimeupLoseEnd" );
	}
}
Std_MoveTable.Mv_TimeupLoseEnd <-
{
	function Init_Std() // 
	{
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
		
		// 存在すればループアニメに移行（適当）
		BMvTbl.JumpFrameID( 999 );
	}
	function Finalize_Std() // 
	{
		
	}
}

//ＳＥを遅らせて再生するオブジェクト
Std_MoveTable.Mv_Obj_DelayPlaySE <-
{
	function Init_Std()
	{
		// _dpn("Mv_Obj_DelayPlaySE:"+BMvTbl.GetLP(0)+" - "+BMvTbl.GetLP(1) );
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		//LP0 ディレイ
		//LP1 再生する番号
		//LP2 再生フラグ
		//LP3 音声の長さ　※字幕無しのときは0が入っている
	}
	function Update_Std() //Updateじゃないと投げ関係で不具合でる
	{
		//print(".");
		//LPを減らしていって0になったら再生する
		if( BMvTbl.GetLP(0)>0 )
		{
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				local isUpdate = BMvTbl.GetMvStatus().isUpdate;
				local mvhs = BMvTbl.GetMvHitStatus();
				local isAtkHitStop = (!isUpdate && mvhs.Type&_HitType_Hit && mvhs.Count>0);
				player.pop();
				
				// _dpn("isUpdate:"+isUpdate+" isAtkHitStop:"+isAtkHitStop+" HitStop:"+mvhs.Count );
				
				if( isUpdate || isAtkHitStop )
				{
					//時間停止中じゃないときのみ進める
					//updateしてないときも攻撃があたっててヒットストップがかかってるときは時間停止じゃなくて攻撃ヒット時なので進める
					BMvTbl.AddLP(0,-1);
				}
				// else
				// {
					// _dpn("----------------------------------以前と違う:"+BMvTbl.GetLP(0)+" - "+BMvTbl.GetLP(1) );
				// }
			}
		}
		else //タイミングがきた
		{
			//再生
			local num = BMvTbl.GetLP(1);
			local flags = BMvTbl.GetLP(2);
			local frame = BMvTbl.GetLP(3);
			
			// _dpn("frame:"+frame);
			
			_vdm(format("PlaySE [%3d] -- Delay",num));
			if( frame != 0 )
			{
				local player = BMvCore.GetPlayerCharaData();
				if( player.push() )
				{
					Battle_Std.Play_SubtitleVoice( num, frame+10 ); // 10Fマージン
					player.pop();
				}
			}
			else
			{
				Battle_Std.PlayerSE_Play( num, flags ); //_SeType_Playerのnumを再生して記憶
			}
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}
//ＳＥを遅らせて再生するオブジェクト2 Param0まち
Std_MoveTable.Mv_Obj_DelayParam0PlaySE <-
{
	function Init_Std()
	{
		//print("\n開始");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		//LP0 まつParam0
		//LP1 再生する番号
		//LP2 再生フラグ
		//LP3 音声の長さ　※字幕無しのときは0が入っている
	}
	function Update_Std() //Updateじゃないと投げ関係で不具合でる
	{
		local mvs = Battle_Std.GetPlayerMvStatus();
		// _dpn("."+mvs.Param0+" LP:"+BMvTbl.GetLP(0) );
		//操作親のParam0を監視して一致したら再生
		
		if( mvs.Param0 == BMvTbl.GetLP(0) )
		{
			//再生
			local num = BMvTbl.GetLP(1);
			local flags = BMvTbl.GetLP(2);
			local frame = BMvTbl.GetLP(3);
			
			_vdm(format("PlaySE [%3d] -- DelayParam0",num));
			if( frame != 0 )
			{
				local player = BMvCore.GetPlayerCharaData();
				if( player.push() )
				{
					Battle_Std.Play_SubtitleVoice( num, frame+10 ); // 10Fマージン
					player.pop();
				}
			}
			else
			{
				Battle_Std.PlayerSE_Play( num, flags ); //_SeType_Playerのnumを再生して記憶
			}
			
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}
//共通アクションここまで	


local pat_OkiagariFreeMotionAr = chrparam.Get( { type="起き上がりのフリーモーションパターン", chrnum=_ChrNo } );
local pat_OkiagariFreeMotionFinalizeMv = chrparam.Get( { type="起き上がりのフリーモーションFinalize先", chrnum=_ChrNo } );

Std_MoveTable.Mv_Modori_Okiagari <- // 起き上がりのフリーモーション
{
	function Init_Std() : (pat_OkiagariFreeMotionAr, _ChrNo )
	{
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_OkiagariNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_OkiagariNageMuteki } ); //起き上がり無敵時間を設定
		
		if( _ChrNo == Def_ChrNo_Chr018 )
		{
			BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動不能にする
		}
		else
		{
			BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		}
		
		//起き上がりのフリーモーション
		local mvs = BMvTbl.GetMvStatus();
		switch(mvs.DataPattern)
		{
		case 593:
			if( pat_OkiagariFreeMotionAr[0] )
			{
				BMvTbl.SetPattern(pat_OkiagariFreeMotionAr[0]);
			}
			else
			{
				BMvTbl.SetFinalize(0);
			}
			break;
		case 594:
			if( pat_OkiagariFreeMotionAr[1] )
			{
				BMvTbl.SetPattern(pat_OkiagariFreeMotionAr[1]);
			}
			else
			{
				BMvTbl.SetFinalize(0);
			}
		default:
			BMvTbl.SetFinalize(0);//エラー
			break;		
		}
	}
	function Finalize_Std() : (pat_OkiagariFreeMotionFinalizeMv)
	{
		BMvTbl.SetNextMoveTable( pat_OkiagariFreeMotionFinalizeMv );
	}
}
	


	
	



//登場タイミングで呼ばれる関数
/*
function Std_MoveTable::Startup()
{
	//
	print("\nStartup");
}
*/

//「勝利キャラの」終了タイミングと、タイムアップ時に両者で呼ばれて、
// 行動文字列を返す、行動が存在しないまたは""が返されるとなにもしない
Std_MoveTable.GetResultMvName <- function()
//function Std_MoveTable::GetResultMvName()
{
	//デバッグ処理
	if( 0 )
	{
		local pside = BMvTbl.GetPlayerSide();//0:1Pサイド 1:2Pサイド
		local tagStatus = BMvCore.GetTagStatus();//-1:通常 1:タッグのメイン 0:タッグのパートナー
		local roundst = BMvTbl.GetMvRoundStatus(); // これで判別
		local tag_str = { [-1]="通常キャラ", [1]="メイン", [0]="パートナー" };
	
		_dpn("★GetResultMvName Round:"+roundst.Round+" "+(pside+1)+"Pサイド "+tag_str[tagStatus] );
	}
	
	//_dem("終了:GetResultMvName");
	Battle_Std.PcAuraEffect_AllAuraEnd(); //勝利キャラorタイムアップの両者はこのタイミングでオーラを消す

	local p = BMvTbl.GetMvRoundStatus(); // これで判別
	//print("\n::GetResultMvName" + p.Round + "," + p.isMyKo + "," + p.WinType + " : " + p.isWinRound );

	//if( p.Round < 0 ) return ""; // トレーニング
	if( p.isMyKo )
	{
		// KOされたら倒れているのでポーズを取らない
		//ここにはいってくることはないのではないか？だぶるＫＯでも入ってこない
		//_dem("敗北")
		return "";
	}
	else
	{
		// 起きている、勝ち以外はタイムアップ
		if( p.WinType == 1 ) // 勝ち
		{
			if( Def_Dbg_RoundStatus ) _dm("勝利orタイムアップ勝利");
			return "Mv_Win";
		}
		else
		if( p.WinType == 0 ) // 負け
		{
			if( Def_Dbg_RoundStatus ) _dm("タイムアップ敗北");
			return "Mv_TimeupLose";
		}
		else
		{
			// タイムアップドロー
			if( Def_Dbg_RoundStatus ) _dm("タイムアップドロー");
			return "Mv_TimeupLose";
		}
	}
	return "";
}



//キャラのオーラを出す時にオーラの時間分こいつが出てる
//終了時に持続のフラグを消す
Std_MoveTable.Mv_Obj_CharaAura <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } ); //隠すｗ
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		
		// local PSFlag = BMvTbl.GetLP(0);
	}
	function Update_Std()
	{
		if( BMvTbl.GetLP(0) > 0 )
		{
			BMvTbl.AddLP(0,-1);
		}
		else
		{
			BMvTbl.SetFinalize(0); //オーラの予定されてた持続時間終了
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable(); //ばいばーい
	}
	function LastUpdate_Std()
	{
		//抜ける時にフラグをなんちゃらする
		Battle_Std.PcAuraEffect_CommonAuraEnd();
	}
}

//リバーサル時間を減らすだけのオブジェクト
Std_MoveTable.Mv_Obj_ReversalTime <-
{
	function Init_Std()
	{
		//print("\n開始");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function Update_Std() //Updateじゃないと投げ関係で不具合でる
	{
		local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		BMvCore.PushCharaData( p ); //
			local pp = BMvTbl.GetPP( def_PP_ReversalLeftTime );
			if( pp>0 ) pp--;
			BMvTbl.SetPP( def_PP_ReversalLeftTime, pp );
		BMvCore.PopCharaData();
		
		//print("\n残り:"+pp);
		
		if( pp <= 0) BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//常に持続するオブジェクト（試合が終わると消滅）
//キャラクターのオーラを管理する
Std_MoveTable.Mv_AuraKanriObject <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } ); //隠すｗ
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		if( mvs.CallCount!=0 ) return; // 1フレームに1回のみに変更
		
		if( mvs.MvCount%7==0 ) //気持ち軽くする AC:6 PS3:7
		{
			local noaura = Battle_Std.GetPSFlag(def_PP_PS_NoAura); //オーラは張らないフラグチェック
			if( !noaura ) Battle_Std.PcAuraEffect_AuraCheck(); //オーラが必要ならはる	
		}
	}
	function Update_Std()
	{
		//今何のオーラが出ているか？はPSフラグで管理する
		//GRDでオーラを出すなら、オーラ出ている間持続するオブジェクトを生成
		//何かで上書きされたあと、終わるタイミングでPSフラグはリセットされる
		//いつ終わるかが不明だね
		//汎用上書きオーラ呼び出し関数：オーラつけるだけ
		//汎用上書きオーラ終了関数　　：オーラ消してフラグも消す		
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( player.push() )
		{
			local rs = BMvTbl.GetMvRoundStatus(); //ラウンド取得状態
			local endflag = ((BMvTbl.GetPP(def_PP_PlayerStatus)&def_PP_PS_AuraKanriEnd)!=0);
			
			player.pop();
			if( rs.isKo || endflag ) // 決着or終われフラグがあったら終了
			{
				BMvTbl.SetFinalize(0);
			}
		}
	}
	function Finalize_Std()
	{
		Battle_Std.PcAuraEffect_AllAuraEnd();
		BMvTbl.SetDeleteMoveTable();
	}
}

// コンセントレーションポーズで攻撃するタイプ
Std_MoveTable.Mv_DyingIWEAtk <-
{
	function Init_Std()
	{
		// _dp("\n Mv_DyingIWEAtk Init()");
		
		Battle_Std.MoveCode.AddFlag( def_MC_SPAction ); // 行動コード(ＳＰ)を追加
		
		Battle_Std.SetCharaFlash_LiberateInit(); //光って
		
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Convert);	

		Battle_Std.InitVector(); // ベクトル初期化
		BMvTbl.SetPosition( { y=0 } ); // 地面にくっつける
	
		Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		
		BMvEff.Liberate_End(); // VOを終了させる
		
		if( Def_Sys_FixSetHosyoHosei_IWtoIWE )
		{
			local comboUsedSpSkill = Battle_Std.EnemyDamageFlag_Check( def_DF_UseSpSkill );
			if( comboUsedSpSkill )
			{
				_dpn("IWE:SPの保証補正");
				Battle_Std.SetSpHosyoHosei( { type="SP" } );//２回目の補正をかける
			}
		}

		//発動時にGRDは空になります
		local isVorpal = (BMvEff.GRD_GetJudgeResult()>0);
		
		Battle_Std.GS_DelFlag( def_PP_GS_VorpalDyingIWEAtk ); // VP中のIWEかどうか

		local stock = BMvEff.GRD_CheckStock( { val=-1 } );;
		if( Def_Sys_IWEGRDBreakType == 0 )
		{
			BMvEff.GRD_UseStock( { val=stock } ); // 全消費
			if( isVorpal )
			{
				BMvEff.GRD_ClearVorpal( 0 ); // ヴォーパルを解除する
				Battle_Std.GS_AddFlag( def_PP_GS_VorpalDyingIWEAtk ); // VP中のIWEかどうか
			}
			else
			{
				BMvEff.GRD_SetBreak( 0, def_GRDBF_IWE, def_GRDBF_IWE ); // ブレイク
			}
		}
		else
		{
			if( isVorpal )
			{
				Battle_Std.GS_AddFlag( def_PP_GS_VorpalDyingIWEAtk ); // VP中のIWEかどうか
			}
		}
		
		if( Def_Dbg_LocalDebugScriptPath ) //ローカル環境でのデバッグ時
		{
			Battle_Std.DebugFunc.CallAtkInitScript();
		}
		
		BMvEff.SpGauge_SetLimit( { time=def_FL_EXSLimit_IWEAtk } ); //一定時間ゲージ増加に制限をかける
		BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } ); 
		
		//EXカットインと時間停止をつける　でも技はSPアクション？
		Battle_Std.Init_ExistAtkSkill(); //SPゲージ消費・カットイン呼び出し
		Battle_Std.MoveCode.AddFlag( def_MC_Skill|def_MC_EXAction ); // 行動コード(必殺技)を設定
		BMvTbl.SetMvAction( def_MVA_EXSystem );
		
		Battle_Std.PlayerSE_StopLastPlaySound(); // 同時押し他の技が出るので止める(IWE音声がないかもなので)
		Battle_Std.TypeSE_Play({ type="IWE攻撃" });
		
		local muteki_f = 25 + def_FL_EXCutinStopTime;
		BMvEff.SetPlayerTimer( { muteki_nage=muteki_f, muteki_dage=muteki_f, muteki_nageX=muteki_f, muteki_dageX=muteki_f } ); // ちょっと長めに無敵
		
		
		BMvTbl.SetLP(0,0); // ヒットしたかどうか
		BMvTbl.SetLP(1,0); // カットイン消去したかどうか
		
		// ループの抜け先を予約
		local stopframe = BMvEff.GetFrameIDNum( 256 );
		if( stopframe != -1 ) // FrameIDがあるかどうか
		{
			BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Convert, frame=stopframe, rest=8 } );
		}
	}
	function Start_Std()
	{
		// 無敵攻撃なので
		BMvEff.AttackInfoString_Set({ word=def_AISW_Invincibility,} );
	}
	function FrameUpdate_Std()
	{
		Battle_Std.CallLoopEndCache_FrameID( def_PAT_Convert, 256, 10 ); // キャッシュ予約Pat, 予約FrameID, 何F毎に呼ぶか

		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		local mvcount = mvs.MvCount;
		local frameid = mvs.FrameID;
		local mode = BMvTbl.GetLP(0);
		
		if( frameid == 200 ) BMvTbl.JumpFrameID( 100 ); // 無限ループ
		if( mvs.MvCount > (65 + def_FL_EXCutinStopTime) )
		{
			BMvTbl.SetFinalize( 256 ); // 抜ける
		}
		if( mvs.MvCount > (45 + def_FL_EXCutinStopTime) )
		{
			if( BMvTbl.GetLP(0) == 1 )
			{
				BMvTbl.SetFinalize(512);	
			}
		}
		if( mvs.MvCount == (10 + def_FL_EXCutinStopTime ) && mvs.CallCount == 0 ) // 実際には +5Fぐらいの発生になる
		{
			local vo_eff = BMvEff.CreateObject( { x=0, y=-260, mvname="Mv_DyingIWEAtk_AtkEff", datatype=1, start_pat=99, flags=_Position_ToolShift } );
			if( vo_eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentHitStatus } );
				 
				vo_eff.pop();
			}
		}
		
		if( mvs.MvCount > (25 + def_FL_EXCutinStopTime) )
		{
			if( BMvTbl.GetLP(1) == 0 )
			{
				BMvEff.CutInProc_Erase(); //カットイン消去
				BMvTbl.SetLP(1,1); // 消した記憶
			}		
		}

	}
	function Finalize_Std() // 
	{
		local fc = BMvTbl.GetFinalizeCode(); //今のファイナライズコードを取得
		if( fc != 512 ) // Mv_Skill_IWEXIST 以外
		{
			BMvEff.CutInProc_Erase(); //カットイン消去
		}
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_DyingIWEAtk_Modori"], [512,"Mv_Skill_IWEXIST"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //抜けるときに消す
		if( !BMvTbl.FromFinalize() )
		{
			BMvEff.CutInProc_Erase(); //カットイン消去
		}

		if( Def_Sys_IWEGRDBreakType == 1 && BMvTbl.GetLP(0) == 0 )
		{
			_dpn("ヒットしないで抜けた");
			local isFromVorpal = Battle_Std.GS_CheckFlag( def_PP_GS_VorpalDyingIWEAtk ); // VP中のIWEかどうか
			if( isFromVorpal )
			{
				BMvEff.GRD_ClearVorpal( 0 ); // ヴォーパルを解除する
			}
			else
			{
				BMvEff.GRD_SetBreak( 0, def_GRDBF_IWE, def_GRDBF_IWE ); // ブレイク
			}
		}
	}
}

//コンセントレーションの戻り
//これは行動不可にしておくとdef_PAT_Convertにキャラ差があるのでダメだよ
Std_MoveTable.Mv_DyingIWEAtk_Modori <-
{
	function Init_Std() // 
	{
		Battle_Std.JumpFrameIDEX(256, def_PAT_Convert, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
		BMvTbl.SetMoveableFlag( { move=1, time=64, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); //行動可能に変更		
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

Std_MoveTable.Mv_DyingIWEAtk_AtkEff <-
{
	function Init_Std()
	{
		BMvTbl.SetLP(0,0); // ズームとかは１回だけにする
	}
	function HitInterrupt_Std()
	{
		if( Battle_Std.CheckDamageTiming() )
		{
			local mvs = BMvTbl.GetMvStatus();
			local effhit = BMvTbl.GetLP(0);
			
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				BMvTbl.SetLP(0,1); // ヒット
				// _dp("\n VOeffヒット");
				
				if( effhit == 0 )
				{
					BMvEff.Slowmotion_Set( { time=60, power=6666, power_minus=10000/60 } );
					BMvEff.SetCamera_Focus( { charapos=1, zoom=1.25, time=[8,30,15], type_in=1, type_out=2 } );
					BMvEff.SetCamera_Quake( { time=35, type=2, clear=1 } );
				}

				// 弾ヒットで本体無敵にして、ヒット後相打ちにならないようにする
				local muteki_f = 60;
				BMvEff.SetPlayerTimer( { muteki_nage=muteki_f, muteki_dage=muteki_f, muteki_nageX=muteki_f, muteki_dageX=muteki_f } ); // ちょっと長めに無敵
				
				player.pop();
				
				BMvTbl.SetLP(0,1); // effhitを1にして、玉ヒット処理したよ
			}
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				// 以降の玉とかヒットしないように玉無敵にする
				BMvTbl.SetHitCheckFlag( { type=0, val=_HitCheckFlag_FireBall, time=8, flag=0 } ); // 無敵
				BMvEff.SetPlayerTimer( { muteki_dage=8, } ); // ちょっと無敵
				
				// これをやると肝心の間違いヒットのフォローがきかない
				/*
				local bs = BtlMvStd.GetBoundStatus();
				if( bs.isBound && bs.Num == 239 ) // イグジスト浮かせがちゃんとあたってたら！
				{
				}
				*/
				
				enemy.pop();
			}
		}
	}	
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_IWEAtk_Eff <-
{
	function Init_Std()
	{
	}
	function HitInterrupt_Std()
	{
		if( Battle_Std.CheckDamageTiming() )
		{
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				BMvTbl.SetLP(0,1); // ヒット
				// _dp("\n VOeffヒット");
				
				player.pop();
			}
			
			local mvs = BMvTbl.GetMvStatus();
			//二度チェックする必要あるか？　まぁ念のため
			//（そもそもこれは相手が_MvStFlag_DangerHPDef の時だけ呼ばれるので大丈夫なはずだけど、回復されるかもしれないし…）
			//逆の状況には対応していない。発動時体力あって、ヒット時２５％未満だとダメ。
			if( mvs.flags & _MvStFlag_DangerHPAtk ) //HPが危険状態な相手を殴っている
			{
				local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
				if( player.push() )
				{
					BMvEff.CreateObject( { mvname="Mv_IWEXS_able" } );
					
					player.pop();
				}
			}			
		}
	}	
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_DyingIWEAtk_Land <- 	//リベレート着地
{
	function Init_Std()
	{
		Battle_Std.InitVector(); //ベクトル初期化
		BMvTbl.SetPosition( { y=0 } ); //これで何とか
		BMvTbl.SetPattern(21); //着地パターンにしてしまう
		if( BMvTbl.GetLP(0) == 0 ) // ヒットしてない
		{
			BMvTbl.SetMoveableFlag({ move=0, time=12, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv }); //着地硬直
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

// 即死するIWE
Std_MoveTable.Mv_SpecialIWEXIST <-
{
	function Init_Std()
	{
		// _dp("\n★即死するIWE発動");
		BMvEff.ComboView_Set( { val=-100, type=2 } ); // 減算-200で100以上にする
		BMvEff.ComboView_Set( { val=100, type=0 } ); // 上書き100で補正100%に戻す

		BMvEff.ComboView_Set( { val=-200, type=2 } ); // 減算-200で300にする
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Skill_IWEXIST" );
	}	
}

// クロスキャストヴェールオフからのIW？
// これを経由してエフェクトだしたらするのも無くはない気がする
Std_MoveTable.Mv_ComboVO_IW <-
{
	function Init_Std()
	{
		_dp("\n★コンボVOからのやつ");
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Skill_41236SP" );
	}
}

Std_MoveTable.Mv_Liberate <- 	//リベレート　ヴェールオフ
{
	function StepMode()
	{
		//print("\nStepMode");
		BMvTbl.AddLP(0,1); //モードを進める
		BMvTbl.SetLP(1,0); //カウンタをリセット
		
	}
	function Init_Std() //
	{
		// _dp("\n Mv_Liberate_Init()");
		Battle_Std.MoveCode.AddFlag( def_MC_EXAction ); // 行動コード(ＥＸ)を追加
		BMvTbl.SetMvAction( def_MVA_EXSystem );
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK );
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		
		BMvEff.AddSkillCount( _SkillCount_VeilOff ); // 履歴カウンタを加算
		
		Battle_Std.PlayerSE_StopLastPlaySound(); // 同時押し他の技が出るので止める
	
		//Battle_Std.PcAuraEffect_LiberateInit(); //ヴェールオフのオーラ
		Battle_Std.SetCharaFlash_LiberateInit(); //光って
		
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Liberate);
		
		Battle_Std.InitVector(); // ベクトル初期化
		BMvTbl.SetVector( { x=0, y=-64, addx=0, addy=0, flags=_Vector_Normal } );
		
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		
		BMvEff.GRD_ClearBreak( 0 ); //効果としてブレイクをクリア
		
		BMvTbl.SetPP(def_PP_Temp,0); //汎用変数初期化

		BMvTbl.SetLP(0,0); //状態
		BMvTbl.SetLP(1,0); //状態カウンタ
		BMvTbl.SetLP(2,0); //最大タメではないヴェールオフか
		//BMvTbl.SetLP(3,0); //ＩＦＸ可能条件っす？
		BMvTbl.SetLP(5,0); // 衝撃がヒットしたかどうか
		
		/*
		local isOverLiberate = ( BMvEff.Liberate_Get() == _SpGaugeMode_OverLiberate)? true : false;
		local enemyisDangar = false;
		local enemy = BMvCore.GetNearEnemyCharaData(); // てき
		if( enemy.IsDone )
		{
			BMvCore.PushCharaData( enemy ); //	
				enemyisDangar = (BCMDTbl.GetHPRatio()<=30);
			BMvCore.PopCharaData(); //
		}
		if( isOverLiberate && enemyisDangar )
		{
			BMvTbl.SetLP(3,1); //IFX可能ヴェールオフですのう
		}
		*/
		
		//BMvEff.Slowmotion_Set( { time=999, power=5000 } );
		//BMvTbl.SetLP(9,0);
		
		// FrameIDメモ
		// modeメモ(LP0) ver1.02
		// 10 0 0〜8F:タメ１枚目（0F目）
		// 20 1 0〜2F:タメ２枚目
		// 30 2 0〜2F:発動直前
		// 40 3 0〜2F:爆発絵
		// xx 4 0F:エフェクト呼び出しタイミング
		// 9+3+3+3 18 +2 = 20F
		
		Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		
		if( Def_Dbg_LocalDebugScriptPath ) //ローカル環境でのデバッグ時
		{
			Battle_Std.DebugFunc.CallAtkInitScript();
		}
		
		local checkframe_20 = BMvEff.GetFrameIDNum( 20 );
		local checkframe_30 = BMvEff.GetFrameIDNum( 30 );
		local checkframe_40 = BMvEff.GetFrameIDNum( 40 );
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Liberate, frame=checkframe_20, rest=4 } ); // ボタン離しで飛ぶので予約
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Liberate, frame=checkframe_30, rest=6 } ); // ボタン離しで飛ぶので予約
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Liberate, frame=checkframe_40, rest=8 } ); // ボタン離しで飛ぶので予約
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		local mode = BMvTbl.GetLP(0);
		local cnt = BMvTbl.GetLP(1);
		//local IFX = BMvTbl.GetLP(3);
		BMvTbl.AddLP(1,1); //フレームカウント進める
		
		// _dpn("mode:"+mode+" cnt:"+cnt+" タメ解除:"+BMvTbl.GetLP(2) );
	
		switch( mode ) //mode:LP0
		{
		case 0: //初期
			if( s.FrameID == 20 ) //次の絵まで進んでしまったようだ
			{
				StepMode();
			}
			else if( cnt>=9 )
			{
				StepMode();
			}
			else if( cnt>=6 ) //ver1.02:6
			{
				//ホールドチェック
				local mask = (1<<0)|(1<<1)|(1<<2);
				// タメ開放をナシにする
				// if( BMvTbl.CheckButtonHold( mask ) < 100 ) //要求と一致未満
				{
					BMvTbl.SetLP(2,1); //途中で抜けたのでタメ解除済みフラグ
					StepMode();
				}
			}
			break;
		case 1: //次のタメの絵
			if( s.FrameID == 30 ) //次の絵まで進んでしまったようだ
			{
				StepMode();
			}		
			else if( cnt>=0+2 ) //ver1.02:cnt>1 UNI2β:0
			{
				//ホールドチェック
				local mask = (1<<0)|(1<<1)|(1<<2);
				//ためてないor前の絵でタメを解除していたら抜ける
				if( BMvTbl.CheckButtonHold( mask ) < 100 || BMvTbl.GetLP(2)==1 ) //要求と一致未満orタメ解除済
				{
					BMvTbl.SetLP(2,1); //途中で抜けたのでタメ解除済みフラグ
					StepMode();
				}
				else if( cnt>=2 )
				{
					// _dm("ためきった");
					//タメきった
					BMvTbl.SetFinalize(512); //最大タメヴェールオフ
					BMvTbl.JumpFrameID(20); //この絵でもうちょいまって！
					StepMode();
				}
			}
			if( cnt==0 )
			{
				BMvTbl.JumpFrameID(20);
			}
			break;
		case 2: //抜け先　たぶんタメじゃないの確定
			if( cnt>=0 ) StepMode();  //ver1.02:cnt>1　ver1.03loc:cnt>=0
			if( cnt==0 )
			{
				BMvTbl.JumpFrameID(30);
				BMvTbl.SetVector( { y=-512, flags=_Vector_Normal|_VecFlag_Add } );
			}
			break;
		case 3: //爆発開始
			if( cnt>=0 ) StepMode();  //ver1.02:cnt>1　ver1.03loc:cnt>=0
			if( cnt==0 )
			{
				BMvTbl.JumpFrameID(40);
			}
			break;
		case 4: //ベクトルあたえたり
			if( cnt>=33+4 ) StepMode();
			if( cnt==0 )
			{
				local mvs = BMvTbl.GetMvStatus();
				local isDying = ( mvs.flags & _MvStFlag_DangerHPDef )? 1 : 0; // 瀕死状態
				
				Battle_Std.SetSpHosyoHosei( { type="VO" } );
				
				// タイムアップは消費する（時間稼ぎに使えるので）
				if( !Battle_Std.CharaisKO() ) // KO後に発動すると次のラウンドでゲージが空になってしまうので弾く
				{
					BMvEff.Liberate_Set(); // ヴェールオフ状態をセット
					BMvEff.Liberate_SetType( _LiberateType_Normal ); // 通常ヴェールオフ
					BMvEff.Liberate_SetMinusValue( def_NormalVO_MinusValue );
				}
				
				// ヴェールオフになった時のボーナス
				if( Def_Sys_VeilOff_GRDBonus )
				{
					local addGRD = ( isDying )? 20000 : 10000; // 増加値

					// 発動時にGRDを増加させる
					BMvEff.GRD_AddValue( { val=addGRD, pressure=0, boundplus=0 } );
					//_dp("\n addGRD:"+addGRD);
				}
				BMvEff.SetSpGauge( { mode=_SpGauge_UseAll } ); //ＳＰゲージ全消費
			
				local isOverLiberate = (BMvTbl.GetPP(def_PP_VeilOffGaugeType)==1)? 1 : 0; //0:100%開放 1:200%開放
				
				//相手がのけぞり中かどうかでフラグをつける
				local enemy_isDamage = Battle_Std.CheckEnemyisDamage()? 1 : 0; //

				// if( enemy_isDamage==0 ) //生発動なら
				// {
					// //発動時に体力を消費する
					// if( isOverLiberate )
					// {
						// BMvEff.SetHpGauge( { value=def_HPV_OverLiberate } );
					// }
					// else
					// {
						// BMvEff.SetHpGauge( { value=def_HPV_Liberate } );
					// }
				// }
				
				local vo_eff = BMvEff.CreateObject( { x=0, y=-260, mvname="Mv_Liberate_Eff", datatype=1, start_pat=92, flags=_Position_ToolShift } );
				if( vo_eff.push() )
				{
					BMvTbl.SetLP(0,enemy_isDamage);
					BMvTbl.SetLP(1,isOverLiberate);
					BMvTbl.SetLP(2,0); // 0:通常　1:ため
					
					vo_eff.pop();
				}
				
				// 後ろのもやもや
				local eff = BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=83, flags=_Position_ToolShift } );
				if( eff.push() )
				{
					//暗転時とかは表示しないように
					BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRenderBlackOut|_ObjFlags_NoRenderOrder } );
					
					eff.pop();
				}

				Battle_Std.InitVector(); //ベクトル初期化（何か残ってるとヤバそうなので）
				BMvTbl.SetVector( { x=0, y=-800, addx=0, addy=50, flags=_Vector_Div } );
				Battle_Std.TypeSE_Play({ type="ヴェールオフ" });
				BMvEff.SetCamera_Quake( { type=1, time=30 } ); //画面を横に揺らす

				BMvEff.SetPlayerTimer( { muteki_nage=13, muteki_dage=13 } );
				
				Battle_Std.CharaBattleActivity_Increment(90,"ヴェールオフ使用");
			}
			break;
		case 5: //落下開始
			if( cnt==0 )
			{
				BMvTbl.SetFinalize(0); //落下Mvへ移行
			}
			break;			
		}
		if( s.isLanding ) BMvTbl.SetFinalize(256);
		
		// 衝撃波がヒットしてたら無敵で上書きしていく
		if( BMvTbl.GetLP(5)==1 )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		}		
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Liberate_End",[256,"Mv_Liberate_Land"],[512,"Mv_MaxLiberate"]); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //抜けるときに消す
	}
}

Std_MoveTable.Mv_Liberate_End <- //落下部分
{
	function Init_Std()
	{
		local vec = BMvTbl.GetVector(0);
		if( vec.y <= 0 ) //まだ上昇してるようなら下げよう
		{
			Battle_Std.InitVector(); //ベクトル初期化
			BMvTbl.SetVector( { x=0, y=0, addx=0, addy=250, flags=_Vector_Normal } );
		}
		
		// 衝撃波がヒットしてたら無敵で落下
		if( BMvTbl.GetLP(5)==1 )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		}
		
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.isLanding ) BMvTbl.SetFinalize(256);
	}
	function Finalize_Std()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_Liberate_Land"]); //デフォ,[code,mv]...	
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //抜けるときに消す
	}	
}

Std_MoveTable.Mv_Liberate_Land <- 	//リベレート着地
{
	function Init_Std()
	{
		Battle_Std.InitVector(); //ベクトル初期化
		BMvTbl.SetPosition( { y=0 } ); //これで何とか
		BMvTbl.SetPattern(21); //着地パターンにしてしまう
		local frame = (BMvTbl.GetPP(def_PP_Temp)==1)? def_FL_LiberateHit_LandRecovery : def_FL_Liberate_LandRecovery;
		//着地パターンには進んでるだろうし、状態の移行だけ行って着地硬直を設定する
		BMvTbl.SetMoveableFlag({ move=0, time=frame, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv }); //着地硬直
		
		// 衝撃波がヒットしてたら行動可能になるまでを無敵にする
		if( BMvTbl.GetLP(5)==1 )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=frame, muteki_dage=frame } );
		}
		
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //抜けるときに消す
	}	
}

// コンボＶＯ
Std_MoveTable.Mv_ComboLiberate <- 	//リベレート　ヴェールオフ
{
	function Init_Std() //
	{
		BMvEff.AddSkillCount( _SkillCount_VeilOff ); // 履歴カウンタを加算
		
		//【トロフィー】実戦でクロスキャストヴェールオフを使用した。
		// BMvTbl.Achievement_Unlock(2);
		
		Battle_Std.MoveCode.AddFlag( def_MC_EXAction ); // 行動コード(ＥＸ)を追加
		BMvTbl.SetMvAction( def_MVA_EXSystem );
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
	
		Battle_Std.SetCharaFlash_LiberateInit(); //光って
		
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Liberate);

		Battle_Std.InitVector(); // ベクトル初期化
		BMvTbl.SetVector( { x=0, y=-1800, addx=0, addy=128, flags=_Vector_Div } );
		
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		
		BMvEff.GRD_ClearBreak( 0 ); //効果としてブレイクをクリア
		
		// FrameIDメモ
		// modeメモ(LP0) ver1.02
		// 10 0 0〜8F:タメ１枚目（0F目）
		// 20 1 0〜2F:タメ２枚目
		// 30 2 0〜2F:発動直前
		// 40 3 0〜2F:爆発絵
		// xx 4 0F:エフェクト呼び出しタイミング
		// 9+3+3+3 18 +2 = 20F
		
		Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		
		if( Def_Dbg_LocalDebugScriptPath ) //ローカル環境でのデバッグ時
		{
			Battle_Std.DebugFunc.CallAtkInitScript();
		}
		
		// local checkframe_20 = BMvEff.GetFrameIDNum( 20 );
		// local checkframe_30 = BMvEff.GetFrameIDNum( 30 );
		// local checkframe_40 = BMvEff.GetFrameIDNum( 40 );
		// BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Liberate, frame=checkframe_20, rest=4 } ); // ボタン離しで飛ぶので予約
		// BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Liberate, frame=checkframe_30, rest=6 } ); // ボタン離しで飛ぶので予約
		// BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Liberate, frame=checkframe_40, rest=8 } ); // ボタン離しで飛ぶので予約
		
		BMvTbl.SetLP(0,0); // カウンタ
		
		local stock = BMvEff.GRD_CheckStock( { val=-1 } );

		if( stock>Def_Sys_ChainShiftGRDLimit ) stock=Def_Sys_ChainShiftGRDLimit; //限界を超えないようにする（clrまでは6個制限）

		local isSuperChainShift = (stock>=6)? 1 : 0; //すごいチェインシフトの条件		
		
		local is_celes_vp = Battle_Std.GS_CheckFlag( def_PP_GS_CelecVorpal ); // セレスヴォーパルだったか
		Battle_Std.GS_DelFlag( def_PP_GS_CelecVorpal ); // セレスヴォーパルなのを消す
		if( is_celes_vp )
		{
			isSuperChainShift = 1;
		}
		
		BMvTbl.SetLP(1,isSuperChainShift); // 何もしてないようだ

		BMvEff.GRD_SetConvertBreak( { time=0 } );
		
		BMvEff.GRD_UseStock( { val=20 } );
		
		BMvTbl.SetLP(5,0); // 衝撃がヒットしたかどうか
		
		//CVO発動時・相手が動けないタイミングで演出
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			Battle_Std.DrawInActiveEffect(); // ダメそうな演出だけ入れる
			enemy.pop();
		}
		
		Battle_Std.PlayerSE_StopLastPlaySound(); // 同時押し他の技が出たり前の技の音声があるので止める
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		
		if( mvs.FrameID != 0 )
		{
			local now_fra = BMvTbl.GetLP(0);
			if( mvs.CallCount == 0 ) BMvTbl.AddLP(0,1);
			
			// local frames = [2,2,2,2,3,3,3,3,3];
			local frames = [9,8,6,3,2,3,3,2,2];
			
			local now_total = 0;
			
			if( now_fra >= frames[ mvs.DataFrame%frames.len() ] )
			{
				BMvTbl.SetLP(0,0); // カウンタ初期化
				
				if( mvs.DataFrame+1 >= frames.len() )
				{
					BMvTbl.SetFinalize( 0 ); // 足りないのでエラー回避
					return;
				}
				else
				{
					BMvTbl.Frame_Proc( 1, _ValAdd ); // 進める
				}
			}
			
			switch( Battle_Std.GetUpdateFrameID( mvs ) )
			{
			case 10:
				BMvEff.SetStopTime( { time=28 } ); //チェインシフトの時間停止
				
				local usepat = 104;//( BMvTbl.GetLP(1) )? 76 : 82; //エフェクトのパターンを決める
				BMvEff.CreateObject( { x=0, y=-300, datatype=1, start_pat=usepat, flags=_Position_ToolShift } );
				BMvEff.CutInProc_Set({ time=[3,37,10], cutin_mv="",erasetype=0, bgtype=1 });
				
				
				if( Battle_Std.TypeSE_Play({ type="クロスキャストヴェールオフ" }) )
				{
				}
				else
				{
					Battle_Std.TypeSE_Play({ type="ヴェールオフ" });
				}
				break;
			case 20:

		
				break;
			case 40: // 開放
				local mvs = BMvTbl.GetMvStatus();
				local isDying = ( mvs.flags & _MvStFlag_DangerHPDef )? 1 : 0; // 瀕死状態
				
				Battle_Std.SetSpHosyoHosei( { type="CVO" } );
				
				// 瀕死で、じゃなくて体力の割合で計算で、
				// 瀕死になっていたら共通（以前と同じ）だと、覚醒飛ばしが無くなる
				// 瀕死でのみ強いだと、一応気をつけることができる、はず

				BMvTbl.SetVector( { y=0, addy=0, flags=_Vector_Div } );
				local usepat = ( isDying )? 103 : 102;
				local eff = BMvEff.CreateObject( { datatype=1, mvname="Mv_ComboVO_HitEffect", start_pat=usepat, x=0, y=-200*128 } );
				
				if( !Battle_Std.RoundisEnd() ) // KOやタイムアップ後に発動すると次のラウンドでゲージが空になってしまうので弾く
				{
					BMvEff.Liberate_Set(); // ヴェールオフ状態をセット
					BMvEff.Liberate_SetType( _LiberateType_Combo ); // コンボヴェールオフ
				}
				
				// def_DyingComboVO_MinusValue も def_ComboVO_MinusValue も140なので意味がない
				// local useVal = ( isDying )? def_DyingComboVO_MinusValue : def_ComboVO_MinusValue;
				
				BMvEff.Liberate_SetMinusValue( def_ComboVO_MinusValue );
				
				// ヴェールオフになった時のボーナス
				if( Def_Sys_VeilOff_GRDBonus )
				{
					local addGRD = ( isDying )? 20000 : 10000; // 増加値

					// 発動時にGRDを増加させる
					BMvEff.GRD_AddValue( { val=addGRD, pressure=0, boundplus=0 } );
					//_dp("\n addGRD:"+addGRD);
				}
				BMvEff.SetSpGauge( { mode=_SpGauge_UseAll } ); //ＳＰゲージ全消費
				BMvEff.SetCamera_Quake( { type=1, time=30 } ); //画面を横に揺らす
				
				Battle_Std.CharaBattleActivity_Increment(90,"ヴェールオフ使用"); // CVOは別な気もするけどVOになっていることは確か
				
				// CS同様にリセット
				if( Def_Sys_CVO_ResetAnyLimit )
				{
					Battle_Std.EnemyDamageFlag_Del( def_DF_JumpCanseled ); // 「ジャンプキャンセルをされた」を相手から消す
					Battle_Std.EnemyDamageFlag_Del( def_DF_AerialJumpCanseled ); // 「エリアルジャンプキャンセルをされた」を相手から消す
				}
				break;
			}
		}
		else
		{
			BMvTbl.SetFinalize(0);
		}
		if( mvs.isLanding ) BMvTbl.SetFinalize(256);
		
		// 衝撃波がヒットしてたら無敵で上書きしていく
		if( BMvTbl.GetLP(5)==1 )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_ComboLiberate_End",[256,"Mv_ComboLiberate_Land"]); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //抜けるときに消す
	}
}

Std_MoveTable.Mv_ComboLiberate_End <- //落下部分
{
	function Init_Std()
	{
		local vec = BMvTbl.GetVector(0);
		if( vec.y <= 0 ) //まだ上昇してるようなら下げよう
		{
			Battle_Std.InitVector(); //ベクトル初期化
			BMvTbl.SetVector( { x=0, y=1500, addx=0, addy=250, flags=_Vector_Normal } );
		}
		
		// 衝撃波がヒットしてたら無敵で落下
		if( BMvTbl.GetLP(5)==1 )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		}
		
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		if( mvs.isLanding ) BMvTbl.SetFinalize(256);
	}
	function Finalize_Std()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_ComboLiberate_Land"]); //デフォ,[code,mv]...	
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //抜けるときに消す
	}
}

Std_MoveTable.Mv_ComboLiberate_Land <- 	//リベレート着地
{
	function Init_Std()
	{
		Battle_Std.InitVector(); //ベクトル初期化
		BMvTbl.SetPosition( { y=0 } ); //これで何とか
		BMvTbl.SetPattern(21); //着地パターンにしてしまう
		// BMvTbl.SetMoveableFlag({ move=0, time=frame, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv }); //着地硬直
		
		// 行動可能なので無敵にはしない
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.Mv_BloodCutin <-
{
	function Init_Std()
	{
		BMvTbl.SetPattern( "BloodCutin" );
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( { x=0, y=-281*128 } );

		BMvEff.SetDefaultExtendedEffectDrawing( 0 );//追加効果描画設定
		BMvTbl.SetPrio( _CharaPrio_Parent_BG );
		BMvEff.SetBgPrioEx( { val=1, type=0 } ); //BGのPAniでprio_exを使用するか
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		BMvEff.SetBgPrioEx( { val=0, type=0 } ); //BGのPAniでprio_exを使用するか
	}
}


Std_MoveTable.Mv_ComboVO_HitEffect <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentHitStatus|_ObjFlags_NoGround } );
	}
	function HitInterrupt_Std()
	{
		// ヒット時の処理をデメリット処理を書くと、コンボVO空振りが流行るので注意
		
		if( Battle_Std.CheckDamageTiming() ) //ダメージを与えた
		{
			// あてたらキャラを無敵にする
			if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) != 0 )
			{
				// プレイヤーが自分自身発生させた行動中
				local player = BMvCore.GetPlayerCharaData();
				if( player.push() )
				{
					BMvTbl.SetLP(5,1); // ヒットしたのを伝える
					
					//CVOヒット時はEXSLimitを与える
					//CSカンニングと異なり、こっちは行動可能時にあてても効果あり
					Battle_Std.SetSpecialEXSLimit_Enemy( def_SP_CVO_EXSLimitVal );

					player.pop();
				}
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


//最大タメヴェールオフ
Std_MoveTable.Mv_MaxLiberate <-
{
	function StepMode()
	{
		BMvTbl.AddLP(0,1); //モードを進める
		BMvTbl.SetLP(1,0); //カウンタをリセット
	}
	function Init_Std() //
	{
		//再度無敵にする
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
	
		//変数初期化
		BMvTbl.SetLP(0,2); //状態
		BMvTbl.SetLP(1,0); //状態カウンタ
		BMvTbl.SetLP(2,0); //
		
		BMvTbl.SetLP(3,0); //ＩＦＸ可能条件っす？
		
		BMvTbl.SetLP(5,0); // 衝撃がヒットしたかどうか
		
		
		local isOverLiberate = (BCMDTbl.GetComboGauge() >= 20000)? true : false;
		local enemyisDangar = false;
		local enemy = BMvCore.GetNearEnemyCharaData(); // てき
		if( enemy.IsDone )
		{
			BMvCore.PushCharaData( enemy ); //	
				local es = BMvTbl.GetMvStatus();
				enemyisDangar = (es.flags & _MvStFlag_DangerHPDef);
			BMvCore.PopCharaData(); //
		}
		
		// FrameIDメモ
		// 10:タメ１枚目（0F目）
		// 20:タメ２枚目
		// 30:発動直前		
		
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		local mode = BMvTbl.GetLP(0);
		local cnt = BMvTbl.GetLP(1);
		BMvTbl.AddLP(1,1); //フレームカウント進める
		
		switch( mode )
		{
		case 2: //抜け先
			if( cnt>=4 ) StepMode();

			if( cnt==0 )
			{
				//ＭＡＸためが確定したのでバリバリする
				BSound.SE_Play( { num=74 } ); // ちりちり音
				BMvEff.CreateObject( { x=0, y=-260, mvname="", datatype=1, start_pat=77, flags=_Position_ToolShift } );						
				BMvEff.SetCamera_Quake( { type=2, time=60 } ); //画面を揺らす

				BMvTbl.SetVector( { y=-512, flags=_Vector_Normal|_VecFlag_Add } );

				//BMvEff.Slowmotion_Set( { time=40, power=5000 } ); //スロー演出
				
				//Battle_Std.TypeSE_Play({ type="ヴェールオフ" });		
				
				BMvTbl.JumpFrameID(20);
			}
			break;
		case 3: //爆発開始
			if( cnt>=2 ) StepMode();

			if( cnt==0 )
			{
				BMvTbl.JumpFrameID(30);
			}
			break;
		case 4: //ベクトルあたえたり
			if( cnt>=33 ) StepMode();
			if( cnt==0 )
			{
				local mvs = BMvTbl.GetMvStatus();
				local isDying = ( mvs.flags & _MvStFlag_DangerHPDef )? 1 : 0; // 瀕死状態
				
				Battle_Std.SetSpHosyoHosei( { type="VO" } );
			
				// タイムアップは消費する（時間稼ぎに使えるので）
				if( !Battle_Std.CharaisKO() ) // KO後に発動すると次のラウンドでゲージが空になってしまうので弾く
				{
					BMvEff.Liberate_Set(); // ヴェールオフ状態をセット
					BMvEff.Liberate_SetType( _LiberateType_Max ); // 最大タメヴェールオフ
					BMvEff.Liberate_SetMinusValue( def_MaxVO_MinusValue );
				}
				
				// ヴェールオフになった時のボーナス
				if( Def_Sys_VeilOff_GRDBonus )
				{
					local addGRD = ( isDying )? 20000 : 10000; // 増加値

					// 発動時にGRDを増加させる
					BMvEff.GRD_AddValue( { val=addGRD, pressure=0, boundplus=0 } );
					//_dp("\n addGRD:"+addGRD);
				}
				BMvEff.SetSpGauge( { mode=_SpGauge_UseAll } ); //ＳＰゲージ全消費
			
				BMvTbl.JumpFrameID(40);

				local isOverLiberate = (BMvTbl.GetPP(def_PP_VeilOffGaugeType)==1)? 1 : 0; //0:100%開放 1:200%開放
				
				//最大タメの時は体力消費なし

				//相手がのけぞり中かどうかでフラグをつける
				local enemy_isDamage = Battle_Std.CheckEnemyisDamage()? 1 : 0;
				
				//92:100%生
				//93:100%コンボ
				//94:200%orタメ生
				//95:200%orタメコンボ
				//96:IWX生
				//97:IWXコンボ

				//パターンをコンボ中かどうかで分ける
				local vo_eff = BMvEff.CreateObject( { x=0, y=-260, mvname="Mv_Liberate_Eff", datatype=1, start_pat=93, flags=_Position_ToolShift } );
				if( vo_eff.push() )
				{
					BMvTbl.SetLP(0,enemy_isDamage);
					BMvTbl.SetLP(1,isOverLiberate);
					BMvTbl.SetLP(2,1); // 0:通常　1:ため
					
					vo_eff.pop();
				}				
				
				local eff = BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=83, flags=_Position_ToolShift } );
				if( eff.IsDone )
				{
					BMvCore.PushCharaData( eff ); //	
						//暗転時とかは表示しないように
						BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRenderBlackOut|_ObjFlags_NoRenderOrder } );
					BMvCore.PopCharaData(); //
				}

				Battle_Std.InitVector(); //ベクトル初期化（何か残ってるとヤバそうなので）
				BMvTbl.SetVector( { x=0, y=-800, addx=0, addy=50, flags=_Vector_Div } );
				Battle_Std.TypeSE_Play({ type="ヴェールオフ" });
				BMvEff.SetCamera_Quake( { type=1, time=30 } ); //画面を横に揺らす
				
				Battle_Std.CharaBattleActivity_Increment(90,"ヴェールオフ使用");
			}
			break;
		case 5: //落下開始
			if( cnt==0 )
			{
				BMvTbl.SetFinalize(0); //落下Mvへ移行
			}
			break;			
		}
		if( s.isLanding ) BMvTbl.SetFinalize(256);
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Liberate_End",[256,"Mv_Liberate_Land"]); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //抜けるときに消す
	}	
}


//ヴェールオフ衝撃波エフェクト
Std_MoveTable.Mv_Liberate_Eff <-
{
	function Init_Std() //
	{
		//LP0 ... 1:相手はのけぞり中に出された 0:ふうう
		//LP1 ... 0:100%開放 1:200%開放

		//LP2 ... 0:通常 1:ため
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_ShieldWeakGRDAdd );//被シールドでGRDが多く増える攻撃
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
	}
	function HitInterrupt_Std()
	{
		if( Battle_Std.CheckDamageTiming() ) //ダメージを与えた
		{
			if(Def_Sys_VeilOff_SubEnemyGRDStock)
			{
				//相手のGRDの個数を半分にする
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					local enemy_grd_stock = BMvEff.GRD_CheckStock( { val=-1 } );
					local sub_stock = enemy_grd_stock/2;
					BMvEff.GRD_UseStock( { val=sub_stock } );
					_dpn("ストック:"+enemy_grd_stock+" 減らす数:"+sub_stock);
					enemy.pop();
				}
			}
			
			if( BMvTbl.GetLP(0)==1 ) //コンボ中に出してヒットしたヴェールオフ
			{
				if( Def_Sys_VeilOff_GRDBreak == 1 )
				{
					// 敵のGRD状態取得 
					if( BMvEff.GRD_GetBreak( 1 ) == 0 ) // 0 ブレイクしていない 1 ブレイク 100 チェインシフト中 255 オーバーブレイク
					{
						BMvEff.GRD_ClearVorpal( 1 ); // ヴォーパルを解除する
					}
				}
				BMvTbl.SetPP(def_PP_Temp,1); //着地硬直をヒット時のものにする
			}
			else //生でヒットさせたヴェールオフ
			{
				if( Def_Sys_VeilOff_GRDBreak == 1 )
				{
					local break_time = ( BMvTbl.GetLP(2)==1 )? def_GRDBF_MaxVeilOffDmg : def_GRDBF_VeilOffDmg; // ためVOかどうか
					BMvEff.GRD_SetBreak( 1, break_time, break_time ); //相手をブレイクにする
				}
				else if( Def_Sys_VeilOff_GRDBreak == 2 )
				{
					// 敵のGRD状態取得 
					if( BMvEff.GRD_GetBreak( 1 ) == 0 ) // 0 ブレイクしていない 1 ブレイク 100 チェインシフト中 255 オーバーブレイク
					{
						BMvEff.GRD_ClearVorpal( 1 ); // ヴォーパルを解除する
					}
				}
				
				// VOがヒットしたらVOの時間を少し短くする（切り替えせたので十分）
				if( Def_Sys_StartHitVO_MinusTime )
				{
					local player = BMvCore.GetPlayerCharaData();
					if( player.push() )
					{
						local gauge_status = BMvEff.Liberate_Get();
						if( gauge_status != 0 )
						{
							_dpn("VO時間を減らす:"+Def_Sys_StartHitVO_MinusTime);
							BMvEff.Liberate_Calc( { value=Def_Sys_StartHitVO_MinusTime, mode=0 } );
						}
						player.pop();
					}
				}
				
				BMvTbl.SetPP(def_PP_Temp,1); //着地硬直をヒット時のものにする
			}
			
			// どっちでも
			
			// あてたらキャラを無敵にする
			if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) != 0 )
			{
				// プレイヤーが自分自身発生させた行動中
				local player = BMvCore.GetPlayerCharaData();
				if( player.push() )
				{
					BMvTbl.SetLP(5,1); // ヒットしたのを伝える
					
					player.pop();
				}
			}
			
			// あてた相手にフラグをたてる
			Battle_Std.EnemyDamageFlag_Add( def_DF_HitedVO );//VOをあてられた
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_IWEXS_able <-
{
	function Init_Std()
	{
		// _dm("IFWXS使用可能状態開始");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=-100, flags=_Position_CaptureShift } );
		
		BMvEff.Slowmotion_Set( { time=60, power=6666, power_minus=10000/60 } );

		local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( p.IsDone )
		{
			BMvCore.PushCharaData( p ); //	
				BMvEff.SetCamera_Focus( { charapos=1, zoom=1.25, time=[8,30,15], type_in=1, type_out=2 } );
			BMvCore.PopCharaData(); //
		}
		
		BMvEff.SetCamera_Quake( { time=35, type=2, clear=1 } );
		
		BMvTbl.SetPP(def_PP_IWEXS_ChgVO_Hit,1); //使用可能		
	}
	function Update_Std()
	{
		//コンボ状態が途切れたら終了
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//_dm("."+s.MvCount);
		if( !Battle_Std.CheckEnemyisDamage() )
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		// _dm("IFWXS使用可能状態終了");
		BMvTbl.SetPP(def_PP_IWEXS_ChgVO_Hit,0); //使用不可能		
		BMvTbl.SetDeleteMoveTable();		
	}
}





//チェインシフトすると生成される
//時間でGRDがSPに変換されていく
Std_MoveTable.Mv_Convert_Object <-
{
	//LP0:予約GRD消費ストック　発動時にいくつあるか
	//LP1:SPどんだけ増えたか 見た目はいい加減でもいいから数値ある程度そろえる
	
	//LP2:毎フレームいくつ増やすか
	//LP3:変換時間
	
	function Init_Std()
	{
		// BMvTbl.SetLP(0,0);	// 発動時にいくつあるかの予約
		
		local stock = BMvTbl.GetLP(0); // BMvEff.GRD_CheckStock( { val=-1 } ); // 発動時にいくつあるか取得
		
		local isCanselCS = (BMvTbl.GetPP(def_PP_ChainShiftStatus)==1); //キャンセルチェインシフト
		local enemyisBound = Battle_Std.CheckEnemyisBound(); // 相手がやられ中かどうか

		local cs_time = stock * 25; //チェインシフト変換フレーム　個数で変化
		local sp_frameAdd = 80; //  1Fで増える量 40=4%
		
		// GRD0個でも10%ぐらいは増える。CSゲージは25Fは最低でも出現する。
		if( stock == 0 )
		{
			cs_time = 25;
			sp_frameAdd = 40;
		}

		local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
		
		if( isCanselCS )
		{
			if( enemyisBound ) // 相手がBound中
			{
				cs_time = cs_time * 60 / 100;
			}
			else
			{
				cs_time = cs_time * 40 / 100;
			}
			
			if( player.push() )
			{
				local use_val = def_NormalVO_MinusValue;
				switch( BMvEff.Liberate_GetType() )
				{
				case _LiberateType_Max:
					use_val = def_MaxVO_MinusValue;
					break;
				case _LiberateType_Combo:
					use_val = def_ComboVO_MinusValue;
					break;
				case _LiberateType_Normal:
				default:
					use_val = def_NormalVO_MinusValue;
					break;
				}
				
				BMvEff.Liberate_SetMinusValue( use_val/2 ); // CS中のVOの減少割合
				
				player.pop();
			}
		}
		else //ノーキャン時
		{
			if( enemyisBound ) // 相手がBound中
			{
				cs_time = cs_time * 80 / 100;
			}
			else
			{
				// sp_frameAdd = sp_frameAdd * 100 / 100;
			}		
		
			if( player.push() )
			{
				BMvEff.Liberate_SetMinusValue( 0 ); // CS中のVOの減少割合
				
				player.pop();
			}
		}
		// _dp("\n CS:"+stock+" cancel:"+isCanselCS+" bound:"+enemyisBound+" time:"+cs_time+" plus:"+(cs_time*sp_frameAdd)/100 );

		//記憶
		BMvTbl.SetLP(2, sp_frameAdd);
		BMvTbl.SetLP(3,cs_time);

		BMvEff.GRD_ClearBreak( 0 );
		BMvEff.GRD_SetConvertBreak( { time=cs_time } ); // 開始※なんか微妙に10Fぐらい長くなるようなのでLPで抜ける

		//発動時にGRDは空になります
		if( player.push() )
		{
			local stock = BMvEff.GRD_CheckStock( { val=-1 } );
			BMvEff.GRD_UseStock( { val=stock } ); // 全消費
			
			player.pop();
		}
		
		// 出力チェック
		//_dm( format( "チェインシフト開始[ stock:%d time:%d ]", stock, convert_time ) );		
	}
	function Update_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.MvCount<=2 ) return; //最初ちょろっとEXSが増えてしまうのを防止
		
		//
		local isconvert = 1; // 継続中かどうか
		BMvTbl.AddLP(3,-1); //残りチェインシフト時間を減らす
		
		local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
	
		if( BMvTbl.GetLP(3)<0 || BMvEff.GRD_GetBreak(0) != 100 ) // チェインシフト状態でなくなる条件
		{
			if( player.push() )
			{
				local stock = BMvEff.GRD_CheckStock( { val=-1 } );
				BMvEff.GRD_UseStock( { val=stock } ); // 全部消費
				BMvEff.GRD_ClearBreak( 0 ); // クリアはされてるけど
				
				player.pop();
			}

			BMvTbl.SetFinalize(0);
			isconvert = 0; //
			//print("\n終わり");
		}

		//チェインシフトのボーナス前にタイマーチェック
		//終了条件は一応これの前にチェックする
		local rs = BMvTbl.GetMvRoundStatus();
		//print("\nrs:"+rs.TimeUpdate);
		if( rs.TimeUpdate==0 ) //タイマーが進んでいないので
		{
			//print("\nとまれ");
			//return;
		}		

		if( isconvert ) // コンバート状態継続中
		{
			// ゲージふやし
			
			local SPadd = BMvTbl.GetLP(2); //１フレームに増やす量
			
			if( player.push() )
			{
				BMvEff.SetSpGauge( { value=SPadd } ); // ＳＰを増加
				
				player.pop();
			}
			//BMvTbl.AddLP(1,-1);
			//local lp = BMvTbl.GetLP(1);
			//if( lp<=0 ) BMvTbl.SetFinalize(0);

			//local z = BMvEff.GRD_GetBreak(0);				
			//print(format(" GB:%d %d : %d",z, s.MvCount, lp));
		}

	}	
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
		if( player.push() )
		{
			local use_val = def_NormalVO_MinusValue;
			switch( BMvEff.Liberate_GetType() )
			{
			case _LiberateType_Max:
				use_val = def_MaxVO_MinusValue;
				break;
			case _LiberateType_Combo:
				use_val = def_ComboVO_MinusValue;
				break;
			case _LiberateType_Normal:
			default:
				use_val = def_NormalVO_MinusValue;
				break;
			}
			
			BMvEff.Liberate_SetMinusValue( use_val ); // CS中のVOの減少割合
			
			player.pop();
		}
	}
}


//チェインシフト
Std_MoveTable.Mv_Convert <- 	//リバースコンバート
{
	function Init_Std() //
	{
		BMvEff.AddSkillCount( _SkillCount_ChainShift ); // 履歴カウンタを加算
	
		//今のベクトルを記憶
		local vec = BMvTbl.GetVector(0);
		BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=vec.addx, addy=vec.addy, flags=_Vector_Keep } ); //保存ベクトルに与える
		
		//行動不能で無敵にする
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_dageX=254, muteki_nageX=254 } );			
		
		// ・時間無敵を設定する
		// ・時間停止を設定する（こうなると自分の時間無敵は時間停止中も進む）
		// ・相手も同時に時間停止を発生させる
		// ・先に自分の時間停止が終わる→時間無敵は途切れた状態で相手の時間停止状態が続く
		// という状況があるので、無敵時間は長めに入れておくこと
	
		//共通処理
		BMvTbl.SetMuki(_Direction_Auto); //振り向く
		
		//ＧＲＤの端数を削って何個もっているか取得する
		//ＧＲＤが６個以上だったらすごいチェインシフトとする
		//BMvEff.GRD_UseStock( { val=0 } ); //端数を削る　※この処理不要
		local stock = BMvEff.GRD_CheckStock( { val=-1 } );

		if( stock>Def_Sys_ChainShiftGRDLimit ) stock=Def_Sys_ChainShiftGRDLimit; //限界を超えないようにする（clrまでは6個制限）
		
		// if( stock<1 ) stock=1; //最低でも1個扱いにする？ 1個あるときのメリットが無いからNG

		local isSuperChainShift = (stock>=6)? 1 : 0; //すごいチェインシフトの条件
		
		local is_celes_vp = Battle_Std.GS_CheckFlag( def_PP_GS_CelecVorpal ); // セレスヴォーパルだったか
		Battle_Std.GS_DelFlag( def_PP_GS_CelecVorpal ); // セレスヴォーパルなのを消す
		if( is_celes_vp )
		{
			isSuperChainShift = 1;
		}
		
		//print("\n isSuperChainShift:"+isSuperChainShift);

		if( isSuperChainShift ) //すごいチェインシフト
		{
			// BMvTbl.Achievement_Unlock(4); // 【トロフィー】ゲージ回収120％！
			
			//補正をゆるくする（少し回復するイメージ）
			local hosei = BMvEff.ComboView_Set();
			if( hosei < def_HOSEI_ChainShiftMax )
			{
				BMvEff.ComboView_Set( { val=def_HOSEI_ChainShift, type=1 } ); // 乗算
				BMvEff.ComboView_Set( { val=def_HOSEI_ChainShiftMax, type=0 } ); // 上書き
			}
		}
		else // 通常チェインシフト
		{
		
		}
		
		// CSによるCP回復テスト
		local par = (isSuperChainShift)? def_CPH_SuperChainShift : def_CPH_ChainShift; // チェインシフトの凄さで回復割合が変化
		Battle_Std.ComboPoint_Multi( par ); // コンボポイントを乗算
		
		//バウンド回数を回復する（３回までいってるとダメ）
		//ジャンプ回数制限もリセット
		//のけぞり修正値もクリアする
		local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
		local enemy_is_damage = false;
		if( enemy.push() )
		{
			local bs = BtlMvStd.GetBoundStatus();
			// short BtlMvStd::MvBoundStatus::isBound
			// のけぞりベクトルがある状態かどうか（やられ状態かではない
			// 0 --- のけぞり状態でない
			// 1 --- のけぞり状態
			// 2 --- のけぞり状態でガードしている
			//print("\n bs.isBound:"+bs.isBound);
			enemy_is_damage = ( bs.isBound==1 );
			if( enemy_is_damage ) // のけぞり状態（ガードは除外するよ）
			{
				if( isSuperChainShift ) //すごいチェインシフト
				{
					if( bs.WallCount<3 )
					{
						BMvTbl.SetWallCount( 0 ); //バウンド回数をリセット
					}
					
					//のけぞり修正値をクリア
					//isBound==1の時だけにしないとガード中に発動されてハメられる
					BMvTbl.BoundCorrect_Calc( { num=-10000 } );  // 通常は10で１ヒット分、-10000の時だけクリア処理
				}
				
				BMvTbl.DamageFlag_Func( def_DF_JumpCanseled, _ValErase );// 「ジャンプキャンセルをされた」を相手から消す
				BMvTbl.DamageFlag_Func( def_DF_AerialJumpCanseled, _ValErase );// 「エリアルジャンプキャンセルをされた」を相手から消す
			}
			
			enemy.pop();
		}
		
		//アサルト回数制限をリセット
		BMvTbl.AddAirCount( def_AC_Assault, -10 ); // アサルト回数リセット

		
		local eff = BMvEff.CreateObject( { mvname="Mv_Convert_Object" } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
			BMvEff.SetExist( { level = _Exist_NoHantei } );
			BMvTbl.SetLP(0,stock); // GRDの個数を記憶
			
			eff.pop();
		}
		
		local isCanselCS = (BMvTbl.GetPP(def_PP_ChainShiftStatus)==1); //キャンセルチェインシフト
		local voiceType = ( isCanselCS )? "キャンセルチェインシフト" : "ノーマルチェインシフト";
		// _dp("\n voiceType:"+voiceType );
		if( Battle_Std.TypeSE_Play({ type=voiceType }) )
		{
		}
		else
		{
			Battle_Std.TypeSE_Play({ type="チェインシフト" });
		}
		

		//メッセージの表示
		BMvEff.AttackInfoString_Set({ word=def_AISW_Convert,} );
		
		//相手に、暗転後動けるようになると消えるオブジェクトを呼ぶ
		Battle_Std.CallAntenStopObject();
		
		//時間停止と暗転の処理
		BMvEff.SetStopTime( { time=def_FL_ConvertStopTime } ); //チェインシフトの時間停止
		
		BMvEff.CutInProc_Set({ time=[3,def_FL_ConvertStopTime-3,10], cutin_mv="",erasetype=0, bgtype=1 });

		BMvEff.SetSpGauge( {value=def_SP_Convert_Init,} );
		
		BMvTbl.SetPattern(def_PAT_ChainShift); //パターンセット
		BMvTbl.SetPrio( _CharaPrio_Near ); //目立たせるように手前にする
		
		BMvTbl.SetVector( { x=0, y=0, addx=0, addy=0, flags=_Vector_Normal|_Vector_Div|_Vector_Bound|_Vector_DivKeep } ); //Keep以外を初期化
		BMvTbl.SetVector_MaxX( 0 ); //XMAXを初期化
		
		local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		if( rc.sx != _Hantei_Error ) // 存在するか
		{
			local usepat = ( isSuperChainShift )? 76 : 82; //エフェクトのパターンを決める
			BMvEff.CreateObject( { x=rc.sx, y=rc.sy, datatype=1, start_pat=usepat, flags=_Position_ToolShift } );
			local eff = BMvEff.CreateObject( { x=rc.sx, y=0, mvname="", datatype=1, start_pat=83, flags=_Position_ToolShift } );
			if( eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove } );	
				BMvTbl.SetPosition( { y=0 } );
				
				eff.pop();
			}
		}
		local pos = BMvTbl.GetPosition(0);
		if( pos.y >= -64 ) //地上付近だったら出す
		{
			BMvEff.CreateObject( { x=0, y=0, datatype=1, start_pat=87, flags=_Position_ToolShift } );
			BMvTbl.SetPosition( { y=0 } ); // 煙を出したとき＝地上でないと判別つかない
		}
		
		Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		
		// 戻りのモーションをキャッシュにのせておく
		local cache_f = def_FL_ConvertStopTime -3; // 大体40Fぐらいだから余裕っしょ
		if( cache_f < 0 ) cache_f = 3;
		Battle_Std.CallSkillSoonCaches( [100,cache_f], [200,cache_f] ); // FrameID, rest

		Battle_Std.CharaBattleActivity_Increment(95,"チェインシフト回数");
		
		Battle_Std.EnemyDamageFlag_Add( def_DF_UseComboChainShift ); // CSしたことを記憶
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount==1 )
		{
			// 190415 でかかりだけで処理をしたい
			// 190410 ここで処理しないとprio奥の相手の行動1F目のときに検知されない
			// 181113 CS時に相手が行動不能だったら赤く光らせよう
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				local isCancelNone = BCMDTbl.CheckCancel( _SkillType_None );
				local isBound = Battle_Std.CheckPlayerisBound();
				local isMuteki = BMvEff.GetPlayerMuteki( 0 ); // 打撃無敵
				local existKuraiHantei = 0;
				local cmdInfo = BCMDTbl.GetCmdInfoEx(0);
				
				local isInActiveMv = ( Battle_Std.MoveCode.CheckFlag(def_MC_Atk|def_MC_Skill) || Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_StdAssult|def_MC7_AirAssult|def_MC7_InActive ) )? 1 : 0;
				{
					for(local i=0; i<8; i++)
					{
						local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Kurai , i ], } );
						if( rc.sx != _Hantei_Error )
						{
							existKuraiHantei = 1; //存在した
							break;
						}
					}
				}
				if( !isCancelNone && !isBound && isMuteki==0 && existKuraiHantei && cmdInfo.GetFrame() <=10 && isInActiveMv)
				{
					Battle_Std.SetInActiveEffect(); // 行動不能時の被CSでの演出
					
					
					if( Def_Sys_EnemyAntenStopNoCancel )
					{
						local mvname = BMvTbl.GetMvName();
						local mvs = BMvTbl.GetMvStatus();
						if( mvname == "Mv_Assault_Std" || mvname == "Mv_Assault_Air" )
						{
							_dpn("アサルト中の被CSでもやがついたのでキャンセルフラグを消す");
							BMvTbl.SetAsFlag( { as_flags=_AsFlag_ChainShift, time=0, flag=_ClearFlag_ChangeMv } );
						}
					}
		
				}
				enemy.pop();
			}
		}
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.MvCount>=def_FL_ConvertStopTime) BMvTbl.SetFinalize(0);
		if( s.FrameID==100 ) BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Convert_Modori" );
	}				
	function LastUpdate_Std()
	{
		//念のため無敵解除
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } );	
	}
}

//チェインシフトフリーモーション
Std_MoveTable.Mv_Convert_Modori <-
{
	function Init_Std()
	{
		//地上か空中かで分岐
		//超低空だったら地上にした方がいいので属性ではなく座標で分岐する
		local pos = BMvTbl.GetPosition(0);
		if( pos.y> -64 ) //地上
		{
			BMvTbl.JumpFrameID(100);
			BMvTbl.SetPosition( { y=0 } ); //地面につける
			Battle_Std.InitVector(); //地上なので保存ベクトルの再生はしないで初期化
		}
		else //空中
		{
			BMvTbl.JumpFrameID(200);
			local vec = BMvTbl.GetVector( { flags=_Vector_Keep } ); //保存ベクトルを呼び出す
			
			//そのままだと空中浮遊とかかっとびすぎるとかあると思うので制限をかける
			if( vec.x> 3000 ) vec.x=3000;
			if( vec.x< -3000 ) vec.x=-3000;

			if( vec.y> 3000 ) vec.y=3000;
			if( vec.y< -3000 ) vec.y=-3000;
			
			//addxは危ない気がするので使わない
			//チェインシフトを使うことでの減速による左右二択とか発生してしまうわけだがしょうがない
			vec.addx = 0;
			
			//addyは190以上、250以下にするする
			if( vec.addy <= 190 ) vec.addy=190;
			if( vec.addy >= 250 ) vec.addy=250;
			
			BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=vec.addx, addy=vec.addy } );
			
			BMvTbl.SetVector( { x=0, y=0, addx=0, addy=0, flags=_Vector_Keep } ); // 保存していたものを破棄
		}
		
		//行動可能で動けるようにする
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } ); //LUでもやるけど一応こっちメイン
		
		BMvTbl.SetCommandLongDelay(1); //受付時間増加（先行入力用）
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetFinalize(256); //着地へ
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Convert_Modori_Land"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_Convert_Modori_Land <-
{
	function Init_Std()
	{
		BMvTbl.SetPattern(21); //着地
		Battle_Std.InitVector();
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//共通アクションここまで	



/*
	ガード関係
*/

local set_Nagemukite_GuardModori = function()
{
	if( BMvTbl.ChangeMv_GetMoveCodeEx( 1 )&def_MC1_ShieldFailed )
	{
		_dp("\n 前が失敗シールドだったので投げ無敵無し");
		BMvEff.SetPlayerTimer( { muteki_nage=0 } ); //無敵時間は無し
	}
	else
	{
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriGuardNageMuteki } ); //無敵時間を設定
	}
}

//立ちガード戻り
Std_MoveTable.Mv_Modori_GuardS <- 
{
	function Init_Std() : (set_Nagemukite_GuardModori)
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_GuardS);
		
		set_Nagemukite_GuardModori(); // 失敗シールドじゃなけりゃ投げ無敵を設定
		
		if (BMvTbl.JumpFrameID( 120 ) == -1)
		{
			_dem("【警告】飛び先のフレームIDが無い");
			BMvTbl.SetFinalize(0);
		}
		Battle_Std.TypeSE_Play({ type="ガード戻り" });
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//屈ガード戻り
Std_MoveTable.Mv_Modori_GuardC <- 
{
	function Init_Std() : (set_Nagemukite_GuardModori)
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_GuardC);

		set_Nagemukite_GuardModori(); // 失敗シールドじゃなけりゃ投げ無敵を設定
		
		if (BMvTbl.JumpFrameID( 120 ) == -1)
		{
			_dem("【警告】飛び先のフレームIDが無い");
			BMvTbl.SetFinalize(0);
		}
		Battle_Std.TypeSE_Play({ type="ガード戻り" });
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}

//空中ガード戻り　※141129 仕様を変更、ベースデータも落下パターンへの変化でファイナライズするように
Std_MoveTable.Mv_Modori_GuardA <- 
{
	function Init_Std() : (set_Nagemukite_GuardModori)
	{
		//BMvTbl.SetPattern(def_PAT_GuardA); //※
		// 戻りが２パターンある
		if( BMvTbl.CheckPosState( _PosState_Air ) )//空中状態でガード解除
		{
			if (BMvTbl.JumpFrameID( 120 ) == -1)
			{
				_dem("【警告】飛び先のフレームIDが無い");
				BMvTbl.SetFinalize(0);
			}
		}
		else	//地上状態でガード解除
		{
			BMvTbl.SetFinalize(200); // Mv_Modori_GuardS　へ
			return;
		}
		
		set_Nagemukite_GuardModori(); // 失敗シールドじゃなけりゃ投げ無敵を設定
		
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		BMvTbl.SetMuki(_Direction_Auto);
		Battle_Std.TypeSE_Play({ type="ガード戻り" });
		
		// ガードフロートからの戻り
		if( BMvTbl.GetLP(8) ==1 ) // 無敵をセットされていた
		{
			BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_dageX=254 } );
		}	
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetFinalize(100);
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Modori_GuardAFall", [100,"Mv_Modori_GuardAFallLand"], [200,"Mv_Modori_GuardS"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0 } );
	}	
}

//空中ガード戻りからの落下
//キャラによってパターンが違う…
local pat_AirGuardModoriFall = chrparam.Get( { type="空中ガードからの戻りパターン", chrnum=_ChrNo } );

Std_MoveTable.Mv_Modori_GuardAFall <- 
{
	function Init_Std() : (pat_AirGuardModoriFall)
	{
		BMvTbl.SetPattern( pat_AirGuardModoriFall ); // 空中ガードからの戻りパターンを設定
		//Mv中行動可能
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		// ガードフロートからの戻り
		if( BMvTbl.GetLP(8) ==1 ) // 無敵をセットされていた
		{
			BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_dageX=254 } );
		}
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetFinalize(100);
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_Modori_GuardAFallLand"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0 } );
	}
}

Std_MoveTable.Mv_Modori_GuardAFallLand <- 
{
	function Init_Std() : (pat_AirGuardModoriFall)
	{
		//※パターンは多分指定してあるだろう
		Battle_Std.InitCharaVector();
		//Mv中行動可能
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする				
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );	//ファイナライズはどのみち着地してからっす
	}
}



//地上やられからの戻り
Std_MoveTable.Mv_Modori_YarareS <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriYarareNageMuteki } ); //無敵時間を設定
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//地上やられからの戻り・しゃがみ
Std_MoveTable.Mv_Modori_YarareC <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriYarareNageMuteki } ); //無敵時間を設定
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}

//投げ抜け攻撃からの戻り
Std_MoveTable.Mv_Modori_Nagenuke <- 
{
	function Init_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriGuardNageMuteki, muteki_nageX=def_FL_ModoriGuardNageMuteki } ); //無敵時間を設定
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//投げ抜けられからの戻り
Std_MoveTable.Mv_Modori_Nagenukerare <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_GuardS);
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriGuardNageMuteki, muteki_nageX=def_FL_ModoriGuardNageMuteki } ); //無敵時間を設定
		
		if (BMvTbl.JumpFrameID( 120 ) == -1)
		{
			_dem("【警告】飛び先のフレームIDが無い");
			BMvTbl.SetFinalize(0);
		}			
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//地上やられからの戻り
Std_MoveTable.Mv_Modori_KirimomiYarareS <- 
{
	function Init_Std() // 
	{
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//Vectorの抜け先はだいたいこのMvになる
//Vector終了後ダウン絵のファイナライズでここにやってくる（＝完全に寝きった絵までくる瞬間にここへくる）
//ここでＫＯチェックで大丈夫か？
//ここから先はbound属性が解除されているので無敵時間とかをつけないとまずそう
Std_MoveTable.Mv_Modori_Down <- // ダウンからの起き上がり
{
	function Init_Std() // 
	{
		//ここまできたらダウン追い討ちされなかった
		BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_nage=254, muteki_dageX=254, muteki_nageX=254 } ); //無敵時間を設定
	
		local rs = BMvTbl.GetMvRoundStatus(); //ラウンドステータス取得		
		// _dp("\n rs.Round:"+rs.Round );
		if (rs.isMyKo && rs.Round != -2 ) //KO状態なら寝たきり、チュートリアルとかは除外
		{
			BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } ); //起き上がり無敵時間を消去
			
			//まず起き上がり先のパターンへ進む
			local s = BMvTbl.GetMvStatus();
			switch(s.DataPattern)
			{
			case 290:
			case 350:
				BMvTbl.SetPattern(293);
				break;
			case 291:
			case 352:
				BMvTbl.SetPattern(294);
				break;
			case 292:
			case 354:
			case 356:
				BMvTbl.SetPattern(295);
				break;
			default:
				_dem("【警告】おかしいところから飛んできたよ０");
				BMvTbl.SetPattern(295);
				break;		
			}
			//まず256に飛んで起き上がらないように
			//・別のMvに状態移行
			//その後一定フレーム待って、起き上がるかどうかをチェック
			//ラウンドとられただけか敗北かに飛ぶ
			if( BMvTbl.JumpFrameID(256)==-1 )
			{
				_dm("【警告】飛び先のフレームIDが無い256");
			}
			if( rs.isLoseRound )
			{
				BMvTbl.SetFinalize(def_FC_Lose);
			}
			else if( rs.WinType == -1) //自分が勝っているかどうか（KO後のみ）、0-負け 1-勝ち -1-引き分け
			{
				//引き分け（勝敗ポイントが両者に入る時）は敗北Mvにして起き上がらないようにする
				//TODO:Ｍｖ見て何かしているものがあるとちょっと都合が悪いかも
				BMvTbl.SetFinalize(def_FC_Lose);			
			}
			else
			{
				BMvTbl.SetFinalize(def_FC_RoundLose);
			}
		}
		else //KOされてないので寝っぱなしへ、もしくはKOされたけどチュートリアル内
		{
			//まずは寝ている絵まで進めよう　※同じパターンを２回やる
			local s = BMvTbl.GetMvStatus();
			switch(s.DataPattern)
			{
			case 290:
			case 350:
				BMvTbl.SetPattern(290);
				break;
			case 291:
			case 352:
				BMvTbl.SetPattern(291);
				break;
			case 292:
			case 354:
			case 356:
				BMvTbl.SetPattern(292);
				break;
			default:
				_dem("【警告】おかしいところから飛んできたよ０");
				BMvTbl.SetPattern(292);
				break;		
			}
			BMvTbl.SetFinalize(0); // ねっぱへ
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neppa", [def_FC_RoundLose,"Mv_RoundLose"], [def_FC_Lose,"Mv_Lose"] ); //デフォ,[code,mv]...
	}
}

// プログラムの緊急受け身の処理で「Mv_Neppa」を参照しているので名前は変更しないこと
Std_MoveTable.Mv_Neppa <- // ダウンからの寝っぱなし状態　次に起き上がりへ移行
{
	function Init_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_nage=254, muteki_dageX=254, muteki_nageX=254 } ); //無敵時間を設定
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		
		// 0〜10 ボタン受け身受付 11〜29:寝てる 30:起き上がる
		local mask = (1<<0)|(1<<1)|(1<<2)|(1<<3); // Dも含む
		local push_button = ( BMvTbl.IsCpu()==0 )? BMvTbl.CheckButtonHoldFrame( mask, 2 ) : BMvTbl.CheckButtonHold( mask ); // プレイヤーのみ2F前の入力を見る（ロールバック対策）
		if( mvs.MvCount >= 20 )
		{
			BMvTbl.SetFinalize(0); // 起き上がりへ進む
		}
		else if( mvs.MvCount <= 10 )
		{
			if( push_button ) BMvTbl.SetFinalize(100); // 受け身へ進む
		}
	}
	function Finalize_Std()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Okiagari", [100,"Mv_NeppaRecover"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_Okiagari <- // 寝っぱなしからの起き上がり
{
	function Init_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_nage=254, muteki_dageX=254, muteki_nageX=254 } ); //無敵時間を設定
		BMvTbl.TM_SetDownStatus(); // ダウン状態待機。トレモリバーサル技呼び出し用。
		
		//まず起き上がり先のパターンへ進む
		local s = BMvTbl.GetMvStatus();
		switch(s.DataPattern)
		{
		case 290:
			BMvTbl.SetPattern(293);
			BMvCore.CallEntryBCCachePreTransfer( { pat=296, frame=0, rest=10 } ); // フリーモーション１Ｆ目予約
			break;
		case 291:
			BMvTbl.SetPattern(294);
			BMvCore.CallEntryBCCachePreTransfer( { pat=297, frame=0, rest=10 } ); // フリーモーション１Ｆ目予約
			break;
		case 292:
			BMvTbl.SetPattern(295);
			BMvCore.CallEntryBCCachePreTransfer( { pat=298, frame=0, rest=10 } ); // フリーモーション１Ｆ目予約
			break;
		default:
			_dem("【警告】おかしいところから飛んできたよ１");
			BMvCore.CallEntryBCCachePreTransfer( { pat=298, frame=0, rest=10 } ); // フリーモーション１Ｆ目予約
			BMvTbl.SetPattern(295);
			break;		
		}			
		
		//起き上がりのボイス分岐
		if( Battle_Std.RoundisEnd() ) // 決着ついた後はボイスを無くす
		{
		
		}
		else
		{
			local s = BMvTbl.GetMvStatus();
			switch(s.DataPattern)
			{
			case 293:
				if( Battle_Std.TypeSE_Play({ type="起き上がり" }) == 0 )
				{
					Battle_Std.TypeSE_Play({ type="あお向け起き上がり" });
				}
				break;
			case 294:
				if( Battle_Std.TypeSE_Play({ type="起き上がり" }) == 0 )
				{
					Battle_Std.TypeSE_Play({ type="うつ伏せ起き上がり" });
				}
				break;
			case 295:
				Battle_Std.TypeSE_Play({ type="重傷起き上がり" });
				break;
			}
		}
	}
	function FrameUpdate_Std()
	{
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_OkiagariFreeMotion" );
	}	
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dageX=0, muteki_nageX=0 } ); //この２つは怖いので消しておく
		Battle_Std.Reversal.SetTime(); //リバーサル受付＋判定オブジェクト生成
	}		
}


//決着敗北で寝たきり
//このMvの名前を見て勝利ポーズは分岐してるよ
//引き分けの時は両者このmvになるよ
Std_MoveTable.Mv_Lose <-
{
	function Init_Std() // 
	{
		// if( Def_Dbg_RoundStatus ) _dp(" -> Mv_Lose");
		if( BMvTbl.JumpFrameID( 1024 ) == -1 )
		{
			_dm("【警告】飛び先のフレームIDが無い 1024");
		}
		BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Add } ); //重なり判定無し
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		
		BMvTbl.SetRoundEnd();
	}
	function Finalize_Std() // 
	{
		_dem("【警告】へんなファイナライズ");
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );	//発生しないはず
	}
	function LastUpdate_Std()
	{
		BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); //重なり判定消去戻し
	}
}

//ラウンド敗北で起き上がる
//引き分けの時はここにこないよ
Std_MoveTable.Mv_RoundLose <-
{
	function Init_Std() // 
	{
		_dm("ラウンドの続きがあるので起きる");
		if (BMvTbl.JumpFrameID( 512 ) == -1)
		{
			_dm("【警告】飛び先のフレームIDが無い512");
		}
		BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Add } ); //重なり判定無し
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		
		BMvTbl.SetRoundEnd(); //ラウンド終了命令を入れる
		
		BMvTbl.SetLP(0,0); //カウンタ初期化
		BMvTbl.SetLP(1,0); //音声再生フラグ		
	}
	function FrameUpdate_Std()
	{
		local rs = BMvTbl.GetMvRoundStatus(); //ラウンドステータス取得		
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		
		local mvcnt = BMvTbl.GetLP(0); //カウンタ取得
		BMvTbl.AddLP(0,1); //1F進める		

		//しばらくは起き上がらない
		if( s.MvCount<120 && s.FrameID==512)
		{
			BMvTbl.JumpFrameID(512); //512の寝た絵で固まってて
		}

		//120F後にラウンド敗北音声を再生する
		if( s.MvCount>=120 && BMvTbl.GetLP(1)==0 )
		{
			BMvTbl.SetLP(1,1); //再生済みフラグ（再生失敗してもフラグはたつ）
			
			//カメラ矩形外に自分がいるかチェック
			local inCamera = true; //カメラ内かどうか
			
			//今のカメラ矩形を取得（ゆれや注目の影響を受けるカメラ位置）
			local pos = BMvEff.GetCameraRect( { flags=_GetPos_DispCamera } );

			//自分の座標を取得
			local my_pos = BMvTbl.GetPosition(0);
			if( my_pos.x < pos.sx || my_pos.x > pos.ex ) inCamera = false;
			
			//結果
			if( inCamera )
			{
				_dm("○　カメラ内なのでボイスを再生");
				Battle_Std.TypeSE_Play({ type="ラウンド敗北" });
			}
			else
			{
				_dm("×　カメラ外なのでボイスは再生しない");
			}
		}
	}	
	function Finalize_Std() // 
	{
		_dem("【警告】へんなファイナライズ");
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );	//発生しないはず
	}
	function LastUpdate_Std()
	{
		BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); //重なり判定消去戻し
	}	
}


Std_MoveTable.Mv_OkiagariFreeMotion <- // 起き上がりのフリーモーション
{
	function Init_Std() // 
	{
		//_dm("起き上がりフリー");
				
		//まず起き上がり先のフリーモーションへ進む
		local s = BMvTbl.GetMvStatus();
		switch(s.DataPattern)
		{
		case 293:
			BMvTbl.SetPattern(296);
			break;
		case 294:
			BMvTbl.SetPattern(297);
			break;
		case 295:
			BMvTbl.SetPattern(298);
			break;
		default:
			_dem("【警告】おかしいところから飛んできたよ");
			BMvTbl.SetPattern(298);
			break;		
		}
		//ここに1F無敵がナイトリバサ必殺技がでないデス
		//ってのは無くなったデス
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_OkiagariNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_OkiagariNageMuteki } ); //起き上がり無敵時間を設定
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );	//ファイナライズ
	}
}	

	
	





//腹吹き飛び系統
//（キャラの向きとベクトル向きが一致していないとダメなもの）
//Mv_Boundと同じ処理＋Battle_Std.SetMuki_BoundVectorMuki();
Std_MoveTable.Mv_Bound_0009 <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit();
		Battle_Std.SetMuki_BoundVectorMuki();
	}
	function Update_Std()
	{
		Battle_Std.BoundUpdate();
	}
	function FrameUpdate_Std()
	{
		local useval = (BMvEff.GRD_GetJudgeResult()>0)? ( (BMvEff.GRD_CheckStock( { val=-1 } )>=6)? def_GRD_BoundFU_GRD6Vorpal : def_GRD_BoundFU_Vorpal) : def_GRD_BoundFU;
		Battle_Std.GRD_AddValue({ val=useval, pressure=0, boundplus=1 });
	}
	function Finalize_Std() // 
	{
		//抜け先が無いかも？
		//状態の移行だけ行う
		BtlMvStd.SetBoundFinalize();
		// print("\nMv_Bound Finalize()");
	}
	function LastUpdate_Std() // 
	{
		BtlMvStd.ClearBound(); // 状態解除
		//print("\nMv_Bound LastUpdate()");
	}
}

Std_MoveTable.Mv_Bound_0017 <- Std_MoveTable.Mv_Bound_0009; //小腹吹き飛び
Std_MoveTable.Mv_Bound_0018 <- Std_MoveTable.Mv_Bound_0009; //小腹吹き飛び
Std_MoveTable.Mv_Bound_0094 <- Std_MoveTable.Mv_Bound_0009; //超腹吹き飛び大壁バウンド
Std_MoveTable.Mv_Bound_0148 <- Std_MoveTable.Mv_Bound_0009; //再帰超斜め上吹き飛び
Std_MoveTable.Mv_Bound_0227 <- Std_MoveTable.Mv_Bound_0009; //超ゆっくり腹吹き飛び
Std_MoveTable.Mv_Bound_0228 <- Std_MoveTable.Mv_Bound_0009; //超斜め上吹き飛び

// コンボVO浮き
if( Def_Sys_ComboLiberate_BoundHosei )
{
Std_MoveTable.Mv_Bound_0238 <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit();
		
		BMvTbl.SetLP(0,0); // 補正をかけたかどうか
	}
	function Update_Std()
	{
		Battle_Std.BoundUpdate();
	}
	function FrameUpdate_Std()
	{
		local useval = (BMvEff.GRD_GetJudgeResult()>0)? ( (BMvEff.GRD_CheckStock( { val=-1 } )>=6)? def_GRD_BoundFU_GRD6Vorpal : def_GRD_BoundFU_Vorpal) : def_GRD_BoundFU;
		Battle_Std.GRD_AddValue({ val=useval, pressure=0, boundplus=1 });
		
		if( BMvTbl.GetLP(0) == 0 )
		{
			// バウンドの時に補正をかける
			local bs = BtlMvStd.GetBoundStatus();
			// bs.VecCount 0:空中ヒット〜着地まで
			if( bs.isBound && bs.VecCount==1 )
			{
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					// Battle_Std.SetHosyoHosei( def_HosyoHosei_ComboVO );
					Battle_Std.SetHosyoHosei_Multi( def_HosyoHosei_ComboVO );
					BMvEff.ComboView_Set( { val=90, type=1 } ); // ダメージ補正
					Battle_Std.ComboPoint_Multi( 90 ); // コンボポイント補正
					
					enemy.pop();
					
					_dp("\n コンボVO着地での補正");
					BMvTbl.SetLP(0,1); // 補正をかけたことを記憶
				}
			}
		}
		
		
	}
	function Finalize_Std() // 
	{
		//抜け先が無いかも？
		//状態の移行だけ行う
		BtlMvStd.SetBoundFinalize();
		// print("\nMv_Bound Finalize()");
	}
	function LastUpdate_Std() // 
	{
		BtlMvStd.ClearBound(); // 状態解除
		//print("\nMv_Bound LastUpdate()");
	}
}
}

local makemv_BoundSirimoti = function( frame1=9, frame2=15, frame3=25 )
{
	local retmv = {};
	retmv.Init_Std <- function() // 
	{
		Battle_Std.BoundInit(); //ベクトル初期化・やられ状態セット

		//やられ絵とベクトル向きが絶対に等しくないとおかしいので
		Battle_Std.SetMuki_BoundVectorMuki(); //向きをベクトルの向きに合わせる
			
		//LP0 しりもちの状態　0:ヒット直後〜　1：しりもち着地〜　2：復帰モーション〜　(3:終わり)
		BMvTbl.SetLP(0,0); //変数初期化
		BMvTbl.SetLP(1,0); //カウント
	}
	retmv.FrameUpdate_Std <- function() : (frame1, frame2, frame3)
	{
		local s = BMvTbl.GetMvStatus();
		local mode = BMvTbl.GetLP(0);
		local cnt = BMvTbl.GetLP(1);
		BMvTbl.AddLP(1,1); //カウントアップ
		local useval = (BMvEff.GRD_GetJudgeResult()>0)? ( (BMvEff.GRD_CheckStock( { val=-1 } )>=6)? def_GRD_BoundFU_GRD6Vorpal : def_GRD_BoundFU_Vorpal) : def_GRD_BoundFU;
		Battle_Std.GRD_AddValue({ val=useval, pressure=0, boundplus=1 });	

		switch( mode )
		{
		case 0:
			if( s.MvCount>frame1 )
			{
				BMvTbl.SetLP(0,1); //状態移行
				BMvTbl.SetLP(1,0); //カウンタリセット
			}
			if( cnt==0 )
			{
				//食らった直後

				//しりもちやられ状態なのをセット(解除は自動)
			}
			break;
		case 1:
			if( s.MvCount>frame2 )
			{
				BMvTbl.SetLP(0,2); //状態移行
				BMvTbl.SetLP(1,0); //カウンタリセット
			}
			if( cnt==0 )
			{
				//尻から着地するところ
				BMvTbl.JumpFrameID(100);
				
				BMvTbl.SetVector( { x=-1000, y=0, addx=100, addy=0, flags=_Vector_Bound } );
				
				//バウンドエフェクト・効果音呼び
				// callLandEffect(); // 着地エフェクト ここはうるさいので使わない
				// BMvEff.CreateObject( { datatype=1, start_pat=20 } ); //砂煙
				// 地面着地のやられエフェクトを出そう
				BMvEff.CreateObject( { datatype=1, start_pat=51 } ); //しちもちダウン
				BMvEff.SetCamera_Quake( { time=12, type=0, clear=0, } ); //揺らし
			}
			break;
		case 2:
			{
				// 戻るタイミングをベクトルを見て行う
				local bs = BtlMvStd.GetBoundStatus();
				if( bs.isBound )
				{
					local left_frame = bs.GetCountNow(); // あと何フレームで終わるか
					
					if( left_frame <= 9 )
					{
						//戻りアニメに進む
						BMvTbl.SetLP(0,3); //状態移行
						BMvTbl.SetLP(1,0); //カウンタリセット
						BMvTbl.JumpFrameID(256);
						// _dpn("ここで戻る");
					}
				}				
			}
			if( cnt==0 )
			{
				//復帰の絵開始・・・は別処理に移動(ベクトルを見てやるように)
				// BMvTbl.JumpFrameID(256);
				
				BMvTbl.SetVector( { x=0, y=0, addx=0, addy=0, flags=_Vector_Bound } );				
			}
			break;		
		}
	}
	retmv.Finalize_Std <- function() // 
	{
		//状態の移行だけ行う
		BtlMvStd.SetBoundFinalize(); //パターンが変化する
		// print("\nMv_Bound Finalize()");
	}
	retmv.LastUpdate_Std <- function() // 
	{
		BtlMvStd.ClearBound(); // 状態解除
	}
	return retmv;
}

//しりもち（作り直し）
//ヒルダの椅子処理でこの番号決め打ちしているので注意
//p1〜p2は10F以内じゃないとダメそう
//XXX:ヒルダ大丈夫？
Std_MoveTable.Mv_Bound_0197 <- makemv_BoundSirimoti( 7, 12, 20 ); // しりもち弱
Std_MoveTable.Mv_Bound_0198 <- makemv_BoundSirimoti( 8, 14, 22 ); // しりもち中
Std_MoveTable.Mv_Bound_0201 <- makemv_BoundSirimoti( 9, 15, 25 ); // しりもち
Std_MoveTable.Mv_Bound_0205 <- makemv_BoundSirimoti( 9, 15, 25 ); // しりもち特
Std_MoveTable.Mv_Bound_0100 <- makemv_BoundSirimoti( 9, 15, 25 ); // しりもちCH尻特

local makemv_BoundAirSirimoti = function( type=0 )
{
	local retmv = {};
	
	local mvparam =
	{
		xvec = -1000,
		xadd = 100,
	}
	
	switch( type )
	{
	case 0:
		break;
	case 1:
		mvparam.xvec = -3000;
		mvparam.xadd = 200;
		break;
	default:
		break;
	}
	
	retmv.Init_Std <- function() // 
	{
		Battle_Std.BoundInit(); //ベクトル初期化・やられ状態セット
		
		//やられ絵とベクトル向きが絶対に等しくないとおかしいので
		Battle_Std.SetMuki_BoundVectorMuki(); //向きをベクトルの向きに合わせる
		
		//LP0 しりもちの状態　0:ヒット直後〜　1：しりもち着地〜　2：復帰モーション〜　(3:終わり)
		BMvTbl.SetLP(0,0); //変数初期化
		BMvTbl.SetLP(1,0); //カウント
	}
	
	
	retmv.FrameUpdate_Std <- function() : (mvparam)
	{
		local s = BMvTbl.GetMvStatus();
		
		//ベクトルテーブルの特定のところだけの処理する
		local bs = BtlMvStd.GetBoundStatus();
		// bs.VecCount 0:空中ヒット〜着地まで
		// bs.VecCount 1:しりもち着地〜
		if( bs.isBound && bs.VecCount==1 )
		{
			local mode = BMvTbl.GetLP(0);
			local cnt = BMvTbl.GetLP(1);
			BMvTbl.AddLP(1,1); //カウントアップ
			local useval = (BMvEff.GRD_GetJudgeResult()>0)? ( (BMvEff.GRD_CheckStock( { val=-1 } )>=6)? def_GRD_BoundFU_GRD6Vorpal : def_GRD_BoundFU_Vorpal) : def_GRD_BoundFU;
			Battle_Std.GRD_AddValue({ val=useval, pressure=0, boundplus=1 });	

			switch( mode )
			{
			case 0:
				if( s.MvCount>10 )
				{
					BMvTbl.SetLP(0,1); //状態移行
					BMvTbl.SetLP(1,0); //カウンタリセット
				}
				if( cnt==0 )
				{
					//食らって着地した直後
					BMvTbl.JumpFrameID(100);

					//しりもちやられ状態なのをセット(解除は自動)
					
					//バウンドエフェクト・効果音呼び
					BMvEff.CreateObject( { datatype=1, start_pat=20 } ); //砂煙
					BMvEff.SetCamera_Quake( { time=12, type=0, clear=0, } ); //揺らし
					BSound.SE_Play( { type=_SeType_Normal, num=37 } ); //_SeType_Normal ---汎用 _SeType_Player ---キャラ				
					
					BMvTbl.SetVector( { x=mvparam.xvec, y=0, addx=mvparam.xadd, addy=0, flags=_Vector_Bound } );
				}
				break;
			case 1:
				if( s.MvCount>20 )
				{
					BMvTbl.SetLP(0,2); //状態移行
					BMvTbl.SetLP(1,0); //カウンタリセット
				}
				if( cnt==0 )
				{
					//復帰の絵開始
					BMvTbl.JumpFrameID(256);
					
					BMvTbl.SetVector( { x=0, y=0, addx=0, addy=0, flags=_Vector_Bound } );				
				}
				break;
			}
		}		
	}
	retmv.Finalize_Std <- function() // 
	{
		//状態の移行だけ行う
		BtlMvStd.SetBoundFinalize(); //パターンが変化する
		// print("\nMv_Bound Finalize()");
	}
	retmv.LastUpdate_Std <- function() // 
	{
		BtlMvStd.ClearBound(); // 状態解除
	}
	
	return retmv;
}// 基本動作テーブル


Std_MoveTable.Mv_Bound_0199 <- makemv_BoundAirSirimoti( 0 );
Std_MoveTable.Mv_Bound_0200 <- makemv_BoundAirSirimoti( 0 );
Std_MoveTable.Mv_Bound_0196 <- makemv_BoundAirSirimoti( 1 );
Std_MoveTable.Mv_Bound_0193 <- makemv_BoundAirSirimoti( 1 );


//しりもちからの戻り・レバガチャチェック
//しりもちからの復帰（レバガチャ部分以外）
Std_MoveTable.Mv_Modori_Sirimoti <- 
{
	function Init_Std() // 
	{
		Battle_Std.InitVector(); // ベクトル初期化
		if (BMvTbl.JumpFrameID(256) == -1)
		{
			_dem("【警告】飛び先のフレームIDが無い");
			BMvTbl.SetFinalize(0);
		}		
	}
	function FrameUpdate_Std()
	{
		//とりあえず特定フレームで抜ける
		local s = BMvTbl.GetMvStatus();
		if (s.MvCount>10)
		{
			BMvTbl.SetFinalize(0);
		}
		local useval = (BMvEff.GRD_GetJudgeResult()>0)? ( (BMvEff.GRD_CheckStock( { val=-1 } )>=6)? def_GRD_BoundFU_GRD6Vorpal : def_GRD_BoundFU_Vorpal) : def_GRD_BoundFU;
		Battle_Std.GRD_AddValue({ val=useval, pressure=0, boundplus=1 });	
	}		
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Modori_YarareC" );	//ファイナライズ
	}
	function LastUpdate_Std() // 
	{
		BtlMvStd.ClearBound(); // 状態解除
		//print("\nMv_Bound LastUpdate()");
	}	
}// 基本動作テーブル


//12 14 27
//きりもみ転等 333
Std_MoveTable.Mv_Bound_0012 <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit(); //ベクトル初期化・やられ状態セット
	}
	function Update_Std()
	{
		Battle_Std.BoundUpdate();	
	}
	function FrameUpdate_Std() // 
	{
	
		//ベクトルが↓向いたら落下パターンへ
		local s = BMvTbl.GetMvStatus();
		if (s.FrameID==100) //落下チェックID中なら
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_Bound }); //ベクトル取得
			if (vec.y >= 0)
			{
				if (BMvTbl.JumpFrameID(256) == -1)
				{
					_dem("【警告】飛び先のフレームIDが無い");
				}
			}
		}
		local useval = (BMvEff.GRD_GetJudgeResult()>0)? ( (BMvEff.GRD_CheckStock( { val=-1 } )>=6)? def_GRD_BoundFU_GRD6Vorpal : def_GRD_BoundFU_Vorpal) : def_GRD_BoundFU;
		Battle_Std.GRD_AddValue({ val=useval, pressure=0, boundplus=1 });	
	}
	function Finalize_Std() // 
	{
		BtlMvStd.SetBoundFinalize();
	}
	function LastUpdate_Std() // 
	{
		BtlMvStd.ClearBound(); // 状態解除
	}
}
Std_MoveTable.Mv_Bound_0014 <- Std_MoveTable.Mv_Bound_0012; //きりもみ小吹き飛び
Std_MoveTable.Mv_Bound_0019 <- Std_MoveTable.Mv_Bound_0012; //きりもみ壁吹き飛び
Std_MoveTable.Mv_Bound_0021 <- Std_MoveTable.Mv_Bound_0012; //きりもみ中壁
Std_MoveTable.Mv_Bound_0027 <- Std_MoveTable.Mv_Bound_0012; //きりもみ転倒
Std_MoveTable.Mv_Bound_0029 <- Std_MoveTable.Mv_Bound_0012; //きりもみ低転倒
Std_MoveTable.Mv_Bound_0095 <- Std_MoveTable.Mv_Bound_0012; //超きりもみ大壁バウンド
Std_MoveTable.Mv_Bound_0132 <- Std_MoveTable.Mv_Bound_0012; //再帰きりもみ吹き飛び
Std_MoveTable.Mv_Bound_0133 <- Std_MoveTable.Mv_Bound_0012; //再帰きりもみ垂直吹き飛び
Std_MoveTable.Mv_Bound_0137 <- Std_MoveTable.Mv_Bound_0012; //再帰きりもみ転倒
Std_MoveTable.Mv_Bound_0139 <- Std_MoveTable.Mv_Bound_0012; //再帰きりもみ低転倒
Std_MoveTable.Mv_Bound_0189 <- Std_MoveTable.Mv_Bound_0012; //きりもみ横吹き飛び
Std_MoveTable.Mv_Bound_0192 <- Std_MoveTable.Mv_Bound_0012; //即落きりもみ吹き飛び
Std_MoveTable.Mv_Bound_0209 <- Std_MoveTable.Mv_Bound_0012; //きりもみ垂直浮き
Std_MoveTable.Mv_Bound_0210 <- Std_MoveTable.Mv_Bound_0012; //きりもみ垂直浮き
Std_MoveTable.Mv_Bound_0225 <- Std_MoveTable.Mv_Bound_0012; //きり吹飛小壁

Std_MoveTable.Mv_Bound_0142 <- Std_MoveTable.Mv_Bound_0012; //きりもみ中壁
Std_MoveTable.Mv_Bound_0149 <- Std_MoveTable.Mv_Bound_0012; //きりもみ落下
Std_MoveTable.Mv_Bound_0195 <- Std_MoveTable.Mv_Bound_0012; //再帰きりもみ落下

Std_MoveTable.Mv_Bound_0237 <- Std_MoveTable.Mv_Bound_0012; //再帰きりもみ落下
Std_MoveTable.Mv_Bound_0055 <- Std_MoveTable.Mv_Bound_0012; //再帰きりもみ落下
Std_MoveTable.Mv_Bound_0056 <- Std_MoveTable.Mv_Bound_0012; //再帰きりもみ落下
Std_MoveTable.Mv_Bound_0057 <- Std_MoveTable.Mv_Bound_0012; //
Std_MoveTable.Mv_Bound_0058 <- Std_MoveTable.Mv_Bound_0012; //
Std_MoveTable.Mv_Bound_0059 <- Std_MoveTable.Mv_Bound_0012; //
//きりもみ系統は同じ処理

// 凍結落下
Std_MoveTable.Mv_Bound_0118 <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit(); //ベクトル初期化・やられ状態セット
		BMvTbl.SetLP(0,0); // カウント
	}
	function FrameUpdate_Std() // 
	{
		local bs = BtlMvStd.GetBoundStatus();
		if( bs.isBound && bs.VecCount==0 ) // 落下中
		{
			//とりあえず一枚目の絵で固定する
			local frame = BMvTbl.JumpFrameID( 0, _ValAdd );
			BMvTbl.Frame_Proc( frame, _ValSet  );
		}
		else if( bs.isBound && bs.VecCount==1 ) // 着地後
		{
			//とりあえず一枚目の絵で固定する
			local frame = BMvTbl.JumpFrameID( 0, _ValAdd );
			BMvTbl.Frame_Proc( frame, _ValSet  );
			
			local cnt = BMvTbl.GetLP(0);
			BMvTbl.AddLP(0,1);
			if(cnt==0)
			{
				//バウンドエフェクト・効果音呼び
				BMvEff.CreateObject( { datatype=1, start_pat=20 } ); //砂煙
				BMvEff.SetCamera_Quake( { time=12, type=0, clear=0, } ); //揺らし
				BSound.SE_Play( { type=_SeType_Normal, num=37 } ); //_SeType_Normal ---汎用 _SeType_Player ---キャラ	
			}
		}
	}
	function Finalize_Std() // 
	{
		BtlMvStd.SetBoundFinalize();
	}
	function LastUpdate_Std() // 
	{
		//共通
		BtlMvStd.ClearBound(); // 状態解除
	}
}

Std_MoveTable.Mv_BoundLockEff <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } );
	}
	function FrameUpdate_Std()
	{
		Battle_Std.SetPos_MarkingEnemy(); // ワーグナーから見て敵にくっつける
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

// スタン系
Std_MoveTable.Mv_Bound_0120 <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit(); //ベクトル初期化・やられ状態セット
		
		//ベクトルテーブルの最初だけ処理する
		local bs = BtlMvStd.GetBoundStatus();
		if( bs.isBound && bs.VecCount==0 )
		{
			local enemyChrNo = Battle_Std.GetEnemyCharaNo();
			if( enemyChrNo==Def_ChrNo_Wag ) //相手
			{
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報をかえる
				if( enemy.push() )
				{
					// 相手が生成
					local eff = BMvEff.CreateObject( { start_pat="stun_hamon", mvname="Mv_BoundLockEff"} );
					if( eff.push() )
					{
						Battle_Std.SetPos_MarkingEnemy(); // ワーグナーから見て敵にくっつける
						
						eff.pop();
					}
					
					enemy.pop();
				}
				BMvEff.SetCharaColor( { color = 0x2856A2, type = 4, intime = 4, time = 255 } );			
			}
		}
	}
	function FrameUpdate_Std() // 
	{
		local bs = BtlMvStd.GetBoundStatus();
		if( bs.isBound && bs.VecCount==0 )
		{
			//とりあえず一枚目の絵で固定する
			local frame = BMvTbl.JumpFrameID( 0, _ValAdd );
			BMvTbl.Frame_Proc( frame, _ValSet  );
		
			//定期的に何か出すとか…
			local mvs = BMvTbl.GetMvStatus();
			
			local enemyChrNo = Battle_Std.GetEnemyCharaNo();
			local enemy = BMvCore.GetNearEnemyCharaData();
			if( enemyChrNo==Def_ChrNo_Wag ) //相手が
			{
				//
				if( mvs.MvCount%25==0 )
				{
					if( enemy.push() )
					{
						// 相手が生成
						local eff = BMvEff.CreateObject( { start_pat="stun_hit", mvname="Mv_BoundLockEff" } );
						if( eff.push() )
						{
							Battle_Std.SetPos_MarkingEnemy(); // ワーグナーから見て敵にくっつける
							
							eff.pop();
						}
						enemy.pop();
					}
				}
			}
		}
	}
	function Finalize_Std() // 
	{
		BtlMvStd.SetBoundFinalize();
	}
	function LastUpdate_Std() // 
	{
		local enemyChrNo = Battle_Std.GetEnemyCharaNo();
		if( enemyChrNo == Def_ChrNo_Wag )
		{
			local bs = BtlMvStd.GetBoundStatus();
			if( bs.isBound && bs.VecCount==0 )
			{
				//フェードで抜ける
				BMvEff.SetCharaColor( { color = 0x2856A2, type = 0, intime = 10, time = 10 } );
			}
			else
			{
				//初期化？
				BMvEff.SetCharaColor( { color = 0xFFFFFF, type = 0, intime = 0, time = 0 } );
			}
		}

		//共通
		BtlMvStd.ClearBound(); // 状態解除
	}
}

Std_MoveTable.Mv_Bound_0119 <- Std_MoveTable.Mv_Bound_0120; // 微弱
Std_MoveTable.Mv_Bound_0121 <- Std_MoveTable.Mv_Bound_0120; // 中
Std_MoveTable.Mv_Bound_0122 <- Std_MoveTable.Mv_Bound_0120; // 強

Std_MoveTable.Mv_Bound_0125 <- Std_MoveTable.Mv_Bound_0120; // 崩れ弱
Std_MoveTable.Mv_Bound_0126 <- Std_MoveTable.Mv_Bound_0120; // 崩れ中
Std_MoveTable.Mv_Bound_0127 <- Std_MoveTable.Mv_Bound_0120; // 崩れ強
Std_MoveTable.Mv_Bound_0128 <- Std_MoveTable.Mv_Bound_0120; // 崩れ特大
Std_MoveTable.Mv_Bound_0129 <- Std_MoveTable.Mv_Bound_0120; // 崩れ超大



// ウェブやられ
local webeff_size = chrparam.Get( { type="ウェブやられエフェクトサイズ", chrnum=_ChrNo } );

// ビャクヤから生成されるウェブエフェクト
Std_MoveTable.Mv_WebLockEffect <-
{
	function Init_Std()
	{
		BMvTbl.SetPattern( "web_lock" );
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } );
		
		BMvTbl.SetLP(0,0); // 終わりかどうか
		// _dp("\n ウェブやられ開始");
		
		// 別キャラ同士の時は、レイヤー0を使う
		// 同キャラ戦の時、1Pならレイヤー0、2Pならレイヤー1を使う
		local norender_layer = (1<<1); // 非表示にするレイヤー
		if( Battle_Std.IsDoukyara() && BMvTbl.GetPlayerSide()==1 )
		{
			norender_layer = (1<<0); // 非表示にするレイヤー
		}
		BMvTbl.SetHan6LayerMask( {  val = norender_layer } ); // ビットを立てたレイヤーが非表示になる		
	}
	function FrameUpdate_Std()
	{
		// 相手にくっつく
		// 相手の行動が変わったら消える
		if( BMvTbl.GetLP(0)==0 ) // ロックしている時の処理
		{
			// _dp("\n ロック中");
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報をかえる
			if( enemy.push() )
			{
				local pl_pos = BMvTbl.GetPosition(0);
				local pl_kasanari = BMvEff.GetHanteiRect( { check=[ _Hantei_Kasanari, 0 ] } );
				local set_posy = pl_pos.y+(-150<<7); // 基本値
				if( pl_kasanari.sx != _Hantei_Error )
				{
					set_posy = pl_kasanari.ey + ( (pl_kasanari.sy - pl_kasanari.ey) * 6 / 10 );
				}
				local bs = BtlMvStd.GetBoundStatus();
				enemy.pop();

				BMvTbl.SetPosition( { x=pl_pos.x, y=set_posy } ); // とりあえず座標をセット
				
				if( bs.isBound && ( bs.Num == 235 || bs.Num == 236 ) && bs.VecCount == 0 ) // アニメ停止するのはここだけ
				{
				}
				else
				{
					// _dp("\n ウェブやられおわり:"+bs.Num );
					BMvTbl.SetLP(0,1); // ロック終わり
					BMvTbl.JumpFrameID( 900 ); // 消滅アニメへ進む
				}
			}
			else
			{
				BMvTbl.SetFinalize( 0 );
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_Bound_0235 <- 
{
	function Init_Std() : (webeff_size)
	{
		Battle_Std.BoundInit(); //ベクトル初期化・やられ状態セット
		
		//ベクトルテーブルの最初だけ処理する
		local bs = BtlMvStd.GetBoundStatus();
		if( bs.isBound && bs.VecCount==0 )
		{
			local enemyChrNo = Battle_Std.GetEnemyCharaNo();
			if( enemyChrNo==Def_ChrNo_Bya )
			{
				local enemy = BMvCore.GetNearEnemyCharaData(); // ビャクヤ側からの処理
				if( enemy.push() )
				{
					local eff =BMvEff.CreateObject( { mvname="Mv_WebLockEffect" });
					if( eff.push() )
					{
						// _dp("\n サイズ変更:"+webeff_size[0]+", "+webeff_size[1] );
						BMvTbl.SetScale( { x=webeff_size[0]*100, y=webeff_size[1]*100 } );
						eff.pop();
					}
					
					enemy.pop();
				}
			}
			BMvEff.SetCharaColor( { color = 0x808080, type = 4, intime = 4, time = 254 } );			
		}
		
		BMvTbl.SetLP(0,0); //カウンタ初期化
	}
	function FrameUpdate_Std() // 
	{
		local mvcnt = BMvTbl.GetLP(0); //カウンタ取得
		BMvTbl.AddLP(0,1); //1F進める

		local bs = BtlMvStd.GetBoundStatus();
		if( bs.isBound && bs.VecCount==0 )
		{
			//とりあえず一枚目の絵で固定する
			local frame = BMvTbl.JumpFrameID( 0, _ValAdd );
			BMvTbl.Frame_Proc( frame, _ValSet  );
		}
	}
	function Finalize_Std() // 
	{
		BtlMvStd.SetBoundFinalize();
	}
	function LastUpdate_Std() // 
	{
		local bs = BtlMvStd.GetBoundStatus();
		if( bs.isBound && bs.VecCount==0 )
		{
			//フェードで抜ける
			BMvEff.SetCharaColor( { color = 0x808080, type = 0, intime = 10, time = 10 } );
		}
		else
		{
			//初期化？
			BMvEff.SetCharaColor( { color = 0xFFFFFF, type = 0, intime = 0, time = 0 } );
		}
		BtlMvStd.ClearBound(); // 状態解除
	}
}

Std_MoveTable.Mv_Bound_0236 <- Std_MoveTable.Mv_Bound_0235;
// ※↑のベクトル番号キメうちでエフェクト処理しているので注意

//呪縛固定浮き
Std_MoveTable.Mv_Bound_0247 <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit(); //ベクトル初期化・やられ状態セット
		
		//ベクトルテーブルの最初だけ処理する
		local bs = BtlMvStd.GetBoundStatus();
		if( bs.isBound && bs.VecCount==0 )
		{
			local enemyChrNo = Battle_Std.GetEnemyCharaNo();
			if( enemyChrNo==Def_ChrNo_Set ) //相手がセトなら？
			{
				local e = BMvCore.GetNearEnemyCharaData(); // 敵の情報をかえる
				if( e.IsDone )
				{
					BMvCore.PushCharaData( e ); //
						local pos = Battle_Std.GetNearEnemyToolShiftPosition();
						Battle_Std.CreateObjectEX({ x=pos.x, y=pos.y-200, flags=_Position_ToolShift,
						pat="Spell_Hit", FrameID=[1,2], angle="rand" });
						
						Battle_Std.CreateObjectEX({ x=pos.x, y=pos.y-200, flags=_Position_ToolShift,
						pat="Spell_Biribiri", FrameID=[1,2,3], angle="rand" });
					BMvCore.PopCharaData(); //						
				}
			}
			BMvEff.SetCharaColor( { color = 0x2856A2, type = 4, intime = 4, time = 254 } );			
		}
		
		
		BMvTbl.SetLP(0,0); //カウンタ初期化
	}
	function FrameUpdate_Std() // 
	{
		local mvcnt = BMvTbl.GetLP(0); //カウンタ取得
		BMvTbl.AddLP(0,1); //1F進める

		local bs = BtlMvStd.GetBoundStatus();
		if( bs.isBound && bs.VecCount==0 )
		{
			//とりあえず一枚目の絵で固定する
			local frame = BMvTbl.JumpFrameID( 0, _ValAdd );
			BMvTbl.Frame_Proc( frame, _ValSet  );
		
			//定期的に何か出すとか…
			local s = BMvTbl.GetMvStatus();
			//print("\nフレーム:"+s.MvCount);
			
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報をかえる
			if( enemy.IsDone )
			{
				local enemyChrNo = Battle_Std.GetEnemyCharaNo();
				//print("\n番号："+enemyChrNo);
				if( enemyChrNo==Def_ChrNo_Set ) //相手がセトなら？
				{
					if (mvcnt%2==0 && mvcnt<=4 ) //数フレに１回
					{
						BMvCore.PushCharaData( enemy ); //
							local pos = Battle_Std.GetNearEnemyToolShiftPosition();
							Battle_Std.CreateObjectEX({ x=pos.x, y=pos.y-200, flags=_Position_ToolShift,
							pat="Spell_Hit", FrameID=[1,2], angle="rand" });
						BMvCore.PopCharaData(); //
					}
					if( mvcnt%10==0 )
					{
						BMvCore.PushCharaData( enemy ); //
							local pos = Battle_Std.GetNearEnemyToolShiftPosition();
							Battle_Std.CreateObjectEX({ x=pos.x, y=pos.y-200, flags=_Position_ToolShift,
							pat="Spell_Biribiri", FrameID=[1,2,3], angle="rand" });
						BMvCore.PopCharaData(); //
					}
				}
			}
		}
	}
	function Finalize_Std() // 
	{
		BtlMvStd.SetBoundFinalize();
	}
	function LastUpdate_Std() // 
	{
		//BMvEff.SetCharaColor( { color = 0x2856A2, type = 4, intime = 1, time = 1 } );
		local bs = BtlMvStd.GetBoundStatus();
		if( bs.isBound && bs.VecCount==0 )
		{
			//フェードで抜ける
			BMvEff.SetCharaColor( { color = 0x2856A2, type = 0, intime = 10, time = 10 } );
		}
		else
		{
			//初期化？
			BMvEff.SetCharaColor( { color = 0xFFFFFF, type = 0, intime = 0, time = 0 } );
		}
		BtlMvStd.ClearBound(); // 状態解除
	}
}

Std_MoveTable.Mv_Bound_0248 <- Std_MoveTable.Mv_Bound_0247;

//空攻撃浮きのベクトル終了先
//地面についた（しりもち）なのか、空中なのかで分岐する
Std_MoveTable.Mv_Modori_Uki <- 
{
	function Init_Std()
	{
		if( BMvTbl.CheckPosState( _PosState_Ground ) ) //既に着地していた
		{
			BMvTbl.SetFinalize( 256 ); //しりもちからの復帰へＧＯ
		}
		else
		{
			BMvTbl.SetFinalize(0); //自動復帰へ
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_AutoRecover", [256,"Mv_Modori_UkiSirimoti"] ); //デフォ,[code,mv]...
	}
}

//攻撃がヒットするとよばれる
//相手のDamageImpactと同時
Std_MoveTable.AttackImpact <- function( info )
{
	Battle_Std.AttackImpact_StdFunc(info);
}

//攻撃を受けるとよばれる
//相手のAttackImpactと同時
Std_MoveTable.DamageImpact <- function( info )
{
	Battle_Std.DamageImpact_StdFunc(info);
}

//攻撃判定同士の接触で呼ばれる
//return 0 すると相殺しない
//最初は1P>2Pと順に呼ばれるが、1Pで成功したら2Pは結果として呼ばれない
//描画のprioが手前なほうが先に呼ばれる（＝最後に殴ったほうが先）
Std_MoveTable.CheckSousai <- function()
{
	return 0; // 相殺しない
}

//相殺判定を使った受け止めや、当て身判定での受け止めで呼ばれる
//return 0 すると当て身に失敗する
//受け止める側から呼ばれる
// BMvCore.GetParamCharaData(0) すると当て身でとったオブジェクトを取得できる
Std_MoveTable.CheckAttackCatch <- function()
{
	return 1; // 当身成功
}


//ＫＯされた瞬間呼ばれて少しすると消滅するＭｖ
//ＫＯボイスの再生に使っている
//キャラ別に書き換えたければこれをいじろう
Std_MoveTable.Mv_KOImpact_Object <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		//LP0 : ＫＯ音声を再生したかどうか
		BMvTbl.SetLP(0,0); // 初期化
	}
	function FrameUpdate_Std()
	{
		//1F後に操作親のパターンを見て分岐
		local s = BMvTbl.GetMvStatus();
		if( BMvTbl.GetLP(0)==0 && s.MvCount>2  )
		{
			BMvTbl.SetLP(0,1);

			local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			if( p.IsDone )
			{
				if( BMvCore.PushCharaData( p ) )
				{
					local rs = BMvTbl.GetMvRoundStatus();
					// _dp("\n ラウンド:"+rs.Round );
					if( rs.Round != -2 ) // チュートリアル以外
					{
						local oya_s = BMvTbl.GetMvStatus();
						//_dm("s:"+oya_s.DataPattern);
						//ひざくずれとは言うがリンネの投げでも同様にやらないとまずそうなので290も含める
						local isHizakuzure = ( oya_s.DataPattern==327 || oya_s.DataPattern==290 ); //パターンで膝崩れかどうかをチェックしてるｗ
						if( rs.isLoseRound )
						{
							local seplay = 0; // 定義してあって再生されたら1
							if( isHizakuzure )
							{
								seplay = Battle_Std.TypeSE_Play({ type="決着ＫＯ_膝崩れ" });
							}
							else
							{
								seplay = Battle_Std.TypeSE_Play({ type="決着ＫＯ_通常" });
							}
							if( seplay==0 ) Battle_Std.TypeSE_Play({ type="決着ＫＯ" });
						}
						else
						{
							local seplay = 0; // 定義してあって再生されたら1
							if( isHizakuzure )
							{
								seplay = Battle_Std.TypeSE_Play({ type="ラウンドＫＯ_膝崩れ" });
							}
							else
							{
								seplay = Battle_Std.TypeSE_Play({ type="ラウンドＫＯ_通常" });			
							}
							if( seplay==0 ) Battle_Std.TypeSE_Play({ type="ラウンドＫＯ" });
						}
					}
				}
				BMvCore.PopCharaData();
			}
		}
		if( s.MvCount>60 ) BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}







//skill


Std_MoveTable.Mv_DebugPause <- 
{
	function Init_Std()
	{
		switch( Def_Dbg_DebugButtonMode )
		{
			case 1: //ゲージ増加
			case 3: //トレモ向け
			{
				btl_debPrint2("【デバッグ】ゲージ増加");
				local exs = BCMDTbl.GetComboGauge();
				BMvEff.SetSpGauge( { value=5000, correct=0 } );
				BMvEff.Liberate_End(); //ヴェールオフ状態だったら終了する
				
				//満タンっぽかったら空にする
				if( exs==20000 || exs==40000 )
				{
					BMvEff.SetSpGauge( { value=-40000, correct=0 } );
				}
				
				BMvTbl.SetPattern( 0 ); //立ちポーズに戻る
				Battle_Std.InitVector();
				BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } );
				break;
			}
			case 2: //相手のみ時間停止
			{
				btl_debPrint2("【デバッグ】相手だけ時間停止");
				BMvEff.SetStopTime( { time=999, stopme=0 } );			
				BMvTbl.SetPattern( 0 ); //立ちポーズに戻る
				Battle_Std.InitVector();
				BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } );
				//BMvTbl.SetFinalize(0);
				break;
			}
			case 7: // ステージ確認
			{
				Battle_Std.InitVector();
				BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } );
				local pos = BMvTbl.GetPosition();
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					BMvTbl.SetPosition( { x=pos.x, y=pos.y } );
					
					enemy.pop();
				}
				BMvTbl.SetFinalize(0);
			}
			case 8:
			{
				BMvTbl.SetFinalize(100); // 登場
				break;
			}
			case 10:
			{
				//IWEを確認する
				BMvTbl.SetPattern(1);
				BMvTbl.SetFinalize(10000); // 潜在
				break;
			}
		}
	}
	function FrameUpdate_Std()
	{
		// Eを押している間継続
		if( BMvTbl.CheckButtonHold( (1<<4) ) == 0 )
		{
			BMvTbl.SetFinalize(0);
			return;
		}
		// 押している間の処理
		if( BMvTbl.CheckStickHold( (1<<2) ) )
		{
			// EXSを空にする
			BMvEff.SetSpGauge( { value=-40000, correct=0 } );
		}
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_Standby"], [10000,"Mv_Skill_IWEXIST"] ); //デフォ,[code,mv]...
	}	
}

Std_MoveTable.Mv_DebugButton_4 <-
{
	function Init_Std()
	{
		switch( Def_Dbg_DebugButtonMode )
		{
			case 1: //
			{
			
				BMvTbl.SetFinalize(0);
				break;
			}
			case 2: // 
			{
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
				if( enemy.push() )
				{
					BMvEff.SetSpGauge( { value=2500, correct=0 } );

					enemy.pop();
				}			
				BMvTbl.SetFinalize(0);
				break;
			}
			case 3: //
			{
				local muki = BMvTbl.GetMuki();
				BMvTbl.SetPosition( { x=-def_POS_GamenHajiX*muki, y=0 } );
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
				if( enemy.IsDone )
				{
					if( BMvCore.PushCharaData( enemy ) )
					{
						BMvTbl.SetPosition( { x=-def_POS_GamenHajiX*muki, y=0 } );
						BMvEff.SetSpGauge( { value=-50000, correct=0 } );
					}
					BMvCore.PopCharaData(); //
				}
				BMvTbl.SetPattern("DUkemi_0"); //これで安心
				Battle_Std.InitVector();
				BMvTbl.SetVector( { y=-1000, addy=190, flags=_Vector_Normal } );
				BMvTbl.SetFinalizeCode(0);
				break;
			}
			case 6:
			{
				BMvTbl.SetFinalize(0);
				break;			
			}
			case 7:
			{
				BMvTbl.SetPosition( { x=-500, flags=_Position_ChangeMuki|_Position_Add|_Position_CaptureShift } );
				BMvTbl.SetFinalize(0);
				break;			
			}
			case 8:
			{
				BMvTbl.SetFinalize(100); // 勝利
				break;
			}
		}
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_RoundWinPattern"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_DebugButton_6 <-
{
	function Init_Std()
	{
		switch( Def_Dbg_DebugButtonMode )
		{
			case 1: //
			{
				BMvTbl.SetFinalize(0);
				break;
			}
			case 2: // 
			{
				{
					BMvEff.SetSpGauge( { value=2500, correct=0 } );
				}			
				BMvTbl.SetFinalize(0);
				break;
			}			case 3: //
			{
				local muki = BMvTbl.GetMuki();
				BMvTbl.SetPosition( { x=def_POS_GamenHajiX*muki, y=0 } );
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
				if( enemy.IsDone )
				{
					if( BMvCore.PushCharaData( enemy ) )
					{
						BMvTbl.SetPosition( { x=def_POS_GamenHajiX*muki, y=0 } );
						BMvEff.SetSpGauge( { value=-50000, correct=0 } );
					}
					BMvCore.PopCharaData(); //
				}
				BMvTbl.SetPattern("DUkemi_0"); //これで安心
				Battle_Std.InitVector();
				BMvTbl.SetVector( { y=-1000, addy=190, flags=_Vector_Normal } );				
				BMvTbl.SetFinalizeCode(0);
				break;
			}
			case 6:
			{
				BMvTbl.SetFinalize(0);
				break;			
			}
			case 7:
			{
				BMvTbl.SetPosition( { x=500, flags=_Position_ChangeMuki|_Position_Add|_Position_CaptureShift } );
				BMvTbl.SetFinalize(0);
				break;			
			}
			case 8:
			{
				BMvTbl.SetFinalize(100); // 勝利
				break;
			}			
		}
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_WinPattern"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_DebugButton_2 <-
{
	function Init_Std()
	{
		//BMvTbl.ClearCommand();
		switch( Def_Dbg_DebugButtonMode )
		{
			case 1: //
			case 2: //
			{
				BMvTbl.SetFinalize(0);
				break;
			}
			case 2: // 
			{
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
				if( enemy.push() )
				{
					BMvEff.SetSpGauge( { value=-5000, correct=0 } );

					enemy.pop();
				}			
				BMvTbl.SetFinalize(0);
				break;
			}
			case 3: //
			{
				btl_debPrint2("【デバッグ】相手のゲージ増加");
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
				if( enemy.IsDone )
				{
					if( BMvCore.PushCharaData( enemy ) )
					{
						local exs = BCMDTbl.GetComboGauge();
						BMvEff.SetSpGauge( { value=5000, correct=0 } );
						BMvEff.Liberate_End(); //ヴェールオフ状態だったら終了する
						
						//満タンっぽかったら空にする
						if( exs==20000 || exs==40000 )
						{
							BMvEff.SetSpGauge( { value=-50000, correct=0 } );
						}
					}
					BMvCore.PopCharaData(); //
				}
				BMvTbl.SetPattern("DUkemi_0"); //これで安心
				Battle_Std.InitVector();
				BMvTbl.SetVector( { y=-1000, addy=190, flags=_Vector_Normal } );				
				BMvTbl.SetFinalizeCode(0);
				break;
			}
			case 6:
			{
				BMvTbl.SetFinalize(0);
				break;			
			}
			case 8:
			{
				BMvTbl.SetFinalize(512); // 勝利
				break;
			}				
			case 9:
			{
				BMvTbl.SetFinalize(256); // イグジスト
				break;
			}				
		}
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_SpecialIWEXIST"], [512,"Mv_TimeupLose"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_LastArcBlastWait <- 
{
	function Init_Std()
	{
		BMvTbl.SetMuki( _Direction_Auto );
		BMvTbl.SetPattern( 150 );
		Battle_Std.InitVector(); // ベクトル全てクリア
		BMvTbl.SetVector( { y=0, flags=_Vector_Div } );
		BMvTbl.SetPosition( { y=0 } ); // かならず地面からでる。同時押しの都合でちょっと浮いてることがある
		
		BMvTbl.SetLP(0,0);//
		local gauge_par = BMvEff.Liberate_GetTimeValue();
		BMvTbl.SetLP(0,gauge_par);

		//IWEの処理をもってきた
		BMvEff.SpGauge_SetLimit( { time=def_FL_EXSLimit_IWEAtk } ); //一定時間ゲージ増加に制限をかける
		
		Battle_Std.Init_ExistAtkSkill(); //SPゲージ消費・カットイン呼び出し
		// BMvEff.CutInProc_Set({ time=[10,999,10], cutin_mv="Mv_CutinGrp",erasetype=1, bgtype=0 }); //カットイングラフィックとか呼び
		Battle_Std.MoveCode.AddFlag( def_MC_Skill|def_MC_EXAction ); // 行動コード(必殺技)を設定
		
		BMvEff.Liberate_End(); //開放中なら終了
		
		//エフェクト表示
		local eff = BMvEff.CreateObject( { datatype=1, start_pat=271, x=0, y=-200*128 } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_EraseParentDamage|_ObjFlags_NoGround } );
			eff.pop();
		}
		
		BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_dageX=254, muteki_nage=254, muteki_nageX=254 } );
		Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		//Battle_Std.TypeSE_Play({ type="バウンドブラスト" });
		
		//演出テスト
		
		BMvTbl.SetCounterHitFlag( { val=1, time=254, flag=_ClearFlag_ChangeMv } );//行動中ハイカウンター
		
		BMvTbl.AddComboRate(); // コンボレート加算
		
		//def_PAT_LastArc_Atkのキャッシュ予約
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_LastArc_Atk, frame=0, rest=30 } );
	}
	function FrameUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=2, muteki_dageX=2, muteki_nage=2, muteki_nageX=2 } );
		
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 42)//発生遅めでコンボ入れにくく？そもそもキャンセル不能な方がいいかも…
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_LastArc_Atk" );
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );
	}
}	


Std_MoveTable.Mv_LastArc_Atk <- 
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function Init_Std()
	{
		Battle_Std.InitCharaVector();
		BMvTbl.SetPattern(151);
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
	}
	function HitInterrupt_Std()
	{
		Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_LastArc_AtkHit"]); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_LastArc_AtkHit <- 
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function Init_Std()
	{
		Battle_Std.InitCharaVector();
		BMvEff.ThrowParam( { pattern=320, x=250, y=0 } );
		BMvTbl.SetFinalize(0);
		BMvEff.SetPlayerTimer( { muteki_dage=10, muteki_nage=10, muteki_dageX=10, muteki_nageX=10 } );
		BMvEff.SetExist( { level=_Exist_NoKuraiHantei, mode=_ExistMode_Set } );
		
		Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_SPActionProduction );
	}
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_LastArc_PreHit" );
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_nage=0, muteki_dageX=0, muteki_nageX=0 } );
		BMvEff.SetExist( { level=0 } );
	}	
}

Std_MoveTable.Mv_LastArc_PreHit <- 
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function Init_Std()
	{
		//シールド成功orA+B+C+Dでくる（事前にLP0にゲージ残量が入っている）
		//60Fの時間停止で画面を真っ白にする
		//真っ白にした後、適当な絵に変更して相手を一発殴ってやられ状態にする
		//そのまま30F待機してから抜ける
		//抜けるときにゲージ残量(LP0)に応じてダメージ補正をかける
		
		Battle_Std.InitCharaVector();
		
		//時間停止しつつ画面を白くしていく
		BMvEff.SetStopTime( { time=60, stopme=2, bounderase=1 } ); //時間停止
		BMvEff.CutInProc_Set({ time=[10,999,10], cutin_mv="Mv_IWXCutinGrp", erasetype=1, bgtype=0 }); //カットイングラフィックとか呼び
		
		BMvEff.SetCamera_Focus( { charapos=1, zoom=1.25, time=[30,90+10,0], type_in=3, type_out=1 } ); //カメラ集中テスト
		
		BMvTbl.SetMvAction( def_MVA_SPSkill );
		Battle_Std.MoveCode.AddFlag( def_MC_Skill|def_MC_SPAction ); // 行動コード
		BMvEff.SetPlayerTimer( { muteki_dage=10, muteki_nage=10, muteki_dageX=10, muteki_nageX=10 } );
		BMvEff.SetExist( { level=_Exist_NoHantei, mode=_ExistMode_Set } );
		
		Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_SPActionProduction );
		
		local eff = BMvEff.CreateObject( { datatype=1, start_pat="LastArcWhiteOut" } );
		if( eff.push() )
		{
			BMvTbl.SetPrio( _CharaPrio_Near_Layer_0 );
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll|_ObjFlags_NoCamera } );
			BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
			BMvTbl.SetPosition( { x=0, y=0 } );
			
			eff.pop();
		}
		
		//KO後にLAするとゲージは減らないけど覚醒が終わってしまうのでチェック
		if( !Battle_Std.RoundisEnd() )
		{
			BMvEff.SpGauge_SetAwakens( 0 );//覚醒終了
		}
		BMvEff.Cockpit_SetPrioU( 1 );//隠れちゃうのでゲージ手前に
		// BSound.BGM_SetFade( { val=50, time=60 } );//BGMのフェード
		
		Battle_Std.TypeSE_Play({ type="ラストアーク成立" });
		BMvEff.AttackInfoString_Set({ word=def_AISW_LASkill,} );	
		
		BSound.SE_Play( { type=_SeType_Normal, num=35 } );//ラストアーク発動SE
		
		//前のMv
		if( BMvTbl.ChangeMv_GetMvName() == "Mv_LastArc" )
		{
			//シールドからのラストアークだ
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GenFlag );
		}
		
		//LA中の判定などがパートナーにあたると、演出中に相手がでてきてしまう
		//強制的にやられにする判定もあてるとまずいので消す
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			if( BMvCore.GetTagStatus() != -1 )
			{
				local pertner = BMvCore.GetPertnerCharaData();
				if( pertner.push() )
				{
					BMvTbl.SetAliveFlag( { val=0, time=255, flag=_ClearFlag_ChangeMv } );
					
					pertner.pop();
				}
			}
			enemy.pop();
		}
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		// _dpn("count:"+mvs.MvCount);
		if( mvs.MvCount == 5 )
		{
			//時間停止終了後(2Fではなく4F以上にして敵キャラのupdate処理の後にする)
			Battle_Std.InitVector();
			Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_PartnerAtkMvStop );//パートナーの攻撃があったら止めてしまう
			
			// 開始座標を固定にする
			local muki = BMvTbl.GetMuki();
			BMvTbl.SetPosition( { x=-320*128*muki, y=0 } );
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				//念の為ベクトル初期化
				Battle_Std.InitVector();
				
				BMvTbl.SetPosition( { x=320*128*muki, y=0 } );
				enemy.pop();
			}
			
			BMvTbl.SetPattern(def_PAT_SuperMotion);
			BMvEff.ThrowParam( { pattern=620, x=640, y=0 } );
			
			//攻撃判定
			local eff = BMvEff.CreateObject( { datatype=1, start_pat="LastArcWhite" } );
			if( eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll } );
				
				eff.pop();
			}
		}
		else if( mvs.MvCount > 30 )
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Skill_LastArc_Hit" );
		BMvTbl.SetPosition( { y=0 } ); // 地面でとったようにする
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_nage=0, muteki_dageX=0, muteki_nageX=0 } );
		BMvEff.SetExist( { level=_Exist_NoKuraiHantei, mode=_ExistMode_Erase } );
		BMvEff.SetExist( { level=0 } );
		BMvEff.SetCamera_Focus( { time=[0,0,0] } ); // カメラ集中の解除
		
		//BMvTbl.SetLP(0,0);//ラストアークのダメージ割合
		local gauge_par = BMvTbl.GetLP(0);
		if( gauge_par > 100 ) gauge_par = 100;
		if( gauge_par <   0 ) gauge_par =   0;
		
		//LAのダメージは6000
		// 0〜100
		//50〜100
		local damage_hosei_par = 80 + (gauge_par*40/100);
		BMvEff.ComboView_Set( { val=damage_hosei_par, type=1 } ); // 乗算
		// _dpn("damage_hosei_par:"+damage_hosei_par+" gauge_par:"+gauge_par);
		
		//途中で抜けたようなときの救済処理
		if( BMvTbl.FromFinalize() == 0 )
		{
			//※ありえないはずだけど、ヤバそうなのだけ念の為入れておく
			//もとに戻す処理
			BMvEff.Cockpit_SetPrioU( 0 );
			BSound.BGM_SetFade( { val=100, time=60 } );
		}
	}
}

//シールド成功時に飛んでくるラストアーク
//無理やり掴んで演出を始めてしまう
//このMv名を見て次のMvで処理をしているので注意
Std_MoveTable.Mv_LastArc <-
{
	function Init_Std()
	{
		Battle_Std.InitVector(); // ベクトル全てクリア

		BMvTbl.SetLP(0,0);//LA発動時のゲージ残量
		
		local gauge_par = BMvEff.Liberate_GetTimeValue();
		BMvTbl.SetLP(0,gauge_par);
		
		BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } ); //ＳＰゲージ予約分を消費
		BMvEff.Liberate_End(); //開放中なら終了

		local enemy = BMvCore.GetEnemyCharaData();
		local enemy_is_damage = Battle_Std.CheckEnemyisDamage();
		local ret = BMvEff.CapturePlayer( { target = enemy } );
		if( ret == 1 )
		{
			//シールド成功時のLA
			BMvTbl.SetFinalize(256);
			
			if( Def_Sys_CapturePlayerAddMoonIcon && !enemy_is_damage )
			{
				Battle_Std.Moon_AddValue(Def_AttackDamageInitMoonAdd,1);//攻撃初段でのボーナス（パートナー側からの呼び出しも有効）
				
				if( enemy.push() )
				{
					Battle_Std.Moon_AddValue(Def_DamageInitMoonAdd,1);//やられ初段でのボーナス
					enemy.pop();
				}
			}
		}
		else
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_LastArcMiss", [256,"Mv_LastArc_PreHit"]); 
	}
}

	
//投げ抜け猶予＆投げ抜け失敗フレーム管理
//def_PP_TechHit_FrameManagerに値が入るときは必ずこれとセットになっている
//値が入る＝カウントダウンしていく
//強引に投げ抜け不能状態にするときはdef_FL_Tech+1の状態になるので、強制スロウリジェクトミス状態となる
Std_MoveTable.Mv_Obj_TechHit_FrameManager <- 
{
	function Init_Std()
	{
		//_dm("FM:投げ抜けチェックきたよ");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		//BMvTbl.SetPP( def_PP_TechHit_FrameManager, 0 ); //投げ抜けチェック
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function Update()
	{
		local end_manage = 0;//管理終了する？
		local techman_frame = BMvTbl.GetPP( def_PP_TechHit_FrameManager );
		// 0 : 投げor投げ抜けをそもそも入れていないか、入力してからかなり経過した
		// 1〜40 : 投げ抜けを入力して何フレーム経過したか
		//def_FL_Tech					= 11;	//つかまれてからの投げ抜け猶予フレーム
		//def_FL_TechSenkou			= 5;		//投げコマンド入力してからの投げ抜け猶予フレーム　このフレームまでは投げ抜け		
		//def_FL_TechMiss				= 30;	//投げを入れてからの投げ抜け失敗フレーム　このフレームまでは投げ抜けミス		
		if (techman_frame<def_FL_TechMiss)
		{
			techman_frame++;
			BMvTbl.SetPP( def_PP_TechHit_FrameManager, techman_frame ); //失敗フレームになるまでは時間をしまっておこう
		}
		else
		{
			end_manage = 1; // 終了
		}
		
		/*
		//ガード中に投げ抜けを入れて、硬直後のダッシュ投げとかでも解除されてしまうのはおかしい…ので一旦戻す
		//投げつかみの処理が行動可能かどうかを見て赤投げ判断してるので、ここも同じ条件じゃないとおかしい
		if( Battle_Std.CheckPlayerisMovable() )
		{
			end_manage = 1; // 終了
		}
		*/
		
		if( end_manage )
		{
			BMvTbl.SetPP( def_PP_TechHit_FrameManager, 0 ); //終了
			BMvTbl.SetFinalize(0);
		}
		//_dp(format("\n投げ抜け：%d",BMvTbl.GetPP( def_PP_TechHit_FrameManager ) ))
	}
	function Finalize()
	{
		//_dm("FM:ばいばい");
		BMvTbl.SetDeleteMoveTable();
	}
}

//親のMvが変化or特定フレームで投げ属性を消去する
Std_MoveTable.Mv_Obj_SetAutoThrowMv <-
{
	function Init()
	{
		//_dm("次のフレームにフラグを消去");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );//これは時間停止の影響を受けます
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		//LP0 ::指定フレーム
	}
	function Update()
	{
		local s = BMvTbl.GetMvStatus();	
		local frame = BMvTbl.GetLP(0); //何フレーム後に消すのか
		local end_flag = ( s.MvCount>frame);
		if( end_flag) BMvTbl.SetFinalize(0);
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate()
	{
		//print("\nフラグけすお");
		BMvEff.CreateObject( {  mvname="Mv_Obj_DelThrowMv" } ); //1F後にフラグを消すMvを作成
	}
}

Std_MoveTable.Mv_Obj_DelThrowMv <-
{
	function Init_Std()
	{
		//_dm("次のフレームにフラグを消去");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
//		BMvTbl.SetPP( def_PP_TechHit_FrameManager, 0 ); //投げ抜けチェック
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function Update()
	{
		local s = BMvTbl.GetMvStatus();	
		if( s.MvCount>2) BMvTbl.SetFinalize(0)
	}
	function Finalize()
	{
		Battle_Std.DelPSFlag( def_PP_PS_isThrowMv ); //投げ属性モーションを削除
		BMvTbl.SetDeleteMoveTable();
	}
}

// Std_MoveTableに特殊技関係をガーッと追加する関数
local Add_EXAtks = function( stdmv ) : (set_AirAtkLandStatus, set_AirAtk_LandMoveableFrame)
{
	//関数内関数
	local makemv_GroundEXAtk = function( param={} )
	{
		local retmv = {};
		
		local limit = param.ComboLimit;
		local pat = param.Pattern;
		local nextmv = param.NextMv;
		local movecode = param.MoveCode;
		local ground_atk_flags = ( "AtkFlags" in param )? param.AtkFlags : 0;
		local atkLv = param.AtkLv;
		
		local atkTable = ( "atkTable" in param )? param.atkTable : {};
		local isAdd = ( "isAdd" in atkTable && atkTable.isAdd );
		
		retmv.Init_Std <- function() : ( limit, pat, movecode, ground_atk_flags, atkLv, isAdd )
		{
			Battle_Std.InitGroundAtk( { type=atkLv, flags=ground_atk_flags } ); //通常攻撃共通Init
			
			if( movecode )
			{
				// 行動コード追加
				// _dp("\n 追加:"+movecode);
				Battle_Std.MoveCode.AddFlag( movecode );
			}
			Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_UniqAttack ); // 特殊技
			
			if( isAdd )
			{
				Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_AddMv );
				Battle_Std.PassAddSkillMoveCodes();
			}
		
			BMvTbl.SetComboLimit( limit );
			BMvTbl.SetPattern( pat );
		}

		retmv.Start_Std <- function()
		{
			Battle_Std.StartGroundAtk();
		}

		local fu_voice = param.FUVoice;

		retmv.FrameUpdate_Std <- function() : (fu_voice)
		{
			Battle_Std.TypeSE_Play({ type=fu_voice });
		}
		
		retmv.HitInterrupt_Std <- function()
		{
			Battle_Std.MvRule_Atk_HitInterrupt();
		}	

		retmv.Finalize_Std <- function() : (nextmv)
		{
			BMvTbl.SetNextMoveTable( nextmv );
		}
		return retmv;
	}


	local makemv_AirEXAtk = function( param={} ) : (set_AirAtkLandStatus)
	{
		local retmv = {};
		
		local limit = param.ComboLimit;
		local pat = param.Pattern;
		local movecode = param.MoveCode;
		local atkLv = param.AtkLv;
		
		local atkTable = ( "atkTable" in param )? param.atkTable : {};
		local isAdd = ( "isAdd" in atkTable && atkTable.isAdd );
		
		retmv.Init_Std <- function() : ( limit, pat, movecode, atkLv, isAdd )
		{
			Battle_Std.InitAirAtk( { type=atkLv } ); //通常攻撃共通Init
			
			if( movecode )
			{
				// 行動コード追加
				// _dp("\n 追加:"+movecode);
				Battle_Std.MoveCode.AddFlag( movecode );
			}			

			Battle_Std.SetStatus_AirAtkStatus(); //ジャンプ攻撃の各種フラグをリセット＋立てる
			
			if( isAdd )
			{
				Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_AddMv );
				Battle_Std.PassAddSkillMoveCodes();
			}
		
			BMvTbl.SetComboLimit( limit );
			BMvTbl.SetPattern( pat );
		}
		
		retmv.Start_Std <- function()
		{
			Battle_Std.StartAirAtk();
		}		

		local fu_voice = param.FUVoice;

		retmv.FrameUpdate_Std <- function() : (set_AirAtkLandStatus, fu_voice)
		{
			Battle_Std.TypeSE_Play({ type=fu_voice });
			local s = BMvTbl.GetMvStatus();
			if( s.isLanding )
			{
				set_AirAtkLandStatus(); // def_PP_AirAtkStatus に着地情報を入れる
				BMvTbl.SetFinalize(9999); //着地したらLandへ
			}
			Battle_Std.CheckAirAtkFsiki(); // 切り替え中段は上段に変更
		}
		
		retmv.HitInterrupt_Std <- function() : (atkLv)
		{
			Battle_Std.MvRule_Atk_HitInterrupt();
		}	

		local landmv = param.LandMv;
		retmv.Finalize_Std <- function() : ( landmv )
		{
			Battle_Std.SwitchNextMoveTable("Mv_Neutral", [9999,landmv] ); //デフォ,[code,mv]...
		}
		
		retmv.GetFinalizeCode_Std <- function() : (landmv)
		{
			return [ [0,"Mv_Neutral"], [9999,landmv] ];//XXX:9999はやめる
		}

		return retmv;
	}

	local makemv_AirEXAtkLand = function( param={} ) : (set_AirAtk_LandMoveableFrame)
	{
		local retmv = {};
		
		switch( param.AtkLv )
		{
		case "A":
			retmv.Init_Std <- function() : (set_AirAtk_LandMoveableFrame)
			{
				Battle_Std.InitAitAtkLand();
				
				set_AirAtk_LandMoveableFrame(			//着地硬直を設定
				def_FL_AtkAirA_LandRecovery,			//空振りした
				def_FL_AtkAirA_LandRecovery_Shielded,	//シールドされた
				def_FL_AtkAirA_LandRecovery_Damage,		//ダメージを与えた
				def_FL_AtkAirA_LandRecovery_Guard,		//ガードされた
				def_FL_AtkAirA_LandRecovery_Assault		//アサルトから出して空振りした
				def_FL_AtkAirA_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
				def_FL_AtkAirA_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
				def_FL_AtkAirA_LandRecovery_AssaultGuard		//アサルトから出してガードされた
				);
			}
			break;
		case "B":
			retmv.Init_Std <- function() : (set_AirAtk_LandMoveableFrame)
			{
				Battle_Std.InitAitAtkLand();
				
				set_AirAtk_LandMoveableFrame(			//着地硬直を設定
				def_FL_AtkAirB_LandRecovery,			//空振りした
				def_FL_AtkAirB_LandRecovery_Shielded,	//シールドされた
				def_FL_AtkAirB_LandRecovery_Damage,		//ダメージを与えた
				def_FL_AtkAirB_LandRecovery_Guard,		//ガードされた
				def_FL_AtkAirB_LandRecovery_Assault		//アサルトから出して空振りした
				def_FL_AtkAirB_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
				def_FL_AtkAirB_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
				def_FL_AtkAirB_LandRecovery_AssaultGuard		//アサルトから出してガードされた
				);
			}
			break;
		case "C":
			retmv.Init_Std <- function() : (set_AirAtk_LandMoveableFrame)
			{
				Battle_Std.InitAitAtkLand();
				
				set_AirAtk_LandMoveableFrame(			//着地硬直を設定
				def_FL_AtkAirC_LandRecovery,			//空振りした
				def_FL_AtkAirC_LandRecovery_Shielded,	//シールドされた
				def_FL_AtkAirC_LandRecovery_Damage,		//ダメージを与えた
				def_FL_AtkAirC_LandRecovery_Guard,		//ガードされた
				def_FL_AtkAirC_LandRecovery_Assault		//アサルトから出して空振りした
				def_FL_AtkAirC_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
				def_FL_AtkAirC_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
				def_FL_AtkAirC_LandRecovery_AssaultGuard		//アサルトから出してガードされた
				);
			}
			break;
		}
		
		retmv.Finalize_Std <- function()
		{
			BMvTbl.SetNextMoveTable( "Mv_Neutral" );
		}
		
		return retmv;
	}




	local std_atk_list = [
		["Mv_Atk_Std6A", "6A", DEF_BS_CL_ATK6A, "Mv_Atk_Std6A_FU", "Mv_Neutral", def_MC_GRDLowBreak, 0, "A", {} ],
		["Mv_Atk_Std6B", "6B", DEF_BS_CL_ATK6B, "Mv_Atk_Std6B_FU", "Mv_Neutral", 0, 0, "B", {} ],
		["Mv_Atk_Std6C", "6C", DEF_BS_CL_ATK6C, "Mv_Atk_Std6C_FU", "Mv_Neutral", 0, 0, "C", {} ],
		["Mv_Atk_Std4A", "4A", DEF_BS_CL_ATK4A, "Mv_Atk_Std4A_FU", "Mv_Neutral", def_MC_GRDLowBreak, 0, "A", {} ],
		["Mv_Atk_Std4B", "4B", DEF_BS_CL_ATK4B, "Mv_Atk_Std4B_FU", "Mv_Neutral", 0, 0, "B", {} ],
		["Mv_Atk_Std4C", "4C", DEF_BS_CL_ATK4C, "Mv_Atk_Std4C_FU", "Mv_Neutral", 0, 0, "C", {} ],
		["Mv_Atk_Std3A", "3A", DEF_BS_CL_ATK3A, "Mv_Atk_Std3A_FU", "Mv_Neutral", def_MC_GRDLowBreak, 0, "A", {} ],
		["Mv_Atk_Std3B", "3B", DEF_BS_CL_ATK3B, "Mv_Atk_Std3B_FU", "Mv_Neutral", 0, 0, "B", {} ],
		["Mv_Atk_Std3C", "3C", DEF_BS_CL_ATK3C, "Mv_Atk_Std3C_FU", "Mv_Neutral", 0, 0, "C", {} ],
		["Mv_Atk_Std1A", "1A", DEF_BS_CL_ATK1A, "Mv_Atk_Std1A_FU", "Mv_Neutral", def_MC_GRDLowBreak, 0, "A", {} ],
		["Mv_Atk_Std1B", "1B", DEF_BS_CL_ATK1B, "Mv_Atk_Std1B_FU", "Mv_Neutral", 0, 0, "B", {} ],
		["Mv_Atk_Std1C", "1C", DEF_BS_CL_ATK1C, "Mv_Atk_Std1C_FU", "Mv_Neutral", 0, 0, "C", {} ],
		["Mv_Atk_6B_6B", "6B_6B", DEF_BS_CL_ATK6B_6B, "Mv_Atk_6B_6B_FU", "Mv_Neutral", 0, 0, "B", { isAdd=1 } ],
		["Mv_Atk_A_A", "A_A", DEF_BS_CL_ATKA_A, "Mv_Atk_A_A_FU", "Mv_Neutral", def_MC_GRDLowBreak, (1<<0), "A", { isAdd=1 } ],
		["Mv_Atk_B_B", "B_B", DEF_BS_CL_ATKB_B, "Mv_Atk_B_B_FU", "Mv_Neutral", 0, (1<<0), "B", { isAdd=1 } ],
		["Mv_Atk_C_C", "C_C", DEF_BS_CL_ATKC_C, "Mv_Atk_C_C_FU", "Mv_Neutral", 0, (1<<0), "C", { isAdd=1 } ],
		
		["Mv_Atk_Cro3A", "3A", DEF_BS_CL_ATK3A, "Mv_Atk_Cro3A_FU", "Mv_Crouch_Wait", def_MC_GRDLowBreak, 0, "A", {} ],
		["Mv_Atk_Cro3B", "3B", DEF_BS_CL_ATK3B, "Mv_Atk_Cro3B_FU", "Mv_Crouch_Wait", 0, 0, "B", {} ],
		["Mv_Atk_Cro3C", "3C", DEF_BS_CL_ATK3C, "Mv_Atk_Cro3C_FU", "Mv_Crouch_Wait", 0, 0, "C", {} ],
		["Mv_Atk_Cro1A", "1A", DEF_BS_CL_ATK1A, "Mv_Atk_Cro1A_FU", "Mv_Crouch_Wait", def_MC_GRDLowBreak, 0, "A", {} ],
		["Mv_Atk_Cro1B", "1B", DEF_BS_CL_ATK1B, "Mv_Atk_Cro1B_FU", "Mv_Crouch_Wait", 0, 0, "B", {} ],
		["Mv_Atk_Cro1C", "1C", DEF_BS_CL_ATK1C, "Mv_Atk_Cro1C_FU", "Mv_Crouch_Wait", 0, 0, "C", {} ],
		["Mv_Atk_2A_2A", "2A_2A", DEF_BS_CL_ATK2A_2A, "Mv_Atk_2A_2A_FU", "Mv_Crouch_Wait", def_MC_GRDLowBreak, (1<<0), "A", { isAdd=1 } ],
		["Mv_Atk_2B_2B", "2B_2B", DEF_BS_CL_ATK2B_2B, "Mv_Atk_2B_2B_FU", "Mv_Crouch_Wait", 0, (1<<0), "B", { isAdd=1 } ],
		["Mv_Atk_2B_2B_2B", "2B_2B_2B", DEF_BS_CL_ATK2B_2B_2B, "Mv_Atk_2B_2B_2B_FU", "Mv_Crouch_Wait", 0, (1<<0), "B", { isAdd=1 } ],
		["Mv_Atk_2C_2C", "2C_2C", DEF_BS_CL_ATK2C_2C, "Mv_Atk_2C_2C_FU", "Mv_Crouch_Wait", 0, (1<<0), "C", { isAdd=1 } ],
	];
	
	for( local i=0; i<std_atk_list.len(); i++ )
	{
		local param = std_atk_list[i];
		local mv = param[0];
		local pat = param[1];
		local limit = param[2];
		local fu_se = param[3];
		local nextmv = param[4];
		local movecode = param[5];
		local atkflags = param[6];
		local atklv = param[7];
		local atkTable = param[8];
		
		stdmv[mv] <- makemv_GroundEXAtk( { ComboLimit=limit, Pattern=pat, FUVoice=fu_se, NextMv=nextmv, MoveCode=movecode, AtkFlags=atkflags, AtkLv=atklv, atkTable=atkTable } );
	}
	
	/*
	local cro_atk_list = [
		["Mv_Atk_Cro6A", "6A", DEF_BS_CL_ATK6A, "Mv_Atk_Std6A_FU" ],
		
	];

	for( local i=0; i<cro_atk_list.len(); i++ )
	{
		local param = cro_atk_list[i];
		local mv = param[0];
		local pat = param[1];
		local limit = param[2];
		local fu_se = param[3];
		
		stdmv[mv] <- makemv_CroEXAtk( { ComboLimit=limit, Pattern=pat, FUVoice=fu_se } );
	}
	*/

	local air_atk_list = [
		["Mv_Atk_Air2A", "J2A", DEF_BS_CL_ATKJ2A, "Mv_Atk_Air2A_FU", "A", "Mv_Atk_Air2A_Land", def_MC_GRDLowBreak, {} ],
		["Mv_Atk_Air2B", "J2B", DEF_BS_CL_ATKJ2B, "Mv_Atk_Air2B_FU", "B", "Mv_Atk_Air2B_Land", 0, {} ],
		["Mv_Atk_Air2C", "J2C", DEF_BS_CL_ATKJ2C, "Mv_Atk_Air2C_FU", "C", "Mv_Atk_Air2C_Land", 0, {} ],
		["Mv_Atk_Air4A", "J4A", DEF_BS_CL_ATKJ4A, "Mv_Atk_Air4A_FU", "A", "Mv_Atk_Air4A_Land", def_MC_GRDLowBreak, {} ],
		["Mv_Atk_Air4B", "J4B", DEF_BS_CL_ATKJ4B, "Mv_Atk_Air4B_FU", "B", "Mv_Atk_Air4B_Land", 0, {} ],
		["Mv_Atk_Air4C", "J4C", DEF_BS_CL_ATKJ4C, "Mv_Atk_Air4C_FU", "C", "Mv_Atk_Air4C_Land", 0, {} ],
		["Mv_Atk_Air6A", "J6A", DEF_BS_CL_ATKJ6A, "Mv_Atk_Air6A_FU", "A", "Mv_Atk_Air6A_Land", def_MC_GRDLowBreak, {} ],
		["Mv_Atk_Air6B", "J6B", DEF_BS_CL_ATKJ6B, "Mv_Atk_Air6B_FU", "B", "Mv_Atk_Air6B_Land", 0, {} ],
		["Mv_Atk_Air6C", "J6C", DEF_BS_CL_ATKJ6C, "Mv_Atk_Air6C_FU", "C", "Mv_Atk_Air6C_Land", 0, {} ],
		["Mv_Atk_JA_JA", "JA_JA", DEF_BS_CL_ATKJA_JA, "Mv_Atk_JA_JA_FU", "A", "Mv_Atk_JA_JA_Land", def_MC_GRDLowBreak, { isAdd=1 } ],
		["Mv_Atk_JB_JB", "JB_JB", DEF_BS_CL_ATKJB_JB, "Mv_Atk_JB_JB_FU", "B", "Mv_Atk_JB_JB_Land", 0, { isAdd=1 } ],
		["Mv_Atk_JC_JC", "JC_JC", DEF_BS_CL_ATKJC_JC, "Mv_Atk_JC_JC_FU", "C", "Mv_Atk_JC_JC_Land", 0, { isAdd=1 } ],
	];

	
	for( local i=0; i<air_atk_list.len(); i++ )
	{
		local param = air_atk_list[i];
		local mv = param[0];
		local pat = param[1];
		local limit = param[2];
		local fu_se = param[3];
		local land_lv = param[4];
		local land_mv = param[5];
		local movecode = param[6];
		local atkTable = param[7];
		
		stdmv[mv] <- makemv_AirEXAtk( { ComboLimit=limit, Pattern=pat, FUVoice=fu_se, LandMv=land_mv, MoveCode=movecode, AtkLv=land_lv, atkTable=atkTable } );
		if( land_mv in stdmv )
		{
			// 既にあるのでスキップ
		}
		else
		{
			stdmv[land_mv] <- makemv_AirEXAtkLand( { AtkLv=land_lv } );
		}
	}
}

Add_EXAtks( Std_MoveTable );


// ここから自動生成無し

// A+B
Std_MoveTable.Mv_Atk_StdAandB <-
{
	function Init_Std()
	{
		Battle_Std.InitGroundAtk(); //通常攻撃共通Init

		BMvTbl.SetComboLimit(DEF_BS_CL_ATKAANDB);
		BMvTbl.SetPattern("A+B");
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="Mv_Atk_StdAandB_FU" });
	}	
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

Std_MoveTable.Mv_Atk_CroAandB <-
{
	function Init_Std()
	{
		Battle_Std.InitGroundAtk(); //通常攻撃共通Init

		BMvTbl.SetComboLimit(DEF_BS_CL_ATKCAANDB);
		BMvTbl.SetPattern("2+A+B");
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="Mv_Atk_CroAandB_FU" });
	}	
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}	
}

Std_MoveTable.Mv_Atk_AirAandB <-
{
	function Init_Std()
	{
		Battle_Std.InitAirAtk( { type="FF" } ); //通常攻撃共通Init

		BMvTbl.SetComboLimit(DEF_BS_CL_ATKJAANDB);
		BMvTbl.SetPattern("JA+B");
	}
	function Start_Std()
	{
		Battle_Std.StartAirAtk();
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="Mv_Atk_AirAandB_FU" });
		
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			// 着地で属性無敵を削除
			Battle_Std.MoveCodeEx.DelFlag( 7, def_MC7_LightLegsMuteki );//小足属性へ空振り予定のMV
			BMvTbl.SetHitCheckFlag( { type=0, val=Def_HitCheckFlag_LightLegs, time=0, flag=_ClearFlag_ChangeMv } ); // 小足無敵にスカるを削除
		}
	}	
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}


local grd_action_init = function()
{
	// 消費予約を行う
	local useval = ( BMvEff.GRD_GetJudgeResult() > 0 )? def_PP_GAU_VORPALUse : def_PP_GAU_NormalUse;
	BMvTbl.SetPP( def_PP_GRDAction_UseGRD, useval ); // 初期化（フラグ処理だけど、初期化＋設定なので上書きでOK）
	_dp("\n GRD消費予約:"+useval );
	
	// アナウンス表示
	// BMvEff.AttackInfoString_Set({ word=def_AISW_GRDAction,} );	
	
	BMvTbl.SetMvAction(def_MVA_EXAtk);
	Battle_Std.MoveCode.AddFlag( def_MC_BCAction ); // BC技
}

local grd_action_useGRD = function()
{
	local grd_st = BMvTbl.GetPP( def_PP_GRDAction_UseGRD );
	// 消費済みor消費しないフラグがあったらやらない
	if( !(grd_st&def_PP_GAU_Used) && !(grd_st&def_PP_GAU_NoUse) )
	{
		if( grd_st&def_PP_GAU_VORPALUse )
		{
			// １つ無くてもＯＫで、自分が0.5減る
			Battle_Std.GRD_AddValue( { val= -5000, boundplus=1 } );

			Battle_Std.PP_AddFlag( def_PP_GRDAction_UseGRD, def_PP_GAU_Used ); // 減らしたフラグを追加
			Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_PaySkillCost ); // コスト消費済み　※この処理では未使用だが統一のため追加
		}
		else if( grd_st&def_PP_GAU_NormalUse )
		{
			// １つ減って、１つ無いと相手が１つ増える
			Battle_Std.UseGRDStock( 1, 10000 ); // 消費GRD数, 相手増加GRD値(単位違注意)

			Battle_Std.PP_AddFlag( def_PP_GRDAction_UseGRD, def_PP_GAU_Used ); // 減らしたフラグを追加
			Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_PaySkillCost ); // コスト消費済み　※この処理では未使用だが統一のため追加
		}
	}
}

local grd_action_update = function() : (grd_action_useGRD)
{
	local grd_st = BMvTbl.GetPP( def_PP_GRDAction_UseGRD );
	if( !(grd_st&def_PP_GAU_Used) && !(grd_st&def_PP_GAU_NoUse) && !(grd_st&def_PP_GAU_NoUpdateUse) )
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount == 4 && mvs.CallCount==0 )
		{
			grd_action_useGRD();
		}
	}
}

local grd_action_lastupdate = function() : (grd_action_useGRD)
{
	local grd_st = BMvTbl.GetPP( def_PP_GRDAction_UseGRD );
	// 消費済みor消費しないフラグがあったらやらない
	if( !(grd_st&def_PP_GAU_Used) && !(grd_st&def_PP_GAU_NoUse) )
	{
		// 除外条件
		if( Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_DoujiEndYoyaku ) && !Battle_Std.CheckPlayerisBound() )
		{
			_dp("\n 同時押しで移った行動＆やられじゃないので処理しない");
		}
		else
		{
			grd_action_useGRD(); // GRD消費処理
		}
	}
}

// B+C
Std_MoveTable.Mv_Atk_StdBandC <-
{
	function Init_Std() : (grd_action_init)
	{
		Battle_Std.InitGroundAtk( { type="FF" } ); //通常攻撃共通Init
		grd_action_init(); // GRDアクション共通Init

		//通常技と必殺技の間の子でいろいろ都合が悪いのでコンボリミットは両方立つ
		BMvTbl.SetComboLimit(DEF_BS_CL_ATKBANDC);
		BMvTbl.SetComboLimit(DEF_BS_CL_ATKCBANDC);
		BMvTbl.SetPattern("B+C");
		
		Battle_Std.TypeSE_Play({ type="Mv_Atk_StdBandC_Init" });		
		
	}
	function Start_Std()
	{
		Battle_Std.StartGroundAtk();
	}
	function FrameUpdate_Std() : (grd_action_update)
	{
		Battle_Std.TypeSE_Play({ type="Mv_Atk_StdBandC_FU" });
		
		grd_action_update();
	}	
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
	function LastUpdate_Std() : (grd_action_lastupdate)
	{
		grd_action_lastupdate();
	}
}

Std_MoveTable.Mv_Atk_CroBandC <-
{
	function Init_Std() : (grd_action_init)
	{
		Battle_Std.InitGroundAtk( { type="FF" } ); //通常攻撃共通Init
		grd_action_init(); // GRDアクション共通Init

		//通常技と必殺技の間の子でいろいろ都合が悪いのでコンボリミットは両方立つ
		BMvTbl.SetComboLimit(DEF_BS_CL_ATKBANDC);
		BMvTbl.SetComboLimit(DEF_BS_CL_ATKCBANDC);
		BMvTbl.SetPattern("2+B+C");

		Battle_Std.TypeSE_Play({ type="Mv_Atk_CroBandC_Init" });
	}
	function Start_Std()
	{
		Battle_Std.StartGroundAtk();
	}
	function FrameUpdate_Std() : (grd_action_update)
	{
		Battle_Std.TypeSE_Play({ type="Mv_Atk_CroBandC_FU" });
		
		grd_action_update();
	}
	function Finalize() // 
	{
		// BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
		
		//XXX:btl_ChrTableFunc.txt
		//キャラの立ちしゃがみなどの状態を見て分岐
		if( BCMDTbl.CheckPosState(_PosState_Stand) )
		{
			BMvTbl.SetNextMoveTable( "Mv_Neutral" );
		}
		else
		{
			//しゃがみや空中の場合はここ
			//空中はないはずなのと、大半は立ちなのでこの処理順
			BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
		}
	}
	function LastUpdate_Std() : (grd_action_lastupdate)
	{
		grd_action_lastupdate();
	}	
}

Std_MoveTable.Mv_Atk_AirBandC <-
{
	function Init_Std() : (grd_action_init)
	{
		Battle_Std.InitAirAtk( { type="FF" } ); //通常攻撃共通Init
		grd_action_init(); // GRDアクション共通Init

		BMvTbl.SetComboLimit(DEF_BS_CL_ATKJBANDC);
		BMvTbl.SetPattern("JB+C");
		Battle_Std.TypeSE_Play({ type="Mv_Atk_AirBandC_Init" });
	}
	function Start_Std()
	{
		Battle_Std.StartAirAtk();
	}
	function FrameUpdate_Std() : (grd_action_update)
	{
		Battle_Std.TypeSE_Play({ type="Mv_Atk_AirBandC_FU" });
		
		grd_action_update();
		
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			// 着地で属性無敵を削除
			Battle_Std.MoveCodeEx.DelFlag( 7, def_MC7_LightLegsMuteki );//小足属性へ空振り予定のMV
			BMvTbl.SetHitCheckFlag( { type=0, val=Def_HitCheckFlag_LightLegs, time=0, flag=_ClearFlag_ChangeMv } ); // 小足無敵にスカるを削除
		}
	}
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
	function LastUpdate_Std() : (grd_action_lastupdate)
	{
		grd_action_lastupdate();
	}
}

//ダッシュ攻撃の処理にも近い間の子的な状態でやや複雑
Std_MoveTable.Mv_Atk_DashStdBandC <- 
{
	function Init_Std() : (grd_action_init)
	{
		Battle_Std.InitDashAtk("0606B+C");

		Battle_Std.MoveCodeEx.DelFlag( 1, def_MC1_NoAtkCansel ); // 通常Ｃから通常技へのキャンセルを除外する　を戻す
		grd_action_init(); // GRDアクション共通Init
		
		Battle_Std.TypeSE_Play({ type="Mv_Atk_DashStdBandC_Init" });		
	}
	function Start_Std()
	{
		Battle_Std.StartDashAtk();
	}
	function FrameUpdate_Std() : (grd_action_update)
	{
		Battle_Std.TypeSE_Play({ type="Mv_Atk_DashStdBandC_FU" });
		
		grd_action_update();
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
	function LastUpdate_Std() : (grd_action_lastupdate)
	{
		grd_action_lastupdate();
		BMvEff.PcAfterImage_Clear(); //残像の消去
	}
}


//空中投げ
Std_MoveTable.Mv_Throw_A <- 
{
	function Init_Std()
	{
		BMvTbl.SetPattern("Throw_A");
		BMvTbl.ClearHitStatus();

		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_InActive );
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		
		// コンボレート加算
		// 地上版にはない。地上版につけると連キャンの当て投げが安くなる
		BMvTbl.AddComboRate(); // コンボレート加算
		
		// 空中浮遊しないようにベクトル設定
		local vec = BMvTbl.GetVector( { flags=_Vector_Normal } );
		if( vec.addy < 190 )
		{
			BMvTbl.SetVector( { addy=190, flags=_Vector_Normal } );
		}
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="Mv_Throw_A_FU" });
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			BMvTbl.SetFinalize(512); //着地したらLandへ
		}		
	}
	function HitInterrupt_Std()
	{
		Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ
	}	
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Throw_A_Hit"],[512,"Mv_Throw_A_Land"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_Throw_A_Land <-
{
	function Init_Std()
	{
		Battle_Std.InitCharaVector();
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
	}
	function Finalize()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.Mv_Throw_A_Hit <- 
{
	function Init_Std() // 
	{
		
		//逆投げだったらここで反転
		if( BMvTbl.GetPP(def_PP_TechReverse) == 1 ) BMvTbl.SetMuki(_Direction_Reverse);	//逆投げなんで反転		
		Battle_Std.InitVector(); //慣性削除		

		//反転後にパターン設定
		BMvTbl.SetPattern("Throw_A_Hit");
		
		Battle_Std.PassHitMoveCodes(); // ヒット分岐でのMvCode引継ぎ
		
		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		BMvTbl.SetMvAction( def_MVA_Throw );
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="Mv_Throw_A_Hit_FU" });
	}
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}		
}

// 同時押しダッシュで生成される
// 
Std_MoveTable.Mv_DoujiDash_F_HoldCheckObject <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround|_ObjFlags_ParentMove } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } ); //隠す
		
		BMvTbl.SetLP(0,0); // ボタンを離したかどうか
		BMvTbl.SetLP(1,0); // ボタンを離したあと何フレーム経過したか。これが2になるとオブジェクトが消滅する。（lastdelay対策）
		// 6+A+B → 1Fでニュートラル →　とすると、このオブジェクトが消えて技制限が消えるが、6+A+Bのキーは残っているのでlastdelayで受け付けているものがあると出てた
	}
	function Update_Std()
	{
		if( BMvTbl.GetLP(0) == 1 ) // ボタンを離した
		{
			local frame = BMvTbl.AddLP(1,1); // 経過したフレームを記憶
			//_dp("\n frame:"+frame);
			if( frame >= 2+2 ) // lastdelayが2F増えたので対応
			{
				BMvTbl.SetFinalize(0);
			}
		}
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();
		
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( player.push() )
		{
			local button_release = (BMvTbl.CheckButtonHold( (1<<0)|(1<<1) ) == 0)? 1 : 0;
			player.pop();

			if( s.MvCount>6+2 ) // lastdelayが2F増えたので対応
			{
				BMvTbl.SetFinalize(0); //長すぎ
			}
			if( button_release )
			{
				BMvTbl.SetLP(0,1); // ボタンを離したことを記憶
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		BMvTbl.SetPP(def_PP_CmdStatus, BMvTbl.GetPP(def_PP_CmdStatus)&~def_PP_CS_DoujiDash_F ); //フラグを消す
	}
}


_dp1p( "\n>>> [btl_UkemiFunc]" );

//Mv_RecoverInitObjectの将来的にはこっちに統一したい版
//全てのボタンをチェックする、各ボタンごとにクールタイムがある
Std_MoveTable.Mv_RecoverInitObject_Mask <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround|_ObjFlags_ParentMove } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } ); //隠す
		
		//入ってきたときに押しっぱなしにしていたボタンをチェックして
		//ボタン開放したらクールタイムセットして
		//なくなったら消滅
		//バティスタのボタンおしっぱなし離しの技が受け身のボタンで出ないようにするための処理
		
		BMvTbl.SetPP(def_PP_RecoverHoldMask,0);
		
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る

		local button = 0;
		if( player.push() )
		{
			for( local i=0; i<=3; i++ )
			{
				if( BMvTbl.CheckButtonHold( (1<<i) ) )
				{
					button = button|(1<<i);
				}
			}
			player.pop();
		}
		
		BMvTbl.SetPP(def_PP_RecoverHoldMask,button);
		
		// 入ってきたときに押しっぱなしのボタンをPPに記憶
		// 離されたらPPを更新
		
		BMvTbl.SetLP(0,0); //Aボタンのクールタイムとか LP>1:クールタイム中
		BMvTbl.SetLP(1,0); //Bボタンのクールタイムとか LP>1:クールタイム中
		BMvTbl.SetLP(2,0); //Cボタンのクールタイムとか LP>1:クールタイム中
		BMvTbl.SetLP(3,0); //Dボタンのクールタイムとか LP>1:クールタイム中
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();
		
		local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		//local button = BMvTbl.GetLP(0);
		local checkbutton = 0;
		for( local i=0; i<=3; i++ )
		{
			if( (BMvTbl.GetPP(def_PP_RecoverHoldMask)&(1<<i)) !=0 ) //最初に押してたやつかどうか
			{
				BMvCore.PushCharaData( p ); //
					checkbutton = BMvTbl.CheckButtonHold( (1<<i) );
				BMvCore.PopCharaData(); //
				
				if( checkbutton==0 && BMvTbl.GetLP(i)==0 ) //ボタン離してた
				{
					BMvTbl.SetLP(i,16); // 離したら10を入れる
					//print("\n 離した:"+i)
				}
				if( BMvTbl.GetLP(i)>0 ) //無条件でLPに値があったら減らしていく
				{
					if( BMvTbl.GetLP(i)<=1 ) //減りきったら
					{
						BMvTbl.SetPP(def_PP_RecoverHoldMask,( BMvTbl.GetPP(def_PP_RecoverHoldMask)&~(1<<i)) );	 //フラグを消す
						//print("\n 終了:"+i);
					}
					else
					{
						//print("\n 減らす:"+i);
						BMvTbl.AddLP(i,-1); //減らしていく					
					}
				}
			}
		}
		
		//print("\nret:"+ret+" button:"+button);
		if( BMvTbl.GetPP(def_PP_RecoverHoldMask)==0 )
		{
			//print("\n全部離した");
			BMvTbl.SetFinalize(0); //消える
		}
			
		if( s.MvCount>120 ) BMvTbl.SetFinalize(0); //長すぎ(120Fに変更)
	}
	function Finalize_Std()
	{
		//_dm("さよなら");
		BMvTbl.SetPP(def_PP_RecoverHoldMask,0);		
		BMvTbl.SetDeleteMoveTable();
	}
}

//あと何フレはやければ追撃されそうだったのか測定するだけ
//最大10F
Std_MoveTable.Mv_Obj_RecoverLateCombo <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=0, flags=_Position_CaptureShift } );

	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();

		//これいじょう長く測定しても調整には影響しねぇべ
		if( s.MvCount>10 )
		{
			BMvTbl.SetFinalize(0);
			return;
		}
		
		local e = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
		if( e.IsDone )
		{
			BMvCore.PushCharaData( e ); //	
				local e_pc = BMvEff.CheckHantei( { src=[ _Hantei_Attack, 0, -1 ], dst=[ _Hantei_Kurai, 0, -1 ], flags=_HC_FavourPc   } );
				local e_obj = BMvEff.CheckHantei( { src=[ _Hantei_Attack, 0, -1 ], dst=[ _Hantei_Kurai, 0, -1 ], flags=_HC_FavourObj   } );
			BMvCore.PopCharaData(); //
			
			if( e_pc.IsDone || e_obj.IsDone )
			{
				local frame = s.MvCount + 1;
				if( Def_Dbg_ComboChanceLog )
				{
					if( e.push() )
					{
						_dp1p(format("\nあと%dF早ければ追撃可かも",frame));
						
						e.pop();
					}
				}
				BMvTbl.SetFinalize(0);
				return;			
			}
			
		}
		else
		{
			BMvTbl.SetFinalize(0);
			return;			
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

/*
受身のMV仕様（メモ途中、正確性にかける）

Mv_Recover
　Mv_Recover_N
　Mv_Recover_F
　Mv_Recover_B
　Mv_GroundRecover
　　NorFはMVは同じでベクトルのみ変化

緊急受身
Mv_NeppaRecover
　Mv_GroundRecover

*/

// 空中受け身分岐
// 空中受身
Std_MoveTable.Mv_Recover <- 
{
	function Init()
	{
		local rst = BMvTbl.GetRecoverStatus(); // 受け身ステータスの取得
		BMvTbl.SetMuki( _Direction_Auto ); //見た目を変更（ベクトル入れる前に変更してもＯＫになった）
		
		local check_rst = rst.Type; //判定に使う受身ステータス
		//rst.Type 受け身入力時のレバー方向　※相手依存になった
		//0:ニュートラル
		//1:前
		//2:後ろ
		//3:下
		
		//寝ている状態からの復帰もここ
		//Y座標が0なら多分そうなので下受身はできないようにだけしておく
		local pos = BMvTbl.GetPosition(0);
		if( pos.y==0 ) //ダウン受け身の時
		{
			check_rst = 10;
		}
		else // 空中受身の時
		{
			if( check_rst==3 ) check_rst=0; //下受け身を廃止・ニュートラル受け身に書き換える
		}
		if( Def_Rule_AirRecover_ClearAirJumpCount ) // 受け身時に二段ジャンプの回数をリセットする
		{
			BMvTbl.AddAirJumpCount( -10 ); // 0回以下にはならないので多めに引く
		}
		BMvTbl.SetPattern("DUkemi_0");
		
		BMvTbl.SetFinalize(check_rst);
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Recover_N", [1,"Mv_Recover_F"], [2,"Mv_Recover_B"], [10,"Mv_GroundRecover"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_RecoverBarrier <- 
{
	function Init()
	{
		BMvTbl.SetLP(0,0); // 消える命令入ったかどうか
	}
	function FrameUpdate()
	{
		if( BMvTbl.GetLP(0) == 0 )
		{
			// オブジェクト側から呼び出し
			if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) != 0 )
			{
				// プレイヤーが自分自身発生させた行動中
			}
			else
			{
				// プレイヤーが自分自身発生させた行動中でない
				BMvTbl.SetLP(0,1);
				BMvTbl.JumpFrameID(900); // 消えるアニメへ
			}
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


local val_RecoverBarrierType = chrparam.Get( { type="空中受け身バリアタイプ", chrnum=_ChrNo } ); 

//空中受け身Ｍｖ作成
local makemv_recover = function( type=0 /* 0:ニュートラル 1:前 2:後ろ */, landmv="Mv_RecoverLand_N") : (val_RecoverBarrierType)
{
	local ret_tmpl = {};
	
	local param = 
	{
		vec = { x=-500, y=-3500, addx=0, addy=250 },
		muteki = 254,
	}
	
	switch( type ) /* 0:ニュートラル 1:前 2:後ろ */
	{
		case 0: //ニュートラル
			param.vec.x = -500;
			param.vec.y = -2800;
			param.muteki = def_FL_N_RecoverMuteki;
			break;
		case 1: //前
			param.vec.x = 1800;
			param.muteki = def_FL_F_RecoverMuteki;
			break;
		case 2: //後ろ
			param.vec.x = -1800;
			param.muteki = def_FL_B_RecoverMuteki;
			break;
	}
	
	ret_tmpl.Init <- function() : (param, val_RecoverBarrierType)
	{
		Battle_Std.InitRecover();
		
		BMvTbl.SetVector( { x=param.vec.x, y=param.vec.y, addx=param.vec.addx, addy=param.vec.addy } );
		BMvEff.SetPlayerTimer( { muteki_nage=param.muteki, muteki_dage=param.muteki, muteki_dageX=param.muteki, muteki_nageX=param.muteki  } );
		
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		
		Battle_Std.TypeSE_Play({ type="空中受け身" });
		
		BMvTbl.SetLP(0,0); //着地まで進んだかどうか
		
		Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定
		
		if( val_RecoverBarrierType == 0 )
		{
			local barrier_pos = { x=0, y=-250 };
			local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
			if( rc.sx != _Hantei_Error )
			{
				barrier_pos.x = rc.sx;
				barrier_pos.y = rc.sy;
			}
			else
			{
				_dpn("★★★受け身用の特殊判定が未設定１★★★");
			}
			BMvEff.CreateObject( { x=barrier_pos.x, y=barrier_pos.y, mvname="", datatype=1, start_pat=6, flags=_Position_ToolShift } );
		}
		else
		{
			local barrier_pos = { x=0, y=-250 };
			local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
			if( rc.sx != _Hantei_Error )
			{
				barrier_pos.x = rc.sx;
				barrier_pos.y = rc.sy;
			}
			else
			{
				_dpn("★★★受け身用の特殊判定が未設定２★★★");
			}
			BMvEff.CreateObject( { x=barrier_pos.x, y=barrier_pos.y, mvname="", datatype=1, start_pat=6, flags=_Position_ToolShift } );
			local eff = BMvEff.CreateObject( { x=rc.sx, y=rc.sy, mvname="Mv_RecoverBarrier", datatype=1, start_pat="RecoverBarrier", flags=_Position_ToolShift } );
			if( eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_EraseParentDamage } );
				eff.pop();
			}
		}		
	}
	
	ret_tmpl.FrameUpdate <- function()
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			BMvTbl.SetLP(0,1); //着地まで進んだ
			BMvTbl.SetFinalize(256); // 着地によるファイナライズ
		}	
	}
	
	ret_tmpl.Finalize <- function() : (landmv)
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,landmv]); //デフォ,[code,mv]...
	}
	
	ret_tmpl.LastUpdate <- function()
	{
		//着地経由せずに万が一抜けるような時は無敵を消しておく（ないはずだけど）
		if( BMvTbl.GetLP(0)==0 )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } );
		}
	}
	
	
	return ret_tmpl;

}

//空中受け身の着地ｍｖ作成　受け身状態ではない
local makemv_recoverland = function( type=0 /* 0:ニュートラル 1:前 2:後ろ */ )
{
	local ret_tmpl = {};
	
	ret_tmpl.Init <- function()
	{
		//着地したら時間の無敵は解除
		Battle_Std.InitVector(); // ベクトル初期化
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_OkiagariNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_OkiagariNageMuteki } ); //起き上がり無敵時間
		
		BMvTbl.SetMoveableFlag( { move=1, time=64, flag=_ClearFlag_ChangeMv } ); //着地後は行動可能に
		BMvTbl.SetLP(0,1); //着地まで進んだ
	}
	
	ret_tmpl.Finalize <- function()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" ); //共通落下をはさむので地上でいい
	}
	
	return ret_tmpl;

}

//空中前受け身
Std_MoveTable.Mv_Recover_N <- makemv_recover(0,"Mv_RecoverLand_N");
Std_MoveTable.Mv_Recover_F <- makemv_recover(1,"Mv_RecoverLand_F");
Std_MoveTable.Mv_Recover_B <- makemv_recover(2,"Mv_RecoverLand_B");

Std_MoveTable.Mv_RecoverLand_N <- makemv_recoverland(0);
Std_MoveTable.Mv_RecoverLand_F <- makemv_recoverland(1);
Std_MoveTable.Mv_RecoverLand_B <- makemv_recoverland(2);


Std_MoveTable.Mv_GroundRecover <- 
{
	function Init() : (val_RecoverBarrierType) // 
	{
		Battle_Std.InitRecover();
		
		BMvTbl.SetMuki( _Direction_Auto );

		Battle_Std.TypeSE_Play({ type="地上受け身" });
		
		BMvTbl.SetPattern("GUkemi_4"); // 新追加
		Battle_Std.InitVector();
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_dageX=254, muteki_nageX=254 } ); //	受け身中は無敵
		Battle_Std.TypeSE_Play({ type="跳ね受け身" });
		
		local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		if( rc.sx != _Hantei_Error ) // 存在するか
		{
			BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=23, flags=_Position_ToolShift } ); //受身
		}			
		//btl_debPrint( format( "\nMv_GroundRecover::Init :%d", rst.Type ) );
		
		Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		
		// レバーが後ろに入っていたら後ろに滑る受身を取る
		local rst = BMvTbl.GetRecoverStatus(); // 受け身ステータスの取得
		
		// _dp("\n Mv_GroundRecover:Stick:"+rst.Stick+" Type:"+rst.Type );
		
		// rst.Stick は 前回の地上受身のが入っている。トレモの時は何となくレバーが入っているらしい。
		// プレイヤーのみ2F前の入力を見る（ロールバック対策）
		local stick_is_back = 0;
		if( BMvTbl.IsCpu()==0 )
		{
			local muki = BMvTbl.GetMuki();
			local mask = ( muki == 1 )? (1<<4) : (1<<6);
			stick_is_back = BMvTbl.CheckStickHoldFrameKeyBuffer( mask, 2 ); // この関数はキーバッファからの取得のため向きを考慮してくれない
		}
		else
		{
			stick_is_back = BMvTbl.CheckStickHold( (1<<4) );
		}
		if( stick_is_back || ( rst.Stick == 4 ) ) // レバー後ろならまず成功（プレイヤーor緊急受身はこれ）、Stickが4でも成功（COMの地上受身の設定）
		{
			BMvTbl.SetLP(0,1); // 受け身タイプ記憶
			BMvTbl.SetVector( { x=-1800, y=-2400, addx=0, addy=200, flags=_Vector_Normal } );
			
			//GRD減少
			Battle_Std.GRD_AddValue({ val=def_GRD_BackGroundRecover, pressure=0, boundplus=0,target=0 });						
		}
		else
		{
			BMvTbl.SetLP(0,0); // 受け身タイプ記憶
			BMvTbl.SetVector( { x=-200, y=-2400, addx=0, addy=200, flags=_Vector_Normal } );
		}
		
		if( BMvTbl.ChangeMv_GetMvName()=="Mv_NeppaRecover" )
		{
			// _dp("\n 緊急受け身");
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GenFlag ); // 緊急受け身
		}
		
		//着地先を予約
		Battle_Std.CallAddSkillCache( "GUkemi_N", 15 ); // 着地先１を予約
		//後ろ受身の方
		Battle_Std.CallAddSkillCache( "GUkemi_B", 15 ); // 着地先２を予約
	}
	function FrameUpdate() : (callLandEffect)// フレーム更新処理
	{
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		
		if( mvs.isLanding )
		{
			local ukemitype = BMvTbl.GetLP(0);
			Battle_Std.InitCharaVector();
			// 地上受け身番号から
			switch( ukemitype )
			{
			case 0: //伏せ受身
				BMvTbl.SetFinalize(10); // 着地後動けていい
				break;
			case 1: //滑り受身
				BMvTbl.SetFinalize(20); // 着地後動けていい
				break;
			}
			
			callLandEffect(); // 着地エフェクト
		}
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[10,"Mv_GroundRecoverN_Land"],[20,"Mv_GroundRecoverB_Land"] ); //デフォ,[code,mv]...
	}
	function LastUpdate()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_GroundRecoverModoriNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_GroundRecoverModoriNageMuteki } );
		Battle_Std.Reversal.SetTime(); //リバーサル受付＋判定オブジェクト生成
	}
}

Std_MoveTable.Mv_GroundRecoverN_Land <-
{
	function Init() // 
	{
		BMvTbl.SetPattern("GUkemi_N");
		Battle_Std.InitCharaVector();
		BMvTbl.SetVector( { x=-500, y=0, addx=100, addy=0, flags=_Vector_Div } );
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_GroundRecoverModoriNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_GroundRecoverModoriNageMuteki } );
		BMvTbl.SetMoveableFlag({ move=1, time=30, flag=_ClearFlag_ChangeMv }); //Mv内行動可能
		
		Battle_Std.MoveCode.AddFlag( _MoveCode0_NoMoveBasicAction ); // 行動コード(歩き・しゃがみ移行不可)を設定
		
		//Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定　ここは戻りなので設定しない
	}
	function FrameUpdate()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 10 )
		{
			BMvTbl.SetFinalize(256);
		}
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_GroundRecover_Modori"]); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_GroundRecoverB_Land <-
{
	function Init() // 
	{
		BMvTbl.SetPattern("GUkemi_B");
		Battle_Std.InitCharaVector();
		BMvTbl.SetVector( { x=-2500, y=0, addx=200, addy=0, flags=_Vector_Div } );
		
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_GroundRecoverModoriNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_GroundRecoverModoriNageMuteki } );
		BMvTbl.SetMoveableFlag({ move=1, time=254, flag=_ClearFlag_ChangeMv }); //Mv内行動可能

		Battle_Std.MoveCode.AddFlag( _MoveCode0_NoMoveBasicAction ); // 行動コード(歩き・しゃがみ移行不可)を設定

		/*
		// 必殺ＣのみだとＶＯとか出せない
		// 投げ無敵がきれて行動不能なので投げが確定する
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_GroundRecoverModoriNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_GroundRecoverModoriNageMuteki } );
		BMvTbl.SetMoveableFlag({ move=0, time=30, flag=_ClearFlag_ChangeMv }); //Mv内行動不能
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=30, flag=_ClearFlag_ChangeMv } ); // 行動不能だけどガードは出来る
		BMvTbl.SetAsStatusFlag( { special=_CancelFlag_Always, time=30, flag=_ClearFlag_ChangeMv } ); // 必殺Ｃのみ可能
		*/
		
		//Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定　ここは戻りなので設定しない
	}
	function FrameUpdate()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 20 )
		{
			BMvTbl.SetFinalize(256);
		}
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_GroundRecover_Modori"]); //デフォ,[code,mv]...
	}
}


//無敵状態の移行だけを行う
Std_MoveTable.Mv_GroundRecover_Modori <-
{
	function Init() // 
	{
		BMvTbl.SetMoveableFlag({ move=1, time=30, flag=_ClearFlag_ChangeMv }); //Mv内行動可能
		
		//Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定　ここは戻りなので設定しない
	}
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.Mv_NeppaRecover <-
{
	function Init()
	{
		BMvTbl.SetFinalize(0);
	}
	function Finalize()
	{
		BMvTbl.SetNextMoveTable( "Mv_GroundRecover" );
	}
}

// 壁受け身
Std_MoveTable.Mv_WallRecover <- 
{
	function Init() // 
	{	
		Battle_Std.InitRecover();

		BMvTbl.SetMuki( _Direction_Auto );
		BMvTbl.SetPattern("GUkemi_0");
		Battle_Std.TypeSE_Play({ type="壁受け身" });

		//壁受身エフェクトを表示
		BMvEff.CreateObject( { x=0, y=-200, mvname="", datatype=1, start_pat=23, flags=_Position_ToolShift } ); //受身エフェクト		
		
		//はりつき中は無敵
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_WallRecoverMuteki, muteki_dage=def_FL_WallRecoverMuteki, muteki_dageX=def_FL_WallRecoverMuteki, muteki_nageX=def_FL_WallRecoverMuteki  } );		
	}
	function FrameUpdate()
	{
		local s = BMvTbl.GetMvStatus();
		
		if( s.MvCount>=def_FL_WallRecoverWaitMax )
		{
			_dm("壁受身から自動で復帰");
			if( BMvTbl.CheckStickHold( (1<<1) | (1<<2) | (1<<3) )==1)
			{
				BMvTbl.SetFinalize(def_FC_WallRecover_Sita); //下受身
			}
			else
			{
				BMvTbl.SetFinalize(0); //普通受身			
			}
		}
	}
	function LastUpdate()
	{
		//無敵解除
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0  } );		
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_WallRecover_Jump", [def_FC_WallRecover_Sita,"Mv_WallRecover_Jump_Sita"] ); //デフォ,[code,mv]...
	}
}// 

//とりあえずこれでバグらんようにしとこ
Std_MoveTable.Mv_WallRecover_Jump <- 
{
	function Init()
	{
		BMvTbl.SetMuki( _Direction_Auto );
		BMvTbl.SetPattern("DUkemi_0");
		BMvTbl.SetVector( { x=1600, y=-3500, addx=0, addy=250 } );
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_F_RecoverMuteki, muteki_dage=def_FL_F_RecoverMuteki, muteki_dageX=def_FL_F_RecoverMuteki, muteki_nageX=def_FL_F_RecoverMuteki  } );

		Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定		
	}
	function FrameUpdate()
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			//着地したら時間の無敵は解除
			Battle_Std.InitVector(); // ベクトル初期化
			BMvEff.SetPlayerTimer( { muteki_nage=def_FL_OkiagariNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_OkiagariNageMuteki } );		
		}	
	}	
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" ); //共通落下をはさむので地上でいい
	}
}

//とりあえずこれでバグらんようにしとこ
Std_MoveTable.Mv_WallRecover_Jump_Sita <- 
{
	function Init()
	{
		BMvTbl.SetMuki( _Direction_Auto );
		BMvTbl.SetPattern("DUkemi_0");
		BMvTbl.SetVector( { x=0, y=1000, addx=0, addy=250 } );
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_F_RecoverMuteki, muteki_dage=def_FL_F_RecoverMuteki, muteki_dageX=def_FL_F_RecoverMuteki, muteki_nageX=def_FL_F_RecoverMuteki  } );

		Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定		
	}
	function FrameUpdate()
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			//着地したら時間の無敵は解除
			Battle_Std.InitVector(); // ベクトル初期化
			BMvEff.SetPlayerTimer( { muteki_nage=def_FL_OkiagariNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_OkiagariNageMuteki } );		
		}
	}
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" ); //共通落下をはさむので地上でいい
	}
}




//オートリカバー共通処理
//受け身共通処理と重ねて呼ばれる
local autorecover_init = function()
{
	local combotime_pos = 0;
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	if( enemy.IsDone )
	{
		if( BMvCore.PushCharaData( enemy ) )
		{
			combotime_pos = BMvEff.SpGauge_GetPlusCorrect_ComboTimePos();
		}
		BMvCore.PopCharaData(); // 
	}

	//コンボの長さレベルからリカバリーボーナスを変更
	local combotime_lv = 3 - combotime_pos; //最後にダメージ受けた時点でのコンボの長さレベル
	//print("\ncombotime_lv:"+combotime_lv);
	local exsplus = 1000; //増加させるＥＸＳ量基本値
	local grdplus = def_GRD_AutoRecoverLv1; //増加させるＧＲＤ基本値
	if( combotime_lv >= 3 ) //３段階以降(x2.0)なら
	{
		exsplus = def_SP_AutoRecoverLv3;
		grdplus = def_GRD_AutoRecoverLv3;
	}
	else if( combotime_lv == 2 ) //２段階目(x1.5)なら
	{
		exsplus = def_SP_AutoRecoverLv2;
		grdplus = def_GRD_AutoRecoverLv2;
	}
	else if( combotime_lv == 1 ) //１段階目(x1.0)なら
	{
		exsplus = def_SP_AutoRecoverLv1;
		grdplus = def_GRD_AutoRecoverLv1;
	}
	else if( combotime_lv == 0 ) //０段階目（x0.5）なら
	{
		exsplus = def_SP_AutoRecoverLv0;
		grdplus = def_GRD_AutoRecoverLv0;
	}
	BMvEff.SetSpGauge( { value=exsplus, limitval=1.0, correct=0 } ); //ＥＸＳを増加させる
	Battle_Std.GRD_AddValue({ val=grdplus }); //受身でＧＲＤをより増加させる
}

//自動復帰
//浮きやられ復帰の空中状態。地上状態での復帰は別Ｍｖになった。Mv_Modori_UkiSirimoti
Std_MoveTable.Mv_AutoRecover <- 
{
	function Init_Std() : (autorecover_init) // 
	{
		local vec = BMvTbl.GetVector(0);
		//print(format("\nvec x:%d y:%d",vec.x, vec.y));
	
		//Battle_Std.TypeSE_Play({ type="自動受け身" });
	
		BMvTbl.SetPattern("UUkemi_1");
		BMvTbl.SetVector( { addy=150, flags=_Vector_Normal } ); //ふんわり浮きにする
		BMvTbl.SetVector( { y=-1000,  flags=_VecFlag_Add } ); //ふんわり浮きにする
		
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に

		local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		if( rc.sx != _Hantei_Error ) // 存在するか
		{
			BMvEff.CreateObject( { x=rc.sx, y=rc.sy, mvname="", datatype=1, start_pat=7, flags=_Position_ToolShift } );
		}			
		
		//ログ追加
		BMvEff.AttackInfoString_Set({ word=def_AISW_AutoRecover,} );		
		
		Battle_Std.InitRecover();

		autorecover_init(); //オートリカバー処理
		BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_nage=254 } ); //無敵時間を設定
		BMvTbl.SetMuki(_Direction_Auto);
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			Battle_Std.InitVector(); // ベクトル初期化
			BMvTbl.SetFinalize(256); //着地終了
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_AutoGroundRecover"] ); //デフォ,[code,mv]...
	}
}



//自動復帰中の着地
Std_MoveTable.Mv_AutoGroundRecover <- 
{
	function Init_Std()
	{
		Battle_Std.InitVector(); // ベクトル初期化
		//BMvTbl.SetPattern("GUkemi_2");
		BMvTbl.SetPattern("GUkemi_1");
		Battle_Std.TypeSE_Play({ type="地上受け身" });
		Battle_Std.TypeSE_Play({ type="跳ね受け身" });
		Battle_Std.TypeSE_Play({ type="自動受け身" });
		
		Battle_Std.SetCharaFlash_Ukemi(); //受身で光る
		BMvTbl.SetVector( { x=0, y=0, addx=0, addy=0 } );
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_F_GroundRecoverMuteki, muteki_dage=def_FL_F_GroundRecoverMuteki, muteki_dageX=def_FL_F_GroundRecoverMuteki, muteki_nageX=def_FL_F_GroundRecoverMuteki } ); //	
		
		BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=23, flags=_Position_ToolShift } ); //受身

		Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定
	}
	function FrameUpdate() // フレーム更新処理
	{
		local s = BMvTbl.GetMvStatus();
		switch( Battle_Std.GetUpdateFrameID( s ) )
		{
		case 100:
			//ID100にきた時のフレームからベクトルを計算する
			local vecx = 20000/(15-s.MvCount);
			local vecaddy = (1000/(15-s.MvCount))*2;

			_dm(format("vecx:%d mvcount:%d",vecx,s.MvCount))
			BMvTbl.SetVector( { x=-vecx, y=-1000, addx=0, addy=vecaddy } );
			break;
		case 150: //メルカヴァ用移動開始　※未使用
			BMvEff.StdCall( { type=6, no=12, param=[ -156,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); // 受身移動
			break;
		case 151: //メルカヴァ用移動開始
			BMvEff.StdCall( { type=6, no=12, param=[ -50,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); // 受身移動
			break;
		case 250: //メルカヴァ用着地
			BMvEff.StdCall( { type=6, no=12, param=[ -80,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); // 受身移動
			break;
		case 255: //メルカヴァ用着地
			BMvEff.StdCall( { type=6, no=12, param=[ -26,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); // 受身移動
			break;				
		case 200: //汎用着地
			BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=20, flags=_Position_ToolShift } ); //着地				
			break;
		case 210: //ワレン用着地
			BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=290, flags=_Position_ToolShift } ); //着地				
			break;
		}
		if( s.MvCount > def_FL_GroundRecoverHane_Recovery )
		{
			BMvTbl.SetFinalize(256);
		}
		if( BCMDTbl.CheckCancel()==255)
		{
			_dm("行動可能になったので受身状態解除");
			BMvTbl.SetFinalize(256);
		}
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_GroundRecover_Modori"]); //デフォ,[code,mv]...
	}
	function LastUpdate()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_GroundRecoverModoriNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_GroundRecoverModoriNageMuteki } );
		Battle_Std.Reversal.SetTime(); //リバーサル受付＋判定オブジェクト生成
		// BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); //重なり判定を復活
	}	
}


//空攻撃のけぞり着地（しりもち）からの復帰
Std_MoveTable.Mv_Modori_UkiSirimoti <- 
{
	function Init_Std() : (autorecover_init)
	{
		Battle_Std.InitVector(); // ベクトル初期化

		BtlMvStd.ClearBound(); // 状態解除　もうやられ状態ではなくす
		
		BMvTbl.SetFinalize(0);

		local eff = BMvEff.CreateObject( { x=0, y=-250, mvname="", datatype=1, start_pat=7, flags=_Position_ToolShift } );
		if( eff.IsDone )
		{
			BMvCore.PushCharaData( eff );
				BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
			BMvCore.PopCharaData();
		}
		
		BMvEff.AttackInfoString_Set({ word=def_AISW_AutoRecover,} );

		Battle_Std.InitRecover();
		autorecover_init(); //オートリカバー処理

		local useval = (BMvEff.GRD_GetJudgeResult()>0)? ( (BMvEff.GRD_CheckStock( { val=-1 } )>=6)? def_GRD_BoundFU_GRD6Vorpal : def_GRD_BoundFU_Vorpal) : def_GRD_BoundFU;
		Battle_Std.GRD_AddValue({ val=useval, pressure=0, boundplus=1 });	
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_AutoGroundRecover" );	//ファイナライズ
	}
	function LastUpdate_Std() // 
	{
		BtlMvStd.ClearBound(); // 状態解除
	}	
}


// 後から暗転するEX技の監視オブジェクト


Std_MoveTable.Mv_DelayExCutinObj <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
	}
	function FrameUpdate_Std()
	{
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local vanish = 0;
			local stopframe = def_FL_EXCutinStopTime;
			// 特殊判定１を監視して、見つかったらカットイン処理へ
			local rc0 = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
			
			if( rc0.sx != _Hantei_Error ) // 存在するか
			{
				Battle_Std.SetEXCutinCameraFocus( stopframe );
				Battle_Std.SetEXCutinGrp();
				vanish = 1;
			}
			player.pop();
			
			if( vanish ) BMvTbl.SetFinalize( 0 ); // 終わり
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


// Battle_Std.CSAntenGaesi_DamageHosei から呼ばれる
// CSでのキャンセルならうんたん、それ以外ならキツいダメージ補正をかける
// 要するにCSでないと追撃不能、という処理だと弱体化が激しいので
// CSでないとダメージ低い、という調整をするためのもの
Std_MoveTable.Mv_Null_CSHoseiChecker <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		
		// BMvTbl.SetLP(0,0); // 上書き補正
		// BMvTbl.SetLP(0,0); // 乗算補正
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount > 60 )
		{
			BMvTbl.SetFinalize( 0 );
			// lastupdateからmv変更まで60fもかかることはないと思うのでここで抜ける
		}
		
		// Mv名を監視する
		if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) == 0 )
		{
			// 別のMvに変わったようだよ
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				local mvname = BMvTbl.GetMvName();

				player.pop();
				
				if( mvname=="Mv_Convert" )
				{
					// CSで抜けた
					_dp("\n CSキャンセルだったね");
					BMvTbl.SetFinalize( 100 );
					return;
				}
			}
			
			BMvTbl.SetFinalize( 200 );
			local uwagaki = BMvTbl.GetLP(0);
			local zyozan = BMvTbl.GetLP(1);
			if( uwagaki ) BMvEff.ComboView_Set( { val=uwagaki, type=0 } ); // 上書き補正
			if( zyozan ) BMvEff.ComboView_Set( { val=zyozan, type=1 } ); // 乗算補正
			_dp("\n ★補正適用 上書き:"+uwagaki+" 乗算:"+zyozan );
			return;
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


//暗転されると生成されて、自分が暗転後動けるようになると消えるオブジェクト
//相手から生成を呼ばれるので注意
//呼び出しタイミング次第では、相手の行動が想定と異なることがあるので、何度か処理をする必要がある
Std_MoveTable.Mv_Null_AntenStopObject <-
{
	function SetEnemyAntenFlags() // 被暗転フラグを立てたりする
	{
		//下の処理がないと相殺で呼ばれるときにうまく動かない
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_EnemyAntenStop );
			
			if( Def_Sys_EnemyAntenStopNoCancel )
			{
				// 赤いもやが出たから…というわけではなく
				// 以下のCS可能フラグは、6DDとか4DDでもCSができるように入れているだけのものなので
				// 時間停止やCSされたときは無効にして、暗転後不自然にCSできないようにしている
				// MEMO:被暗転ではなく、被CSのときだけでもいい気がする？けど神のフレーム感があって不快ではある
				
				local mvname = BMvTbl.GetMvName();
				local mvs = BMvTbl.GetMvStatus();
				// _dpn("mvname:"+mvname);
				if( mvname == "Mv_ForwardShift" && mvs.MvCount < 10 )
				{
					_dpn("3D中の被暗転でキャンセルフラグを消す");
					BMvTbl.SetAsFlag( { as_flags=_AsFlag_ChainShift, time=0, flag=_ClearFlag_ChangeMv } );
				}
				if( (mvname == "Mv_Assault_Std" || mvname == "Mv_Assault_Air" ) && mvs.MvCount < 10 )
				{
					_dpn("アサルト中の被暗転でキャンセルフラグを消す");
					BMvTbl.SetAsFlag( { as_flags=_AsFlag_ChainShift, time=0, flag=_ClearFlag_ChangeMv } );
				}
				/*
				// でかかりではなく全フレームCS可能なのでこの処理はやらない
				if( (mvname == "Mv_Barrier_Std" || mvname == "Mv_Barrier_Cro" || mvname == "Mv_Barrier_Air") && mvs.MvCount < 10 )
				{
					// _dpn("シールド中の被暗転でキャンセルフラグを消す");
					BMvTbl.SetAsFlag( { as_flags=_AsFlag_ChainShift, time=0, flag=_ClearFlag_ChangeMv } );
				}
				*/
			}
			player.pop();
		}
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_Anten );
			enemy.pop();
		}		
		
	}
	function DelEnemyAntenFlags()
	{
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			Battle_Std.MoveCodeEx.DelFlag( 2, def_MC2_EnemyAntenStop );
			player.pop();
		}
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			Battle_Std.MoveCodeEx.DelFlag( 3, def_MC3_Anten );
			enemy.pop();
		}
	}
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		
		SetEnemyAntenFlags();
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount < 3 )
		{
			SetEnemyAntenFlags(); // 何度か処理をしないと1Fのズレに対応できない
		}
		else
		{
			DelEnemyAntenFlags(); // LastUpdateだと遅いのでここ？
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//次のフレームに暗転キャラに打撃無敵をつける
//EX必殺技専用
Std_MoveTable.Mv_Null_SetNextMutekiObject <-
{
	function Init_Std()
	{
		// BMvTbl.SetLP(0,0);// 生成時にセットされる暗転時間
	}
	function FrameUpdate_Std()
	{
		//暗転〜生成までに間に攻撃されたりした場合はすぐに消す
		if( Battle_Std.CheckPlayerisBound() )
		{
			BMvTbl.SetFinalize(0);
			return;
		}
		
		local anten_frame = (BMvTbl.GetLP(0) - 1); // 1F後なので暗転フレームも-1される

		local mvs = BMvTbl.GetMvStatus();
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local pmvs = BMvTbl.GetMvStatus();
			
			local is_ex_skill = ( Battle_Std.MoveCode.CheckFlag( def_MC_Skill ) && Battle_Std.MoveCode.CheckFlag( def_MC_EXAction ) );
			//基本的にはmvs.MvCount >= 1でOKだが、別のMvを0F経由してから出た技の場合、このオブジェクト自体の生成が1F遅れてしまう仕様がある
			//そのため、保険の意味もかねてプレイヤーのMvCountもチェックしている

			local set_muteki = ( mvs.MvCount >= 1 || pmvs.MvCount >= 2 );
			// _dpn("Frame:"+mvs.MvCount+" p:"+pmvs.MvCount+" set:"+set_muteki );
			
			if( set_muteki && is_ex_skill )
			{
				BMvEff.SetPlayerTimer( { muteki_dage=anten_frame, muteki_dageX=anten_frame } );
			}
			player.pop();
			
			if( set_muteki )
			{
				BMvTbl.SetFinalize(0);
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//次のフレームにカメラを追従カメラにくっつける
Std_MoveTable.Mv_Null_NextFrameResetViewCamera <-
{
	function Init_Std()
	{
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 1 )
		{
			BMvEff.ResetViewCamera();
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//1F経由しないとヒットした瞬間にダメージフラグが設定できないのでこうしている
Std_MoveTable.Mv_Null_EnemyDamageFlag_DelayAdd <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		// BMvTbl.SetLP(0,0);// フラグを親から受け取る
		// BMvTbl.SetLP(1,0);// 相手がisDamageのときだけフラグを立てる
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 1 )
		{
			// _dpn("フラグセット");
			if( BMvTbl.GetLP(1)==1 )
			{
				if( Battle_Std.CheckEnemyisDamage() )
				{
					Battle_Std.EnemyDamageFlag_Add( BMvTbl.GetLP(0) );
				}
			}
			else
			{
				Battle_Std.EnemyDamageFlag_Add( BMvTbl.GetLP(0) );
			}
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//InActive検知のあと相手が行動可能になるまで継続する
//これが生きている間に殴ると相手のゲージ増加量が減る
Std_MoveTable.Mv_Null_KeepInActive <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		Battle_Std.GS_AddFlag( def_PP_GS_KeepInActive );
		
		// BMvTbl.SetLP(0,0);
	}
	function FrameUpdate_Std()
	{
		local player_is_movable = Battle_Std.CheckPlayerisMovable();
		if( player_is_movable )
		{
			BMvTbl.SetFinalize(0);
			Battle_Std.GS_DelFlag( def_PP_GS_KeepInActive );
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		Battle_Std.GS_DelFlag( def_PP_GS_KeepInActive );
	}
}

// もともとはヒルダ用のMVだったのを共通化
Std_MoveTable.Mv_Null_EXSCharge <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );

		// 各値は呼び出し元の関数で決まる
		// BMvTbl.SetLP(0,25); // 効果フレーム
		// BMvTbl.SetLP(1,100); // 毎フレーム増やすゲージ量
		
		if( Def_Dbg_LocalDebugMode )
		{
			local frame = BMvTbl.GetLP(0);
			local add_val = BMvTbl.GetLP(1);
			local total_add = frame * add_val;
			_dpn("ゲージ増加処理:"+frame+"*"+add_val+"="+total_add);
		}
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= BMvTbl.GetLP(0) ) // 何フレーム増加処理をやるか
		{
			BMvTbl.SetFinalize( 0 );
			return;
		}
		
		local val = BMvTbl.GetLP(1); // 1Fの増加量
		BMvEff.SetSpGauge( { value=val, limitval=val, correct=0 } );
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


Std_MoveTable.Mv_Null_AddEnemyDamageFlag <-
{
	function SetHosei()
	{
		if( BMvTbl.GetLP(9)==0 )
		{
			BMvTbl.SetLP(9,1); // 1回で終わり
			
			local flag = BMvTbl.GetLP(0);
			
			_dpn("追加するEnemyDamageFlag:"+flag );

			if( flag )
			{
				Battle_Std.EnemyDamageFlag_Add( flag );
			}
		}
	}
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		
		// BMvTbl.SetLP(0,0); // 予定フラグ
		BMvTbl.SetLP(9,0); // 終了処理
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 240 || Battle_Std.CheckEnemyisDamage() || BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } )==0 )
		{
			// _dpn("終了命令");
			BMvTbl.SetFinalize( 0 );
			return;
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		SetHosei();
	}
}

// 相殺成功時に呼ばれて、相殺中に付与する無敵状態を無敵として扱わなくするフラグを付けたり消したりする
Std_MoveTable.Mv_Null_DelSousaiMutekiFlag <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			Battle_Std.MoveCodeEx.AddFlag( 6, def_MC6_SousaiMuteki );
			
			player.pop();
		}
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 4 ) // 3Fで十分だが、相殺と同時に暗転ぐらいだと不足するので念のため4Fにする
		{
			// _dpn("終了");
			BMvTbl.SetFinalize( 0 );
			return;
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			Battle_Std.MoveCodeEx.DelFlag( 6, def_MC6_SousaiMuteki );
			
			player.pop();
		}
	}
}


// 投げコマンドを入れた時、2グラと3グラ以外を防いでいるが、リバーサルタイミングのときに漏れやすいので色々対応する
// 色々影響がありそうなのでガードリバーサルのときだけ防ぐものとして作成
Std_MoveTable.Mv_Null_GuardReversalThrowBouhatsuChecker <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		
		BMvTbl.SetLP(0,0); // A+Dを離して再度押したりとかのチェック用
		_dpn("生成");
	}
	function FrameUpdate_Std()
	{
		local button_hold = 0;
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			button_hold = BMvTbl.CheckButtonHold( (1<<0)|(1<<3) );
			// _dpn("button_hold:"+button_hold);
			
			player.pop();
		}
		
		// 3ACDをやったあとレバーを2とか1にしてガードリバーサルになると、3Cではなく投げが漏れる
		// その対策でSetCommandFailTimeを延長する
		// ただ、普通にやると、3ACDのあとに再度A+Dを連打してもリバサで投げが出せなくなるので
		// また入力されたっぽい雰囲気を感じたら終わるようにした
		
		switch( BMvTbl.GetLP(0) )
		{
		case 0: // A+Dを離すまで
			if( button_hold == 0 )
			{
				BMvTbl.SetLP(0,1); // 次へ
			}
			break;
		case 1: // A+Dを離してから再度押すまで
			if( button_hold )
			{
				BMvTbl.SetLP(0,2); // 終わり
			}
			break;
		case 2:
			break;
		}
		
		
		// ガード硬直中のみ有効
		// あんまり長いガードは無視
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount > 90 || !Battle_Std.CheckPlayerisGuard() || BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } )==0 || BMvTbl.GetLP(0)>=2 )
		{
			BMvTbl.SetCommandFailTime( { command=def_CN_Throw_F, time=0 } );
			BMvTbl.SetFinalize();
		}
		else
		{
			
			if( player.push() )
			{
				_dpn("暴発を防ぐ");
				BMvTbl.SetCommandFailTime( { command=def_CN_Throw_F, time=1 } );
				
				player.pop();
			}
		}
	}
	function Finalize_Std()
	{
		_dpn("終わり");
		BMvTbl.SetDeleteMoveTable();
	}
}

_dp1p("\n btl_UkemiFunc.....OK");
//Battle_Std.SetVector <- ukemi_tbl.SetVector;



//定義したテーブルを返す
return Std_MoveTable;

}//end


// 壁激突やられベクトルを返す
function Battle_Std::GetWallBoundVector()
{
	return 255; // 文字列でも大丈夫
}
